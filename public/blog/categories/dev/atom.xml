<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: dev | Solarex's Blog]]></title>
  <link href="http://Solarex.github.io/blog/categories/dev/atom.xml" rel="self"/>
  <link href="http://Solarex.github.io/"/>
  <updated>2014-10-16T14:45:04+08:00</updated>
  <id>http://Solarex.github.io/</id>
  <author>
    <name><![CDATA[Solarex]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[Android Context]]></title>
    <link href="http://Solarex.github.io/blog/2014/10/14/android-context/"/>
    <updated>2014-10-14T10:11:00+08:00</updated>
    <id>http://Solarex.github.io/blog/2014/10/14/android-context</id>
    <content type="html"><![CDATA[<center><p><img src="http://Solarex.github.io/images/android_robot.png" width="255" height="300"></p></center>


<p>Context is probably the most used element in Android applications…it may also be the most misused.Context objects are so common, and get passed around so frequently, it can be easy to create a situation you didn’t intend.  Loading resources, launching a new Activity, obtaining a system service, getting internal file paths, and creating views all require a Context (and that’s not even getting started on the full list!) to accomplish the task.  What I’d like to do is provide for you some insights on how Context works alongside some tips that will (hopefully) allow you to leverage it more effectively in your applications.</p>

<!-- more -->


<h2>Context Types</h2>

<p>Not all Context instances are created equal.  Depending on the Android application component, the Context you have access to varies slightly:</p>

<ul>
<li><p><strong>Application</strong> – is a singleton instance running in your application process.  It can be accessed via methods like getApplication() from an Activity or Service, and getApplicationContext() from any other object that inherits from Context.  Regardless of where or how it is accessed, you will always receive the same instance from within your process.</p></li>
<li><p><strong>Activity/Service</strong> – inherit from ContextWrapper which implements the same API, but proxies all of its method calls to a hidden internal Context instance, also known as its base context.  Whenever the framework creates a new Activity or Service instance, it also creates a new ContextImpl instance to do all of the heavy lifting that either component will wrap.  Each Activity or Service, and their corresponding base context, are unique per-instance.</p></li>
<li><p><strong>BroadcastReceiver</strong> – is not a Context in and of itself, but the framework passes a Context to it in onReceive() each time a new broadcast event comes in.  This instance is a ReceiverRestrictedContext with two main functions disabled; calling registerReceiver() and bindService().  These two functions are not allowed from within an existing BroadcastReceiver.onReceive().  Each time a receiver processes a broadcast, the Context handed to it is a new instance.</p></li>
<li><p><strong>ContentProvider</strong> – is also not a Context but is given one when created that can be accessed via <code>getContext()</code>.  If the <code>ContentProvider</code> is running local to the caller (i.e. same application process), then this will actually return the same Application singleton.  However, if the two are in separate processes, this will be a newly created instance representing the package the provider is running in.</p></li>
</ul>


<h2>Saved References</h2>

<p>The first issue we need to address comes from saving a reference to a <code>Context</code> in an object or class that has a lifecycle that extends beyond that of the instance you saved.  For example, creating a custom singleton that requires a <code>Context</code> to load resources or access a <code>ContentProvider</code>, and saving a reference to the current <code>Activity</code> or <code>Service</code> in that singleton.</p>

<p>Bad Singleton</p>

<p>```java
public class CustomManager {</p>

<pre><code>private static CustomManager sInstance;

public static CustomManager getInstance(Context context) {
    if (sInstance == null) {
        sInstance = new CustomManager(context);
    }

    return sInstance;
}

private Context mContext;

private CustomManager(Context context) {
    mContext = context;
}
</code></pre>

<p>}
```</p>

<p>The problem here is we don’t know where that <code>Context</code> came from, and it is not safe to hold a reference to the object if it ends up being an <code>Activity</code> or a <code>Service</code>.  This is a problem because a singleton is managed by a single static reference inside the enclosing class.  This means that our object, and ALL the other objects referenced by it, will never be garbage collected.  If this <code>Context</code> were an Activity, we would effectively hold hostage in memory all the views and other potentially large objects associated with it; creating a leak.</p>

<p>To protect against this, we modify the singleton to always reference the application context:</p>

<p>Better Singleton</p>

<p>```java
public class CustomManager {</p>

<pre><code>private static CustomManager sInstance;

public static CustomManager getInstance(Context context) {
    if (sInstance == null) {
        //Always pass in the Application Context
        sInstance = new CustomManager(context.getApplicationContext());
    }

    return sInstance;
}

private Context mContext;

private CustomManager(Context context) {
    mContext = context;
}
</code></pre>

<p>}
```</p>

<p>Now it doesn’t matter where our <code>Context</code> came from, because the reference we are holding is safe.  The application context is itself a singleton, so we aren’t leaking anything by creating another static reference to it.  Another great example of places where this can crop up is saving references to a <code>Context</code> from inside a running background thread or a pending Handler.</p>

<p>So why can’t we always just reference the application context?  Take the middleman out of the equation, as it were, and never have to worry about creating leaks?  The answer, as I alluded to in the introduction, is because one <code>Context</code> is not equal to another.</p>

<h2>Context Capabilities</h2>

<p>The common actions you can safely take with a given <code>Context</code> object depends on where it came from originally.  Below is a table of the common places an application will receive a <code>Context</code>, and in each case what it is useful for:</p>

<table border="1" width="90%" align="center">
<thead>
<tr>
<th></th>
<th align="center">Application</th>
<th align="center">Activity</th>
<th align="center">Service</th>
<th align="center">ContentProvider</th>
<th align="center">BroadcastReceiver</th>
</tr>
</thead>
<tbody>
<tr>
<td>Show a Dialog</td>
<td align="center">NO</td>
<td align="center">YES</td>
<td align="center">NO</td>
<td align="center">NO</td>
<td align="center">NO</td>
</tr>
<tr>
<td>Start an Activity</td>
<td align="center">NO<sup>1</sup></td>
<td align="center">YES</td>
<td align="center">NO<sup>1</sup></td>
<td align="center">NO<sup>1</sup></td>
<td align="center">NO<sup>1</sup></td>
</tr>
<tr>
<td>Layout Inflation</td>
<td align="center">NO<sup>2</sup></td>
<td align="center">YES</td>
<td align="center">NO<sup>2</sup></td>
<td align="center">NO<sup>2</sup></td>
<td align="center">NO<sup>2</sup></td>
</tr>
<tr>
<td>Start a Service</td>
<td align="center">YES</td>
<td align="center">YES</td>
<td align="center">YES</td>
<td align="center">YES</td>
<td align="center">YES</td>
</tr>
<tr>
<td>Bind to a Service</td>
<td align="center">YES</td>
<td align="center">YES</td>
<td align="center">YES</td>
<td align="center">YES</td>
<td align="center">NO</td>
</tr>
<tr>
<td>Send a Broadcast</td>
<td align="center">YES</td>
<td align="center">YES</td>
<td align="center">YES</td>
<td align="center">YES</td>
<td align="center">YES</td>
</tr>
<tr>
<td>Register BroadcastReceiver</td>
<td align="center">YES</td>
<td align="center">YES</td>
<td align="center">YES</td>
<td align="center">YES</td>
<td align="center">NO<sup>3</sup></td>
</tr>
<tr>
<td>Load Resource Values</td>
<td align="center">YES</td>
<td align="center">YES</td>
<td align="center">YES</td>
<td align="center">YES</td>
<td align="center">YES</td>
</tr>
</tbody>
</table>


<ul>
<li>An application CAN start an <code>Activity</code> from here, but it requires that a new task be created.  This may fit specific use cases, but can create non-standard back stack behaviors in your application and is generally not recommended or considered good practice.</li>
<li>This is legal, but inflation will be done with the default theme for the system on which you are running, not what’s defined in your application.</li>
<li>Allowed if the receiver is null, which is used for obtaining the current value of a sticky broadcast, on Android 4.2 and above.</li>
</ul>


<h2>User Interface</h2>

<p>You can see from looking at the previous table that there are a number of functions the application context is not properly suited to handle; all of them related to working with the UI.  In fact, the only implementation equipped to handle all tasks associated with the UI is <code>Activity</code>; the other instances fare pretty much the same in all categories.</p>

<p>Luckily, these three actions are things an application doesn’t really have any place doing outside the scope of an <code>Activity</code>; it’s almost like the framework was designed that way on purpose.  Attempting to show a Dialog that was created with a reference to the application context, or starting an <code>Activity</code> from the application context will throw an exception and crash your application…a strong indicator something has gone wrong.</p>

<p>The less obvious issue is inflating layouts.  If you read my last piece on layout inflation, you already know that it can be a slightly mysterious process with some hidden behaviors;  using the right <code>Context</code> is linked to another one of those behaviors.  While the framework will not complain and will return a perfectly good view hierarchy from a <code>LayoutInflater</code> created with the application context, the themes and styles from your app will not be considered in the process.  This is because <code>Activity</code> is the only <code>Context</code> on which the themes defined in your manifest are actually attached.  Any other instance will use the system default theme to inflate your views, leading to a display output you probably didn’t expect.</p>

<h2>The Intersection of these Rules</h2>

<p>Invariably, someone will arrive at the conclusion that these two rules conflict.  There is a case in the application’s current design where a long-term reference must be saved and we must save an <code>Activity</code> because the tasks we want to accomplish include manipulation of the UI.  If that is the case, I would urge you to reconsider your design, as this would be a textbook instance of fighting the framework.</p>

<h2>The Rule of Thumb</h2>

<p>In most cases, use the <code>Context</code> directly available to you from the enclosing component you’re working within.  You can safely hold a reference to it as long as that reference does not extend beyond the lifecycle of that component. As soon as you need to save a reference to a <code>Context</code> from an object that lives beyond your <code>Activity</code> or <code>Service</code>, even temporarily, switch that reference you save over to the application context.</p>

<p>Context对象是最常见的对象，经常用于参数传递，因此也会出现一些你意想不到的情况。加载资源文件，启动一个新的Activity，获取一个系统服务，获取内部文件路径和创建view全部（这些仅仅是一部分）都需要一个Context对象来完成这些操作。我们想做的是给你展示Context如何工作，以及提供一些建议会（希望会）让你在开发中更合理的使用Context。</p>

<h2>Context类型</h2>

<p>并不是所有的Context对象都相同，根据Android应用组件的不同，可以分为以下几种：</p>

<ul>
<li><strong>Application</strong>：它是应用程序的一个单例，它可以通过<code>Activity</code>或<code>Service</code>的<code>getApplication()</code>方法获取，也可以在任何继承<code>Context</code>类的的对象中通过<code>getApplicationContext()</code>来获取。不管它是怎么获取的，这些方法返回的都是App中同一个实例。</li>
<li><strong>Activity/Service</strong>：它们继承自<code>ContextWrapper</code>，<code>ContextWrapper</code>实现了<code>Context</code>同样的API，但是隐藏了内部<code>Context</code>对象的方法调用，<code>Context</code>也是<code>ContextWrapper</code>的父类。每当系统创建一个<code>Activity</code>或<code>Service</code>对象的时候，它也为它们创建了新的<code>ContextWrapper</code>对象。每个<code>Activity</code>或<code>Service</code>对象，包括他们对应的context对象都是唯一的。</li>
<li><strong>BroadcastReceiver</strong>：它并不拥有<code>Context</code>对象，但是系统在一个新的广播到来的时候通过<code>onReceiver()</code>方法传入一个<code>Context</code>对象，这是一个<code>ReceiverRestrictedContext</code>，它的两个主要方法，<code>registerReceiver()</code>和<code>bindService()</code>都被禁用了。每一次receiver处理一个广播，传入的<code>Context</code>对象都是一个新的实例。</li>
<li><strong>ContentProvider</strong>：同样也不是一个<code>Context</code>对象，但是在创建的时候会通过<code>getContext()</code>方法传入一个context对象。如果<code>ContentProvider</code>是在本地调用的话（在同一个进程中），那么这会返回一个应用单例。然而，如果是在不同的进程中调用的话，它会新建一个context对象表示当前provider运行的进程。</li>
</ul>


<h2>Saved References</h2>

<p>第一个问题是，我们想在一个对象中保存一个Context对象的引用，并且这个对象的生命周期超过了你保存的Context对象。比如：创建一个需要一个Context对象的单例来加载文件资源或访问一个<code>ContentProvider</code>，并且在这个单例中保存当前<code>Activity</code>或<code>Service</code>的引用。</p>

<p>Bad Singleton这里的问题在于，我们并不知道Context从哪里来，并且如果单例保存了Activity或Service的引用，如果它们被销毁了，这样是不安全的。这个问题是因为单例在类里面保存了一个静态引用。这就意味着那个对象，以及这个对象引用的所有对象都不会被gc回收。如果Context对象是一个Activity，我们就会始终持有这个Activity的所有View以及其他可能很大的对象，最终导致内存泄露。</p>

<p>为了防止出现这种情况，我们可以修改这个类让它持有Application Context,Better Singleton：现在，不管context对象是从哪里传入的，因为现在单例持有的是Application Context，这个是安全的，因为Application Context 本身就是一个单例，因此不会造成内存泄露。还有一个类似的问题就是在一个后台线程（background thread）或一个延时Handler中持有一个对Context的引用。
既然Application Context有那么多好处，我们为什么不用Application Context来处理一切呢？这个问题的答案就是，前面提到过的，是因为<strong>这些Context并不都是相同的。</strong></p>

<p>从上文中可以知道，Context有多种来源，而不同来源的Context所具有的通用操作也不一样，下表列出了各种不同Context 的作用域：这几个Context只有Activity的Context是“看的见的”，其他组件的Context都是“看不见的”。因此，如果你想创建一个比如Dialog，Activity等“看的见”的组件就必须要用Activity的Context。比如，你想调用getString或getResource方法获取res文件夹下的资源时，所有的Context对象都可以使用。因为这些东西都是“看不见”的。</p>

<h2>用户界面</h2>

<p>你可以从上面的表格中看到Application Context有很多事情是做不了的，它不能做的事情都与UI有关。事实上，只有Activity才能够处理与UI有关的任务，其他的Context都是非常相似的（不能处理与UI有关的任务）。
这3个任务（“Show a Dialog”，“Start a Activity”，“Layout Inflation”）似乎就是Android系统就是这么设计的，让Activity来处理这些与UI有关的任务。想要使用Application Context对象来新建一个Dialog或者启动一个Activity系统就会抛出异常，然后程序就会崩溃。
Infalting layouts是一个容易被忽略的问题，如果你读过这篇文章<a href="http://www.doubleencore.com/2013/05/layout-inflation-as-intended/">layout inflation</a>，你就会明白这里面隐藏着一些坑…使用不同的Context就是会带你走向不同坑。当你使用LayoutInflator，并且使用Application Context后，它会返回一个View，但是这个View的主题和样式就会被忽略。这是因为，Activity 才是系统配置文件中的唯一持有主题和样式的Context。其他所有的Context都会使用系统默认的主题来渲染你的xml来生成View，最终就导致了界面并不是你想要的。</p>

<h2>结论</h2>

<p>很多情况下，你可以在一个组件内部使用Context对象，你可以很安全的持有Context的引用，前提就是你的对象生命周期小于Context的生命周期。如果你的对象需要持有一个比Context生命周期要长的Context引用时，即使你的对象也是一个临时对象，也请你考虑保存Application Context 的引用！</p>

<p>REF:<a href="http://www.doubleencore.com/2013/06/context/">Context</a></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Java thread tutorial]]></title>
    <link href="http://Solarex.github.io/blog/2014/10/14/java-thread-tutorial/"/>
    <updated>2014-10-14T08:49:00+08:00</updated>
    <id>http://Solarex.github.io/blog/2014/10/14/java-thread-tutorial</id>
    <content type="html"><![CDATA[<center><p><img src="http://Solarex.github.io/images/java-thread-tutorial.png" ></p></center>


<ul>
<li><a href="#overview">Java Thread and Multithreading Tutorial</a>

<ul>
<li><a href="#example">Java Thread Example</a></li>
<li><a href="#sleep">Java Thread Sleep</a></li>
<li><a href="#join">Java Thread Join</a></li>
<li><a href="#states">Java Thread States</a></li>
<li><a href="#wait">Java Thread wait, notify and notifyAll</a></li>
<li><a href="#safety">Java Thread Safety and Java Synchronization</a></li>
<li><a href="#exception">Java Exception in thread main</a></li>
<li><a href="#singleton">Thread Safety in Singleton Class</a></li>
<li><a href="#daemon">Java Daemon Thread</a></li>
<li><a href="#threadlocal">Java Thread Local</a></li>
<li><a href="#dump">Java Thread Dump</a></li>
<li><a href="#deadlock">How to Analyze Deadlock and avoid it in Java</a></li>
<li><a href="#timer">Java Timer Thread</a></li>
<li><a href="#producer">Java Producer Consumer Problem</a></li>
<li><a href="#pool">Java Thread Pool</a></li>
<li><a href="#future">Java Callable Future</a></li>
<li><a href="#futuretask">Java FutureTask Example</a></li>
</ul>
</li>
</ul>


<h2 id="overview">Java Thread and Multithreading Tutorial</h2>


<p>There are two types of threads in an application – <code>user thread</code> and <code>daemon thread</code>. When we start an application, main is the first user thread created and we can create multiple user threads as well as daemon threads. When all the user threads are executed, JVM terminates the program.</p>

<p>We can set different priorities to different Threads but it doesn’t guarantee that higher priority thread will execute first than lower priority thread. Thread scheduler is the part of Operating System implementation and when a Thread is started, it’s execution is controlled by Thread Scheduler and JVM doesn’t have any control on it’s execution.</p>

<!-- more -->




<h3 id="example">Java Thread Example</h3>


<p>Every java application has at least one thread – main thread. Although there are so many other threads running in background like memory management, system management, signal processing etc. But from application point of view – main is the first thread and we can create multiple threads from it.</p>

<p>Multithreading refers to two or more threads executing concurrently in a single program. A computer single core processor can execute only one thread at a time and time slicing is the OS feature to share processor time between different processes and threads.</p>

<p>Benefits of Threads</p>

<ul>
<li>Threads are lightweight compared to processes, it takes less time and resource to create a thread.</li>
<li>Threads share their parent process data and code</li>
<li>Context switching between threads is usually less expensive than between processes.</li>
<li>Thread intercommunication is relatively easy than process communication.</li>
</ul>


<p>Java provides two ways to create a thread programmatically.</p>

<ul>
<li>Implementing the <code>java.lang.Runnable</code> interface.</li>
<li>Extending the <code>java.lang.Thread</code> class.</li>
</ul>


<p><strong>Once we start any thread, it’s execution depends on the OS implementation of time slicing and we can’t control their execution. However we can set threads priority but even then it doesn’t guarantee that higher priority thread will be executed first.</strong></p>

<p>As you have noticed that thread doesn’t return any value but what if we want our thread to do some processing and then return the result to our client program, check our <a href="#future">Java Callable Future</a>.</p>

<h3 id="sleep">Java Thread Sleep</h3>


<p><code>java.lang.Thread sleep()</code> method can be used to pause the execution of current thread for specified time in milliseconds. The argument value for milliseconds can’t be negative, else it throws <code>IllegalArgumentException</code>.</p>

<p>There is another method <code>sleep(long millis, int nanos)</code> that can be used to pause the execution of current thread for specified milliseconds and nanoseconds. The allowed nano second value is between 0 and 999999.</p>

<p>Thread Sleep important points</p>

<ul>
<li>It always pause the current thread execution.</li>
<li>The actual time thread sleeps before waking up and start execution depends on system timers and schedulers. For a quiet system, the actual time for sleep is near to the specified sleep time but for a busy system it will be little bit more.</li>
<li>Thread sleep doesn’t lose any monitors or locks current thread has acquired.</li>
<li>Any other thread can interrupt the current thread in sleep, in that case <code>InterruptedException</code> is thrown.</li>
</ul>


<p>How Thread Sleep Works</p>

<p><code>Thread.sleep()</code> interacts with the thread scheduler to put the current thread in wait state for specified period of time. Once the wait time is over, thread state is changed to runnable state and wait for the CPU for further execution. So the actual time that current thread sleep depends on the thread scheduler that is part of operating system.</p>

<h3 id="join">Java Thread Join</h3>


<p>Java Thread <code>join</code> method can be used to pause the current thread execution until unless the specified thread is dead. There are three overloaded join functions.</p>

<ul>
<li><p><code>public final void join()</code>: This method puts the current thread on wait until the thread on which it’s called is dead. If the thread is interrupted, it throws <code>InterruptedException</code>.</p></li>
<li><p><code>public final synchronized void join(long millis)</code>: This method is used to wait for the thread on which it’s called to be dead or wait for specified milliseconds. Since thread execution depends on OS implementation, it doesn’t guarantee that the current thread will wait only for given time.</p></li>
<li><p><code>public final synchronized void join(long millis, int nanos)</code>: This method is used to wait for thread to die for given milliseconds plus nanoseconds.</p></li>
</ul>


<p>```java
package org.solarex.threadtest;</p>

<p>public class ThreadJoinExample {</p>

<pre><code>public static void main(String[] args) {
    Thread t1 = new Thread(new MyRunnable(), "t1");
    Thread t2 = new Thread(new MyRunnable(), "t2");
    Thread t3 = new Thread(new MyRunnable(), "t3");

    t1.start();

    //start second thread after waiting for 2 seconds or if it's dead
    try {
        t1.join(2000);
    } catch (InterruptedException e) {
        e.printStackTrace();
    }

    t2.start();

    //start third thread only when first thread is dead
    try {
        t1.join();
    } catch (InterruptedException e) {
        e.printStackTrace();
    }

    t3.start();

    //let all threads finish execution before finishing main thread
    try {
        t1.join();
        t2.join();
        t3.join();
    } catch (InterruptedException e) {
        e.printStackTrace();
    }

    System.out.println("All threads are dead, exiting main thread");
}
</code></pre>

<p>}</p>

<p>class MyRunnable implements Runnable{</p>

<pre><code>@Override
public void run() {
    System.out.println("Thread started:::"+Thread.currentThread().getName()+"@"+System.currentTimeMillis());
    try {
        Thread.sleep(4000);
    } catch (InterruptedException e) {
        e.printStackTrace();
    }
    System.out.println("Thread ended:::"+Thread.currentThread().getName()+"@"+System.currentTimeMillis());
}
</code></pre>

<p>}</p>

<hr />

<p>// output begin
hrh@Solarex:Java$ java org.solarex.threadtest.ThreadJoinExample
Thread started:::t1@1413344304212
Thread started:::t2@1413344306213
Thread ended:::t1@1413344308213
Thread started:::t3@1413344308214
Thread ended:::t2@1413344310213
Thread ended:::t3@1413344312214
All threads are dead, exiting main thread
// output end
```</p>

<h3 id="states">Java Thread States</h3>


<p>Thread States</p>

<p>Below diagram shows different states of thread in java, note that we can create a thread in java and start it but how the thread states change from Runnable to Running to Blocked depends on the OS implementation of thread scheduler and java doesn’t have full control on that.</p>

<center><p><img src="http://Solarex.github.io/images/thread-lifecycle-states.png"></p></center>


<ul>
<li><p><code>New</code>:When we create a new Thread object using new operator, thread state is New Thread. At this point, thread is not alive and it’s a state internal to Java programming.</p></li>
<li><p><code>Runnable</code>:When we call <code>start()</code> function on <code>Thread</code> object, it’s state is changed to <code>Runnable</code> and the control is given to <strong>Thread scheduler</strong> to finish it’s execution. Whether to run this thread instantly or keep it in runnable thread pool before running it depends on the OS implementation of thread scheduler.</p></li>
<li><p><code>Running</code>:When thread is executing, it’s state is changed to <code>Running</code>. Thread scheduler picks one of the thread from the runnable thread pool and change it’s state to Running and CPU starts executing this thread. A thread can change state to Runnable, Dead or Blocked from running state depends on time slicing, thread completion of run() method or waiting for some resources.</p></li>
<li><p><code>Blocked/Waiting</code>:A thread can be waiting for other thread to finish using thread <code>join</code> or it can be waiting for some resources to available, for example producer consumer problem or waiter notifier implementation or IO resources, then it’s state is changed to Waiting. Once the thread wait state is over, it’s state is changed to Runnable and it’s moved back to runnable thread pool.</p></li>
<li><p><code>Dead</code>:Once the thread finished executing, it’s state is changed to Dead and it’s considered to be not alive.</p></li>
</ul>


<h3 id="wait">Java Thread wait,notifyand notifyAll</h3>


<ul>
<li><p><strong>wait</strong>:Object <code>wait</code> methods has three variance, one which waits indefinitely for any other thread to call notify or notifyAll method on the object to wake up the current thread. Other two variances puts the current thread in wait for specific amount of time before they wake up.</p></li>
<li><p><strong>notify</strong>:<code>notify</code> method wakes up only one thread waiting on the object and that thread starts execution. So if there are multiple threads waiting for an object, this method will wake up only one of them. The choice of the thread to wake depends on the OS implementation of thread management.</p></li>
<li><p><strong>notifyAll</strong>:<code>notifyAll</code> method wakes up all the threads waiting on the object, although which one will process first depends on the OS implementation.</p></li>
</ul>


<p>```java
//Message.java
package org.solarex.threadtest;</p>

<p>public class Message{</p>

<pre><code>private String msg;

public Message(String str){
    this.msg = str;
}

public String getMsg(){
    return msg;
}

public void setMsg(String str){
    this.msg = str;
}
</code></pre>

<p>}
//Waiter.java
package org.solarex.threadtest;</p>

<p>public class Waiter implements Runnable{</p>

<pre><code>private Message msg;
public Waiter(Message m){
    this.msg = m;
}
@Override
public void run(){
    String name = Thread.currentThread().getName();
    synchronized(msg){
        try{
            System.out.println(name+" waiting to get notified @ " + System.currentTimeMillis());
            msg.wait();
        }catch(InterruptedException e){
            e.printStackTrace();
        }
        System.out.println(name+" waiter thread got notified @ " + System.currentTimeMillis());
        System.out.println(name+" proccessed: " + msg.getMsg());
    }
}
</code></pre>

<p>}
//Notifier.java
package org.solarex.threadtest;
public class Notifier implements Runnable{</p>

<pre><code>private Message msg;
public Notifier(Message msg){
    this.msg = msg;
}

@Override
public void run(){
    String name = Thread.currentThread().getName();
    System.out.println(name+" started");
    try{
        Thread.sleep(1000);
        synchronized(msg){
            msg.setMsg(name+" notifier work done");
            // msg.notify();
            msg.notifyAll();
        }
    }catch (InterruptedException e){
        e.printStackTrace();
    }
}
</code></pre>

<p>}
//WaitNotifierTest.java
package org.solarex.threadtest;
public class WaitNotifyTest {</p>

<pre><code>public static void main(String[] args){
    Message msg = new Message("Hi");
    Waiter waiter0 = new Waiter(msg);
    new Thread(waiter0, "waiter0").start();

    Waiter waiter1 = new Waiter(msg);
    new Thread(waiter1, "waiter1").start();

    Notifier notifier = new Notifier(msg);
    new Thread(notifier, "notifier").start();

    System.out.println("main thread exit");
}
</code></pre>

<p>}</p>

<p>// javac -d . Message.java Waiter.java Notifier.java WaitNotifierTest.java
// java org.solarex.threadtest.WaitNotifierTest
// &mdash;&mdash;&mdash;&mdash;begin output&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;
hrh@Solarex:Java$ java org.solarex.threadtest.WaitNotifyTest
waiter0 waiting to get notified @ 1413423213359
waiter1 waiting to get notified @ 1413423213360
main thread exit
notifier started
waiter1 waiter thread got notified @ 1413423214362
waiter1 proccessed: notifier notifier work done
waiter0 waiter thread got notified @ 1413423214362
waiter0 proccessed: notifier notifier work done
// &mdash;&mdash;&mdash;&mdash;end output&mdash;&mdash;&mdash;&mdash;&mdash;
```</p>

<h3 id="safety">Java Thread Safety and Java Synchronization</h3>


<p>Thread safety is the process to make our program safe to use in multithreaded environment, there are different ways through which we can make our program thread safe.</p>

<ul>
<li>Synchronization is the easiest and most widely used tool for thread safety in java.</li>
<li>Use of Atomic Wrapper classes from <code>java.util.concurrent.atomic</code> package. For example <code>AtomicInteger</code></li>
<li>Use of locks from <code>java.util.concurrent.locks</code> package.</li>
<li>Using thread safe collection classes, check this post for usage of <code>ConcurrentHashMap</code> for thread safety.</li>
<li>Using volatile keyword with variables to make every thread read the data from memory, not read from thread cache.</li>
</ul>


<p>Synchronization is the tool using which we can achieve thread safety, JVM guarantees that synchronized code will be executed by only one thread at a time. java keyword synchronized is used to create synchronized code and internally it uses locks on Object or Class to make sure only one thread is executing the synchronized code.
+ Java synchronization works on locking and unlocking of resource, before any thread enters into synchronized code, it has to acquire lock on the Object and when code execution ends, it unlocks the resource that can be locked by other threads. In the mean time other threads are in wait state to lock the synchronized resource.
+ We can use synchronized keyword in two ways, one is to make a complete method synchronized and other way is to create synchronized block.可以创建synchronized方法或者synchronized代码块
+ When a method is synchronized, it locks the Object, if method is static it locks the Class, so it’s always best practice to use synchronized block to lock the only sections of method that needs synchronization.
+ While creating synchronized block, we need to provide the resource on which lock will be acquired, it can be XYZ.class or any Object field of the class.
+ <code>synchronized(this)</code> will lock the Object before entering into the synchronized block.
+ You should use the lowest level of locking, for example if there are multiple synchronized block in a class and one of them is locking the Object, then other synchronized blocks will also be not available for execution by other threads. When we lock an Object, it acquires lock on all the fields of the Object.
+ Java Synchronization provides data integrity on the cost of performance, so it should be used only when it’s absolutely necessary.
+ Java Synchronization works only in the same JVM, so if you need to lock some resource in multiple JVM environment, it will not work and you might have to look after some global locking mechanism.
+ Java Synchronization could result in deadlocks, check this post about <a href="#deadlock">deadlock in java and how to avoid them</a>.
+ Java synchronized keyword cannot be used for constructors and variables.
+ It is preferable to create a dummy private Object to use for synchronized block, so that it’s reference can’t be changed by any other code. For example if you have a setter method for Object on which you are synchronizing, it’s reference can be changed by some other code leads to parallel execution of the synchronized block.
+ We should not use any object that is maintained in a constant pool, for example String should not be used for synchronization because if any other code is also locking on same String, it will try to acquire lock on the same reference object from String pool and even though both the codes are unrelated, they will lock each other.</p>

<p>```java
//dummy object variable for synchronization
private Object mutex=new Object();
&hellip;
//using synchronized block to read, increment and update count value synchronously
synchronized (mutex) {</p>

<pre><code>    count++;
</code></pre>

<p>}
```</p>

<p>```java
public class MyObject {</p>

<p>  // Locks on the object&rsquo;s monitor
  public synchronized void doSomething() {</p>

<pre><code>// ...
</code></pre>

<p>  }
}</p>

<p>// Hackers code
MyObject myObject = new MyObject();
synchronized (myObject) {
  while (true) {</p>

<pre><code>// Indefinitely delay myObject
Thread.sleep(Integer.MAX_VALUE); 
</code></pre>

<p>  }
}
```</p>

<p>Notice that hacker’s code is trying to lock the myObject instance and once it gets the lock, it’s never releasing it causing <code>doSomething()</code> method to block on waiting for the lock, this will cause system to go on deadlock and cause Denial of Service (DoS).</p>

<p>```java
public class MyObject {
  public Object lock = new Object();</p>

<p>  public void doSomething() {</p>

<pre><code>synchronized (lock) {
  // ...
}
</code></pre>

<p>  }
}</p>

<p>//untrusted code</p>

<p>MyObject myObject = new MyObject();
//change the lock Object reference
myObject.lock = new Object();
```</p>

<p>Notice that lock Object is public and by changing it’s reference, we can execute synchronized block parallel in multiple threads. Similar case is true if you have private Object but have setter method to change it’s reference.</p>

<p>```java
public class MyObject {
  //locks on the class object&rsquo;s monitor
  public static synchronized void doSomething() {</p>

<pre><code>// ...
</code></pre>

<p>  }
}</p>

<p>// hackers code
synchronized (MyObject.class) {
  while (true) {</p>

<pre><code>Thread.sleep(Integer.MAX_VALUE); // Indefinitely delay MyObject
</code></pre>

<p>  }
}
```</p>

<p>Notice that hacker code is getting lock on class monitor and not releasing it, it will cause deadlock and DoS in the system.</p>

<h3 id="exception">Java Exception in thread main</h3>


<p>These are some of the common java exceptions in thread main, whenever you face any one of these check following:</p>

<ul>
<li>Same JRE version is used to compile and run the java program</li>
<li>You are running java class from the classes directory and package is provided as directory.</li>
<li>Your java classpath is set properly to include all the dependency classes</li>
<li>You are using only file name without .class extension while running a java program</li>
<li>Java class main method syntax is correct</li>
</ul>


<h3 id="singleton">Thread Safety in Singleton Class</h3>


<p><strong>Singleton</strong> is one of the most widely used creational design pattern to restrict the object creation by applications. In real world applications, resources like Database connections or Enterprise Information Systems (EIS) are limited and should be used wisely to avoid any resource crunch. To achieve this, we can implement Singleton design pattern to create a wrapper class around the resource and limit the number of object created at runtime to one.</p>

<p>In general we follow below steps to create a singleton class:</p>

<ul>
<li>Override the private constructor to avoid any new object creation with new operator.</li>
<li>Declare a private static instance of the same class</li>
<li><p>Provide a public static method that will return the singleton class instance variable. If the variable is not initialized then initialize it or else simply return the instance variable.</p></li>
<li><p>Create the instance variable at the time of class loading:</p></li>
<li><strong>Pros</strong>:Thread safety without synchronization,Easy to implement</li>
<li><p><strong>Cons</strong>:Early creation of resource that might not be used in the application,The client application can’t pass any argument, so we can’t reuse it. For example, having a generic singleton class for database connection where client application supplies database server properties.</p></li>
<li><p>Synchronize the <code>getInstance()</code> method:</p></li>
<li><strong>Pros</strong>:Thread safety is guaranteed,Client application can pass parameters,Lazy initialization achieved</li>
<li><p><strong>Cons</strong>:Slow performance because of locking overhead,Unnecessary synchronization that is not required once the instance variable is initialized.</p></li>
<li><p>Use synchronized block inside the if loop:</p></li>
<li><strong>Pros</strong>:Thread safety is guaranteed,Client application can pass arguments,Lazy initialization achieved,Synchronization overhead is minimal and applicable only for first few threads when the variable is null.</li>
<li><strong>Cons</strong>:Extra if condition</li>
</ul>


<p>```java
public class ASingleton{</p>

<pre><code>private static ASingleton instance= null;
private static Object mutex= new Object();
private ASingleton(){
}

public static ASingleton getInstance(){
    if(instance==null){
        synchronized (mutex){
            if(instance==null) instance= new ASingleton();
        }
    }
    return instance;
}
</code></pre>

<p>}
```</p>

<h3 id="daemon">Java Daemon Thread</h3>


<p>When we create a Thread in java, by default it’s a user thread and if it’s running JVM will not terminate the program. When a thread is marked as daemon thread, JVM doesn’t wait it to finish and as soon as all the user threads are finished, it terminates the program as well as all the associated daemon threads</p>

<p>```java
package org.solarex.threadtest;
public class JavaDaemonThread{</p>

<pre><code>public static void main(String[] args) throws InterruptedException{
    Thread dt = new Thread(new DaemonThread(), "dt");
    dt.setDaemon(true);
    dt.start();
    Thread.sleep(30000);
    System.out.println("main thread exit");
}
</code></pre>

<p>}
class DaemonThread implements Runnable{</p>

<pre><code>@Override
public void run(){
    while(true){
        processSth();
    }
}

private void processSth(){
    try{
        System.out.println("process @ " + System.currentTimeMillis());
        Thread.sleep(5000);
    }catch(Exception e){
        e.printStackTrace();
    }
}
</code></pre>

<p>}</p>

<p>//&mdash;&mdash;&mdash;&mdash;&mdash;begin output&mdash;&mdash;&mdash;&mdash;&mdash;&ndash;
hrh@Solarex:Java$ java org.solarex.threadtest.JavaDaemonThread
process @ 1413426032024
process @ 1413426037024
process @ 1413426042024
process @ 1413426047025
process @ 1413426052025
process @ 1413426057025
main thread exit
//&mdash;&mdash;&mdash;&mdash;&mdash;end output&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&ndash;
```</p>

<p>If we don’t set the thread to be run as daemon thread, the program will never terminate even after main thread is finished it’s execution. Usually we create a daemon thread for functionalities that are not critical to system, for example logging thread or monitoring thread to capture the system resource details and their state.</p>

<h3 id="threadlocal">Java Thread Local</h3>


<p>Java <code>ThreadLocal</code> is used to create thread-local variables. We know that all threads of an Object share it’s variables, so if the variable is not thread safe, we can use synchronization but if we want to avoid synchronization, we can use ThreadLocal variables.Every thread has it’s own <code>ThreadLocal</code> variable and they can use it’s <code>get()</code> and <code>set()</code> methods to get the default value or change it’s value local to Thread. <code>ThreadLocal</code> instances are typically private static fields in classes that wish to associate state with a thread.</p>

<p>```java
package org.solarex.threadtest;</p>

<p>import java.text.SimpleDateFormat;
import java.util.Random;</p>

<p>public class ThreadLocalExample implements Runnable{</p>

<pre><code>// SimpleDateFormat is not thread-safe, so give one to each thread
private static final ThreadLocal&lt;SimpleDateFormat&gt; formatter = new ThreadLocal&lt;SimpleDateFormat&gt;(){
    @Override
    protected SimpleDateFormat initialValue()
    {
        return new SimpleDateFormat("yyyyMMdd HHmm");
    }
};

public static void main(String[] args) throws InterruptedException {
    ThreadLocalExample obj = new ThreadLocalExample();
    for(int i=0 ; i&lt;10; i++){
        Thread t = new Thread(obj, ""+i);
        Thread.sleep(new Random().nextInt(1000));
        t.start();
    }
}

@Override
public void run() {
    System.out.println("Thread Name= "+Thread.currentThread().getName()+" default Formatter = "+formatter.get().toPattern());
    try {
        Thread.sleep(new Random().nextInt(1000));
    } catch (InterruptedException e) {
        e.printStackTrace();
    }

    formatter.set(new SimpleDateFormat());

    System.out.println("Thread Name= "+Thread.currentThread().getName()+" formatter = "+formatter.get().toPattern());
}
</code></pre>

<p>}
//&mdash;&mdash;&mdash;begin output&mdash;&mdash;&mdash;&mdash;&mdash;
hrh@Solarex:Java$ java org.solarex.threadtest.ThreadLocalExample
Thread Name= 0 default Formatter = yyyyMMdd HHmm
Thread Name= 1 default Formatter = yyyyMMdd HHmm
Thread Name= 1 formatter = M/d/yy h:mm a
Thread Name= 0 formatter = M/d/yy h:mm a
Thread Name= 2 default Formatter = yyyyMMdd HHmm
Thread Name= 3 default Formatter = yyyyMMdd HHmm
Thread Name= 2 formatter = M/d/yy h:mm a
Thread Name= 4 default Formatter = yyyyMMdd HHmm
Thread Name= 3 formatter = M/d/yy h:mm a
Thread Name= 4 formatter = M/d/yy h:mm a
Thread Name= 5 default Formatter = yyyyMMdd HHmm
Thread Name= 6 default Formatter = yyyyMMdd HHmm
Thread Name= 5 formatter = M/d/yy h:mm a
Thread Name= 7 default Formatter = yyyyMMdd HHmm
Thread Name= 8 default Formatter = yyyyMMdd HHmm
Thread Name= 7 formatter = M/d/yy h:mm a
Thread Name= 6 formatter = M/d/yy h:mm a
Thread Name= 8 formatter = M/d/yy h:mm a
Thread Name= 9 default Formatter = yyyyMMdd HHmm
Thread Name= 9 formatter = M/d/yy h:mm a
//&mdash;&mdash;&mdash;end output&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;
```</p>

<p>As you can see from the output that Thread-0 has changed the value of formatter but still thread-2 default formatter is same as the initialized value.</p>

<h3 id="dump">Java Thread Dump</h3>


<p>Java comes with <code>jstack</code> tool through which we can generate thread dump for a java process. This is a two step process.</p>

<ul>
<li>Find out the PID of the java process using <code>ps -eaf | grep java</code> command</li>
<li>Run <code>jstack</code> tool as <code>jstack PID</code> to generate the thread dump output to console, you can append thread dump output to file using command <code>jstack PID &gt;&gt; mydumps.tdump</code></li>
</ul>


<h3 id="deadlock">How to Analytize Deadlock and avoid it in Java</h3>


<p>Deadlock is a programming situation where two or more threads are blocked forever, this situation arises with at least two threads and two or more resources.</p>

<p>```java
package org.solarex.threadtest;</p>

<p>public class ThreadDeadlock {</p>

<pre><code>public static void main(String[] args) throws InterruptedException {
    Object obj1 = new Object();
    Object obj2 = new Object();
    Object obj3 = new Object();

    Thread t1 = new Thread(new SyncThread(obj1, obj2), "t1");
    Thread t2 = new Thread(new SyncThread(obj2, obj3), "t2");
    Thread t3 = new Thread(new SyncThread(obj3, obj1), "t3");

    t1.start();
    Thread.sleep(5000);
    t2.start();
    Thread.sleep(5000);
    t3.start();

}
</code></pre>

<p>}</p>

<p>class SyncThread implements Runnable{</p>

<pre><code>private Object obj1;
private Object obj2;

public SyncThread(Object o1, Object o2){
    this.obj1=o1;
    this.obj2=o2;
}
@Override
public void run() {
    String name = Thread.currentThread().getName();
    System.out.println(name + " acquiring lock on "+obj1);
    synchronized (obj1) {
     System.out.println(name + " acquired lock on "+obj1);
     work();
     System.out.println(name + " acquiring lock on "+obj2);
     synchronized (obj2) {
        System.out.println(name + " acquired lock on "+obj2);
        work();
    }
     System.out.println(name + " released lock on "+obj2);
    }
    System.out.println(name + " released lock on "+obj1);
    System.out.println(name + " finished execution.");
}
private void work() {
    try {
        Thread.sleep(30000);
    } catch (InterruptedException e) {
        e.printStackTrace();
    }
}
</code></pre>

<p>}
```</p>

<p>For analyzing deadlock, we need to look out for the threads with state as <code>BLOCKED</code> and then the resources it’s waiting to lock, every resource has a unique ID using which we can find which thread is already holding the lock on the object.</p>

<p>These are some of the guidelines using which we can avoid most of the deadlock situations.</p>

<ul>
<li><strong>Avoid Nested Locks</strong>: This is the most common reason for deadlocks, avoid locking another resource if you already hold one. It’s almost impossible to get deadlock situation if you are working with only one object lock.</li>
<li><strong>Lock Only What is Required</strong>: You should acquire lock only on the resources you have to work on, for example in above program I am locking the complete Object resource but if we are only interested in one of it’s fields, then we should lock only that specific field not complete object.</li>
<li><strong>Avoid waiting indefinitely</strong>: You can get deadlock if two threads are waiting for each other to finish indefinitely using thread join. If your thread has to wait for another thread to finish, it’s always best to use join with maximum time you want to wait for thread to finish.</li>
</ul>


<h3 id="timer">Java Timer Thread</h3>


<p><code>java.util.Timer</code> is a utility class that can be used to schedule a thread to be executed at certain time in future. Java <code>Timer</code> class can be used to schedule a task to be run one-time or to be run at regular intervals.<code>java.util.TimerTask</code> is an abstract class that implements <code>Runnable</code> interface and we need to extend this class to create our own <code>TimerTask</code> that can be scheduled using java <code>Timer</code> class.Timer class is thread safe and multiple threads can share a single Timer object without need for external synchronization. Timer class uses <code>java.util.TaskQueue</code> to add tasks at given regular interval and at any time there can be only one thread running the <code>TimerTask</code>, for example if you are creating a Timer to run every 10 seconds but single thread execution takes 20 seconds, then Timer object will keep adding tasks to the queue and as soon as one thread is finished, it will notify the queue and another thread will start executing.</p>

<p>Timer class uses Object <strong>wait and notify</strong> methods to schedule the tasks.</p>

<p>```java
package org.solarex.threadtest;</p>

<p>import java.util.Date;
import java.util.Timer;
import java.util.TimerTask;</p>

<p>public class MyTimerTask extends TimerTask {</p>

<pre><code>@Override
public void run() {
    System.out.println("Timer task started at:"+new Date());
    completeTask();
    System.out.println("Timer task finished at:"+new Date());
}

private void completeTask() {
    try {
        //assuming it takes 20 secs to complete the task
        Thread.sleep(20000);
    } catch (InterruptedException e) {
        e.printStackTrace();
    }
}

public static void main(String args[]){
    TimerTask timerTask = new MyTimerTask();
    //running timer task as daemon thread
    Timer timer = new Timer(true);
    timer.scheduleAtFixedRate(timerTask, 0, 10*1000);
    System.out.println("TimerTask started");
    //cancel after sometime
    try {
        Thread.sleep(120000);
    } catch (InterruptedException e) {
        e.printStackTrace();
    }
    timer.cancel();
    System.out.println("TimerTask cancelled");
    try {
        Thread.sleep(30000);
    } catch (InterruptedException e) {
        e.printStackTrace();
    }
}
</code></pre>

<p>}</p>

<p>//&mdash;&mdash;&mdash;begin output&mdash;&mdash;&mdash;&mdash;&mdash;&ndash;
hrh@Solarex:Java$ java org.solarex.threadtest.MyTimerTask
TimerTask started
Timer task started at:Thu Oct 16 13:55:16 CST 2014
Timer task finished at:Thu Oct 16 13:55:36 CST 2014
Timer task started at:Thu Oct 16 13:55:36 CST 2014
Timer task finished at:Thu Oct 16 13:55:56 CST 2014
Timer task started at:Thu Oct 16 13:55:56 CST 2014
Timer task finished at:Thu Oct 16 13:56:16 CST 2014
Timer task started at:Thu Oct 16 13:56:16 CST 2014
Timer task finished at:Thu Oct 16 13:56:36 CST 2014
Timer task started at:Thu Oct 16 13:56:36 CST 2014
Timer task finished at:Thu Oct 16 13:56:56 CST 2014
Timer task started at:Thu Oct 16 13:56:56 CST 2014
TimerTask cancelled
Timer task finished at:Thu Oct 16 13:57:16 CST 2014
//&mdash;&mdash;&mdash;end output&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;
```</p>

<p>The output confirms that if a task is already executing, Timer will <strong>wait for it to finish and once finished</strong>, it will start again the next task from the queue.</p>

<p>Timer object can be created to run the associated tasks as a daemon thread. Timer <code>cancel()</code> method is used to terminate the timer and discard any scheduled tasks, however it doesn’t interfere with the currently executing task and let it finish. If the timer is run as daemon thread, whether we cancel it or not, it will terminate as soon as all the user threads are finished executing.</p>

<p>Timer class contains several <code>schedule()</code> methods to schedule a task to run once at given date or after some delay. There are several <code>scheduleAtFixedRate()</code> methods to run a task periodically with certain interval.</p>

<p>While scheduling tasks using Timer, you should make sure that time interval is more than normal thread execution, otherwise tasks queue size will keep growing and eventually task will be executing always.</p>

<h3 id="producer">Java Producer Consumer Problem</h3>


<p><code>java.util.concurrent.BlockingQueue</code> is a Queue that supports operations that wait for the queue to become non-empty when retrieving and removing an element, and wait for space to become available in the queue when adding an element.</p>

<p><code>BlockingQueue</code> doesn’t accept null values and throw <code>NullPointerException</code> if you try to store null value in the queue.<code>BlockingQueue</code> implementations are thread-safe. All queuing methods are atomic in nature and use internal locks or other forms of concurrency control.</p>

<p><code>BlockingQueue</code> interface is part of java collections framework and it’s primarily used for implementing producer consumer problem. We don’t need to worry about waiting for the space to be available for producer or object to be available for consumer in <code>BlockingQueue</code> as it’s handled by implementation classes of <code>BlockingQueue</code>.Java provides several <code>BlockingQueue</code> implementations such as <code>ArrayBlockingQueue</code>, <code>LinkedBlockingQueue</code>, <code>PriorityBlockingQueue</code>, <code>SynchronousQueue</code> etc.</p>

<p>While implementing producer consumer problem, we will use <code>ArrayBlockingQueue</code> implementation and following methods are important to know.</p>

<ul>
<li><code>put(E e)</code>: This method is used to insert elements to the queue, if the queue is full it waits for the space to be available.</li>
<li><code>E take()</code>: This method retrieves and remove the element from the head of the queue, if queue is empty it waits for the element to be available.</li>
</ul>


<p>```java
//Message.java
public class Message {</p>

<pre><code>private String msg;

public Message(String str){
    this.msg=str;
}

public String getMsg() {
    return msg;
}
</code></pre>

<p>}</p>

<p>//Producer.java
import java.util.concurrent.BlockingQueue;</p>

<p>public class Producer implements Runnable {</p>

<pre><code>private BlockingQueue&lt;Message&gt; queue;

public Producer(BlockingQueue&lt;Message&gt; q){
    this.queue=q;
}
@Override
public void run() {
    //produce messages
    for(int i=0; i&lt;100; i++){
        Message msg = new Message(""+i);
        try {
            Thread.sleep(i);
            queue.put(msg);
            System.out.println("Produced "+msg.getMsg());
        } catch (InterruptedException e) {
            e.printStackTrace();
        }
    }
    //adding exit message
    Message msg = new Message("exit");
    try {
        queue.put(msg);
    } catch (InterruptedException e) {
        e.printStackTrace();
    }
}
</code></pre>

<p>}</p>

<p>//Consumer.java
import java.util.concurrent.BlockingQueue;</p>

<p>public class Consumer implements Runnable{</p>

<p>private BlockingQueue<Message> queue;</p>

<pre><code>public Consumer(BlockingQueue&lt;Message&gt; q){
    this.queue=q;
}

@Override
public void run() {
    try{
        Message msg;
        //consuming messages until exit message is received
        while((msg = queue.take()).getMsg() !="exit"){
        Thread.sleep(10);
        System.out.println("Consumed "+msg.getMsg());
        }
    }catch(InterruptedException e) {
        e.printStackTrace();
    }
}
</code></pre>

<p>}</p>

<p>//ProducerConsumerService.java
import java.util.concurrent.ArrayBlockingQueue;
import java.util.concurrent.BlockingQueue;</p>

<p>public class ProducerConsumerService {</p>

<pre><code>public static void main(String[] args) {
    //Creating BlockingQueue of size 10
    BlockingQueue&lt;Message&gt; queue = new ArrayBlockingQueue&lt;&gt;(10);
    Producer producer = new Producer(queue);
    Consumer consumer = new Consumer(queue);
    //starting producer to produce messages in queue
    new Thread(producer).start();
    //starting consumer to consume messages from queue
    new Thread(consumer).start();
    System.out.println("Producer and Consumer has been started");
}
</code></pre>

<p>}
```</p>

<h3 id="pool">Java Thread Pool</h3>


<p>A thread pool manages the pool of worker threads, it contains a queue that keeps tasks waiting to get executed.</p>

<p>A thread pool manages the collection of <code>Runnable</code> threads and worker threads execute Runnable from the queue.</p>

<p><code>java.util.concurrent.Executors</code> provide implementation of <code>java.util.concurrent.Executor</code> interface to create the thread pool in java.</p>

<p>```java
// WorkerThread.java
public class WorkerThread implements Runnable {</p>

<pre><code>private String command;

public WorkerThread(String s){
    this.command=s;
}

@Override
public void run() {
    System.out.println(Thread.currentThread().getName()+" Start. Command = "+command);
    processCommand();
    System.out.println(Thread.currentThread().getName()+" End.");
}

private void processCommand() {
    try {
        Thread.sleep(5000);
    } catch (InterruptedException e) {
        e.printStackTrace();
    }
}

@Override
public String toString(){
    return this.command;
}
</code></pre>

<p>}</p>

<p>//SimpleThreadPool.java
import java.util.concurrent.ExecutorService;
import java.util.concurrent.Executors;</p>

<p>public class SimpleThreadPool {</p>

<pre><code>public static void main(String[] args) {
    ExecutorService executor = Executors.newFixedThreadPool(5);
    for (int i = 0; i &lt; 10; i++) {
        Runnable worker = new WorkerThread("" + i);
        executor.execute(worker);
      }
    executor.shutdown();
    while (!executor.isTerminated()) {
    }
    System.out.println("Finished all threads");
}
</code></pre>

<p>}
```</p>

<p>Executors class provide simple implementation of <code>ExecutorService</code> using <code>ThreadPoolExecutor</code> but <code>ThreadPoolExecutor</code> provides much more feature than that. We can specify the number of threads that will be alive when we create <code>ThreadPoolExecutor</code> instance and we can limit the size of thread pool and create our own <code>RejectedExecutionHandler</code> implementation to handle the jobs that can’t fit in the worker queue.</p>

<p>```java
// RejectedExecutionHandlerImpl.java
import java.util.concurrent.RejectedExecutionHandler;
import java.util.concurrent.ThreadPoolExecutor;</p>

<p>public class RejectedExecutionHandlerImpl implements RejectedExecutionHandler {</p>

<pre><code>@Override
public void rejectedExecution(Runnable r, ThreadPoolExecutor executor) {
    System.out.println(r.toString() + " is rejected");
}
</code></pre>

<p>}</p>

<p>// MyMonitorThread.java
import java.util.concurrent.ThreadPoolExecutor;</p>

<p>public class MyMonitorThread implements Runnable
{</p>

<pre><code>private ThreadPoolExecutor executor;

private int seconds;

private boolean run=true;

public MyMonitorThread(ThreadPoolExecutor executor, int delay)
{
    this.executor = executor;
    this.seconds=delay;
}

public void shutdown(){
    this.run=false;
}

@Override
public void run()
{
    while(run){
            System.out.println(
                String.format("[monitor] [%d/%d] Active: %d, Completed: %d, Task: %d, isShutdown: %s, isTerminated: %s",
                    this.executor.getPoolSize(),
                    this.executor.getCorePoolSize(),
                    this.executor.getActiveCount(),
                    this.executor.getCompletedTaskCount(),
                    this.executor.getTaskCount(),
                    this.executor.isShutdown(),
                    this.executor.isTerminated()));
            try {
                Thread.sleep(seconds*1000);
            } catch (InterruptedException e) {
                e.printStackTrace();
            }
    }

}
</code></pre>

<p>}</p>

<p>// WorkerPool.java
import java.util.concurrent.ArrayBlockingQueue;
import java.util.concurrent.Executors;
import java.util.concurrent.ThreadFactory;
import java.util.concurrent.ThreadPoolExecutor;
import java.util.concurrent.TimeUnit;</p>

<p>public class WorkerPool {</p>

<pre><code>public static void main(String args[]) throws InterruptedException{
    //RejectedExecutionHandler implementation
    RejectedExecutionHandlerImpl rejectionHandler = new RejectedExecutionHandlerImpl();
    //Get the ThreadFactory implementation to use
    ThreadFactory threadFactory = Executors.defaultThreadFactory();
    //creating the ThreadPoolExecutor
    ThreadPoolExecutor executorPool = new ThreadPoolExecutor(2, 4, 10, TimeUnit.SECONDS, new ArrayBlockingQueue&lt;Runnable&gt;(2), threadFactory, rejectionHandler);
    //start the monitoring thread
    MyMonitorThread monitor = new MyMonitorThread(executorPool, 3);
    Thread monitorThread = new Thread(monitor);
    monitorThread.start();
    //submit work to the thread pool
    for(int i=0; i&lt;10; i++){
        executorPool.execute(new WorkerThread("cmd"+i));
    }

    Thread.sleep(30000);
    //shut down the pool
    executorPool.shutdown();
    //shut down the monitor thread
    Thread.sleep(5000);
    monitor.shutdown();

}
</code></pre>

<p>}</p>

<p>Notice that while initializing the ThreadPoolExecutor, we are keeping initial pool size as 2, maximum pool size to 4 and work queue size as 2. So if there are 4 running tasks and more tasks are submitted, the work queue will hold only 2 of them and rest of them will be handled by RejectedExecutionHandlerImpl.</p>

<p>Notice the change in active, completed and total completed task count of the executor. We can invoke <code>shutdown()</code> method to finish execution of all the submitted tasks and terminate the thread pool.
```</p>

<h3 id="future">Java Callable Future</h3>


<p>In last few posts, we learned a lot about java threads but sometimes we wish that <strong>a thread could return some value that we can use</strong>. Java 5 introduced <code>java.util.concurrent.Callable</code> interface in concurrency package that is similar to Runnable interface but it can return any Object and able to throw Exception.</p>

<p>Callable interface use Generic to define the return type of Object. <code>Executors</code> class provide useful methods to execute <code>Callable</code> in a thread pool. Since callable tasks run in parallel, we have to wait for the returned Object. Callable tasks return <code>java.util.concurrent.Future</code> object. Using Future we can find out the status of the Callable task and get the returned Object. It provides <code>get()</code> method that can wait for the Callable to finish and then return the result.</p>

<p>Future provides <code>cancel()</code> method to cancel the associated <code>Callable</code> task. There is an overloaded version of <code>get()</code> method where we can specify the time to wait for the result, it’s useful to avoid current thread getting blocked for longer time. There are <code>isDone()</code> and <code>isCancelled()</code> methods to find out the current status of associated <code>Callable</code> task.</p>

<p>```java
import java.util.ArrayList;
import java.util.Date;
import java.util.List;
import java.util.concurrent.Callable;
import java.util.concurrent.ExecutionException;
import java.util.concurrent.ExecutorService;
import java.util.concurrent.Executors;
import java.util.concurrent.Future;</p>

<p>public class MyCallable implements Callable<String> {</p>

<pre><code>@Override
public String call() throws Exception {
    Thread.sleep(1000);
    //return the thread name executing this callable task
    return Thread.currentThread().getName();
}

public static void main(String args[]){
    //Get ExecutorService from Executors utility class, thread pool size is 10
    ExecutorService executor = Executors.newFixedThreadPool(10);
    //create a list to hold the Future object associated with Callable
    List&lt;Future&lt;String&gt;&gt; list = new ArrayList&lt;Future&lt;String&gt;&gt;();
    //Create MyCallable instance
    Callable&lt;String&gt; callable = new MyCallable();
    for(int i=0; i&lt; 100; i++){
        //submit Callable tasks to be executed by thread pool
        Future&lt;String&gt; future = executor.submit(callable);
        //add Future to the list, we can get return value using Future
        list.add(future);
    }
    for(Future&lt;String&gt; fut : list){
        try {
            //print the return value of Future, notice the output delay in console
            // because Future.get() waits for task to get completed
            System.out.println(new Date()+ "::"+fut.get());
        } catch (InterruptedException | ExecutionException e) {
            e.printStackTrace();
        }
    }
    //shut down the executor service now
    executor.shutdown();
}
</code></pre>

<p>}
```</p>

<h3 id="futuretask">Java FutureTask Example</h3>


<p><code>FutureTask</code> is base concrete implementation of <code>Future</code> interface and provides asynchronous processing. It contains the methods to start and cancel a task and also methods that can return the state of the <code>FutureTask</code> as whether it’s completed or cancelled. We need a callable object to create a future task and then we can use Java Thread Pool Executor to process these asynchronously.</p>

<p>```java
// MyCallable.java
import java.util.concurrent.Callable;</p>

<p>public class MyCallable implements Callable<String> {</p>

<pre><code>private long waitTime;

public MyCallable(int timeInMillis){
    this.waitTime=timeInMillis;
}
@Override
public String call() throws Exception {
    Thread.sleep(waitTime);
    //return the thread name executing this callable task
    return Thread.currentThread().getName();
}
</code></pre>

<p>}</p>

<p>// FutureTaskExample.java
import java.util.concurrent.ExecutionException;
import java.util.concurrent.ExecutorService;
import java.util.concurrent.Executors;
import java.util.concurrent.FutureTask;
import java.util.concurrent.TimeUnit;
import java.util.concurrent.TimeoutException;</p>

<p>public class FutureTaskExample {</p>

<pre><code>public static void main(String[] args) {
    MyCallable callable1 = new MyCallable(1000);
    MyCallable callable2 = new MyCallable(2000);

    FutureTask&lt;String&gt; futureTask1 = new FutureTask&lt;String&gt;(callable1);
    FutureTask&lt;String&gt; futureTask2 = new FutureTask&lt;String&gt;(callable2);

    ExecutorService executor = Executors.newFixedThreadPool(2);
    executor.execute(futureTask1);
    executor.execute(futureTask2);

    while (true) {
        try {
            if(futureTask1.isDone() &amp;&amp; futureTask2.isDone()){
                System.out.println("Done");
                //shut down executor service
                executor.shutdown();
                return;
            }

            if(!futureTask1.isDone()){
            //wait indefinitely for future task to complete
            System.out.println("FutureTask1 output="+futureTask1.get());
            }

            System.out.println("Waiting for FutureTask2 to complete");
            String s = futureTask2.get(200L, TimeUnit.MILLISECONDS);
            if(s !=null){
                System.out.println("FutureTask2 output="+s);
            }
        } catch (InterruptedException | ExecutionException e) {
            e.printStackTrace();
        }catch(TimeoutException e){
            //do nothing
        }
    }

}
</code></pre>

<p>}
```</p>

<p>When we run above program, you will notice that it doesn’t print anything for sometime because <code>get()</code> method of <code>FutureTask</code> waits for the task to get completed and then returns the output object. There is an overloaded method also to wait for only specified amount of time and we are using it for futureTask2. Also notice the use of <code>isDone()</code> method to make sure program gets terminated once all the tasks are executed.</p>

<p>Ref:</p>

<ul>
<li><a href="http://www.journaldev.com/1079/java-thread-tutorial">Java Thread and Multithreading Tutorial</a></li>
<li><a href="http://docs.oracle.com/javase/tutorial/essential/concurrency/">Concurrency</a></li>
</ul>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[A journey on the Android Main Thread]]></title>
    <link href="http://Solarex.github.io/blog/2014/10/13/android-main-thread/"/>
    <updated>2014-10-13T16:51:00+08:00</updated>
    <id>http://Solarex.github.io/blog/2014/10/13/android-main-thread</id>
    <content type="html"><![CDATA[<p>When facing bugs that were related to how we interact with the main thread, I decided to get a closer look at what the main thread really is.</p>

<p>```java
public class BigBang {
  public static void main(String&hellip; args) {</p>

<pre><code>// The Java universe starts here.
</code></pre>

<p>  }
}
```</p>

<p>All Java programs start with a call to a <code>public static void main()</code> method. This is true for Java Desktop programs, JEE servlet containers, and Android applications.</p>

<p>When the Android system boots, it starts a Linux process called <code>ZygoteInit</code>. This process is a Dalvik VM that loads the <a href="https://android.googlesource.com/platform/frameworks/base/+/refs/heads/master/preloaded-classes">most common classes</a> of the Android SDK on a thread, and then waits.</p>

<!-- more -->


<p>When starting a new Android application, the Android system forks the <code>ZygoteInit</code> process. The thread in the child fork stops waiting, and calls <code>ActivityThread.main()</code>.</p>

<h2>Loopers</h2>

<p>Before going any further, we need to look at the <code>Looper</code> class.</p>

<p>Using a looper is a good way to dedicate one thread to process messages serially.</p>

<p>Each looper has a queue of <code>Message</code> objects (a <code>MessageQueue</code>).</p>

<p>A looper has a <code>loop()</code> method that will process each message in the queue, and block when the queue is empty.</p>

<p>The <code>Looper.loop()</code> method code is similar to this:</p>

<p>```java
void loop() {
  while(true) {</p>

<pre><code>Message message = queue.next(); // blocks if empty.
dispatchMessage(message);
message.recycle();
</code></pre>

<p>  }
}
```</p>

<p>Each looper is associated with one thread. To create a new looper and associate it to the current thread, you must call <code>Looper.prepare()</code>. The loopers are stored in a static <code>ThreadLocal</code> in the <code>Looper</code> class. You can retrieve the <code>Looper</code> associated to the current thread by calling <code>Looper.myLooper()</code>.</p>

<p>The <code>HandlerThread</code> class does everything for you:</p>

<p><code>java
HandlerThread thread = new HandlerThread("SquareHandlerThread");
thread.start(); // starts the thread.
Looper looper = thread.getLooper();
</code></p>

<p>Its code is similar to this:</p>

<p>```java
class HandlerThread extends Thread {
  Looper looper;
  public void run() {</p>

<pre><code>Looper.prepare(); // Create a Looper and store it in a ThreadLocal.
looper = Looper.myLooper(); // Retrieve the looper instance from the ThreadLocal, for later use.
Looper.loop(); // Loop forever.
</code></pre>

<p>  }
}
```</p>

<h2>Handlers</h2>

<p>A handler is the natural companion to a looper.</p>

<p>A handler has two purposes:</p>

<ul>
<li>Send messages to a looper message queue from any thread.</li>
<li>Hndle messages dequeued by a looper on the thread associated to that looper.</li>
</ul>


<p>```java
// Each handler is associated to one looper.
Handler handler = new Handler(looper) {
  public void handleMessage(Message message) {</p>

<pre><code>// Handle the message on the thread associated to the given looper.
if (message.what == DO_SOMETHING) {
  // do something
}
</code></pre>

<p>  }
};</p>

<p>// Create a new message associated to that handler.
Message message = handler.obtainMessage(DO_SOMETHING);</p>

<p>// Add the message to the looper queue.
// Can be called from any thread.
handler.sendMessage(message);
```</p>

<p>You can associate multiple handlers to one looper. The looper delivers the message to <code>message.target</code>.</p>

<p>A popular and simpler way to use a handler is to post a <code>Runnable</code>:</p>

<p>```java
// Create a message containing a reference to the runnable and add it to the looper queue
handler.post(new Runnable() {
  public void run() {</p>

<pre><code>// Runs on the thread associated to the looper associated to that handler.
</code></pre>

<p>  }
});
```</p>

<p>A handler can also be created without providing any looper:</p>

<p><code>java
// DON'T DO THIS
Handler handler = new Handler();
</code></p>

<p>The handler no argument constructor calls <code>Looper.myLooper()</code> and retrieves the looper associated with the current thread. This may or may not be the thread you actually want the handler to be associated with.</p>

<p>Most of the time, you just want to create a handler to post on the main thread:</p>

<p><code>java
Handler handler = new Handler(Looper.getMainLooper());
</code></p>

<p>Back to PSVM
Let&rsquo;s look at <code>ActivityThread.main()</code> again. Here is what it is essentially doing:</p>

<p>```java
public class ActivityThread {
  public static void main(String&hellip; args) {</p>

<pre><code>Looper.prepare();

// You can now retrieve the main looper at any time by calling Looper.getMainLooper().
Looper.setMainLooper(Looper.myLooper());

// Post the first messages to the looper.
// { ... }

Looper.loop();
</code></pre>

<p>  }
}
```</p>

<p>Now you know why this thread is called the main thread :) .</p>

<p>Note: As you would expect, one of the first things that the main thread will do is create the <code>Application</code> and call <code>Application.onCreate()</code>.</p>

<h2>Activities love orientation changes</h2>

<p>Let&rsquo;s start with the activity lifecycle and the magic behind the handling of configuration changes.</p>

<h3>Why it matters</h3>

<p>This article was inspired by a real crash that occurred in Square Register.
A simplified version of the code is:</p>

<p>```java
public class MyActivity extends Activity {
  protected void onCreate(Bundle savedInstanceState) {</p>

<pre><code>super.onCreate(savedInstanceState);
Handler handler = new Handler(Looper.getMainLooper());
handler.post(new Runnable() {
  public void run() {
    doSomething();
  }
});
</code></pre>

<p>  }</p>

<p>  void doSomething() {</p>

<pre><code>// Uses the activity instance
</code></pre>

<p>  }
}
```</p>

<p>As we will see, <code>doSomething()</code> can be called after the activity <code>onDestroy()</code> method has been called due to a configuration change. At that point, you should not use the activity instance anymore.</p>

<h3>A refresher on orientation changes</h3>

<p>The device orientation can change at any time. We will simulate an orientation change while the activity is being created using <code>Activity#setRequestedOrientation(int)</code>.</p>

<p>Can you predict the log output when starting this activity in portrait?</p>

<p>```java
public class MyActivity extends Activity {
  protected void onCreate(Bundle savedInstanceState) {</p>

<pre><code>super.onCreate(savedInstanceState);
Log.d("Square", "onCreate()");
if (savedInstanceState == null) {
  Log.d("Square", "Requesting orientation change");
  setRequestedOrientation(ActivityInfo.SCREEN_ORIENTATION_LANDSCAPE);
}
</code></pre>

<p>  }</p>

<p>  protected void onResume() {</p>

<pre><code>super.onResume();
Log.d("Square", "onResume()");
</code></pre>

<p>  }</p>

<p>  protected void onPause() {</p>

<pre><code>super.onPause();
Log.d("Square", "onPause()");
</code></pre>

<p>  }</p>

<p>  protected void onDestroy() {</p>

<pre><code>super.onDestroy();
Log.d("Square", "onDestroy()");
</code></pre>

<p>  }
}
```</p>

<p>If you know the Android lifecycle, you probably predicted this:</p>

<p><code>java
onCreate()
Requesting orientation change
onResume()
onPause()
onDestroy()
onCreate()
onResume()
</code></p>

<p>The Android Lifecycle goes on normally, the activity is created, resumed, and then the orientation change is taken into account and the activity is paused, destroyed, and a new activity is created and resumed.</p>

<h3>Orientation changes and the main thread</h3>

<p>Here is an important detail to remember: an orientation change leads to recreating the activity via a simple post of a message to the main thread looper queue.</p>

<p>Let&rsquo;s look at that by writing a spy that will read the content of the looper queue via reflection:</p>

<p>```java
public class MainLooperSpy {
  private final Field messagesField;
  private final Field nextField;
  private final MessageQueue mainMessageQueue;</p>

<p>  public MainLooperSpy() {</p>

<pre><code>try {
  Field queueField = Looper.class.getDeclaredField("mQueue");
  queueField.setAccessible(true);
  messagesField = MessageQueue.class.getDeclaredField("mMessages");
  messagesField.setAccessible(true);
  nextField = Message.class.getDeclaredField("next");
  nextField.setAccessible(true);
  Looper mainLooper = Looper.getMainLooper();
  mainMessageQueue = (MessageQueue) queueField.get(mainLooper);
} catch (Exception e) {
  throw new RuntimeException(e);
}
</code></pre>

<p>  }</p>

<p>  public void dumpQueue() {</p>

<pre><code>try {
  Message nextMessage = (Message) messagesField.get(mainMessageQueue);
  Log.d("MainLooperSpy", "Begin dumping queue");
  dumpMessages(nextMessage);
  Log.d("MainLooperSpy", "End dumping queue");
} catch (IllegalAccessException e) {
  throw new RuntimeException(e);
}
</code></pre>

<p>  }</p>

<p>  public void dumpMessages(Message message) throws IllegalAccessException {</p>

<pre><code>if (message != null) {
  Log.d("MainLooperSpy", message.toString());
  Message next = (Message) nextField.get(message);
  dumpMessages(next);
}
</code></pre>

<p>  }
}
```</p>

<p>As you can see, the message queue is merely a linked list where each message has a reference to the next message.</p>

<p>We log the content of the queue right after the orientation change:</p>

<p>```java
public class MyActivity extends Activity {
  private final MainLooperSpy mainLooperSpy = new MainLooperSpy();</p>

<p>  protected void onCreate(Bundle savedInstanceState) {</p>

<pre><code>super.onCreate(savedInstanceState);
Log.d("Square", "onCreate()");
if (savedInstanceState == null) {
  Log.d("Square", "Requesting orientation change");
  setRequestedOrientation(ActivityInfo.SCREEN_ORIENTATION_LANDSCAPE);
  mainLooperSpy.dumpQueue();
}
</code></pre>

<p>  }
}
```</p>

<p>Here is the output:</p>

<p><code>java
onCreate()
Requesting orientation change
Begin dumping queue
{ what=118 when=-94ms obj={1.0 208mcc15mnc en_US ldltr sw360dp w598dp h335dp 320dpi nrml land finger -keyb/v/h -nav/h s.44?spn} }
{ what=126 when=-32ms obj=ActivityRecord{41fd2b48 token=android.os.BinderProxy@41fcce50 no component name} }
End dumping queue
</code></p>

<p>A quick look at the <code>ActivityThread</code> class tells us what those 118 and 126 messages are:</p>

<p>```java
public final class ActivityThread {
  private class H extends Handler {</p>

<pre><code>public static final int CONFIGURATION_CHANGED   = 118;
public static final int RELAUNCH_ACTIVITY       = 126;
</code></pre>

<p>  }
}
```</p>

<p>Requesting an orientation change added <code>CONFIGURATION_CHANGED</code> and a <code>RELAUNCH_ACTIVITY</code> message to the main thread looper queue.</p>

<p>Let&rsquo;s take a step back and think about what&rsquo;s going on:</p>

<p>When the activity starts for the first time, the queue is empty. The message currently being executed is <code>LAUNCH_ACTIVITY</code>, which creates the activity instance, calls <code>onCreate()</code> and then <code>onResume()</code> in a row. Then only the main looper processes the next message in the queue.</p>

<p>When a device orientation change is detected, a <code>RELAUNCH_ACTIVITY</code> is posted to the queue.</p>

<p>When that message is processed, it:</p>

<ul>
<li>calls <code>onSaveInstanceState()</code>, <code>onPause()</code>, <code>onDestroy()</code> on the old activity instance,</li>
<li>creates a new activity instance,</li>
<li>calls <code>onCreate()</code> and <code>onResume()</code> on that new activity instance.</li>
</ul>


<p>All that in one message handling. Any message you post in the meantime will be handled after <code>onResume()</code> has been called.</p>

<h3>Tying it all together</h3>

<p>What could happen if you post to a handler in <code>onCreate()</code> during an orientation change? Let&rsquo;s look at the two cases, right before and right after the orientation change:</p>

<p>```java
public class MyActivity extends Activity {
  private final MainLooperSpy mainLooperSpy = new MainLooperSpy();</p>

<p>  protected void onCreate(Bundle savedInstanceState) {</p>

<pre><code>super.onCreate(savedInstanceState);
Log.d("Square", "onCreate()");
if (savedInstanceState == null) {
  Handler handler = new Handler(Looper.getMainLooper());
  handler.post(new Runnable() {
    public void run() {
      Log.d("Square", "Posted before requesting orientation change");
    }
  });
  Log.d("Square", "Requesting orientation change");
  setRequestedOrientation(ActivityInfo.SCREEN_ORIENTATION_LANDSCAPE);
  handler.post(new Runnable() {
    public void run() {
      Log.d("Square", "Posted after requesting orientation change");
    }
  });
  mainLooperSpy.dumpQueue();
}
</code></pre>

<p>  }</p>

<p>  protected void onResume() {</p>

<pre><code>super.onResume();
Log.d("Square", "onResume()");
</code></pre>

<p>  }</p>

<p>  protected void onPause() {</p>

<pre><code>super.onPause();
Log.d("Square", "onPause()");
</code></pre>

<p>  }</p>

<p>  protected void onDestroy() {</p>

<pre><code>super.onDestroy();
Log.d("Square", "onDestroy()");
</code></pre>

<p>  }
}
```</p>

<p>Here is the output:</p>

<p><code>java
onCreate()
Requesting orientation change
Begin dumping queue
{ what=0 when=-129ms }
{ what=118 when=-96ms obj={1.0 208mcc15mnc en_US ldltr sw360dp w598dp h335dp 320dpi nrml land finger -keyb/v/h -nav/h s.46?spn} }
{ what=126 when=-69ms obj=ActivityRecord{41fd6b68 token=android.os.BinderProxy@41fd0ae0 no component name} }
{ what=0 when=-6ms }
End dumping queue
onResume()
Posted before requesting orientation change
onPause()
onDestroy()
onCreate()
onResume()
Posted after requesting orientation change
</code></p>

<p>To sum things up: at the end on <code>onCreate()</code>, the queue contained four messages. The first was the post before the orientation change, then the two messages related to the orientation change, and then only the post after the orientation change. The logs show that these were executed in order.</p>

<p>Therefore, any message posted before the orientation change will be handled before <code>onPause()</code> of the leaving activity, and any message posted after the orientation change will be handled after <code>onResume()</code> of the incoming activity.</p>

<p>The practical implication is that when you post a message, you have no guarantee that the activity instance that existed at the time it was sent will still be running when the message is handled (even if you post from <code>onCreate()</code> or <code>onResume()</code>). If your message holds a reference to a view or an activity, the activity won&rsquo;t be garbage collected until the message is handled.</p>

<h3>What could you do?</h3>

<h4>The real fix</h4>

<p>Stop calling <code>handler.post()</code> when you are already on the main thread. In most cases, <code>handler.post()</code> is used as a quick fix to ordering problems. Fix your architecture instead of messing it up with random <code>handler.post()</code> calls.</p>

<h4>If you have a good reason to post</h4>

<p>Make sure your message does not hold a reference to an activity, as you would do for a background operation.</p>

<h4>If you really need that activity reference</h4>

<p>Remove the message from the queue with <code>handler.removeCallbacks()</code> in the activity <code>onPause()</code>.</p>

<h4>If you want to get fired</h4>

<p>Use <code>handler.postAtFrontOfQueue()</code> to make sure a message posted before <code>onPause()</code> is always handled before <code>onPause()</code>. Your code will become really hard to read and understand. Seriously, don&rsquo;t.</p>

<h4>A word on <code>runOnUiThread()</code></h4>

<p>Did you notice that we created a handler and used <code>handler.post()</code> instead of directly calling <code>Activity.runOnUiThread()</code>?</p>

<p>Here is why:</p>

<p>```java
public class Activity {
  public final void runOnUiThread(Runnable action) {</p>

<pre><code>if (Thread.currentThread() != mUiThread) {
  mHandler.post(action);
} else {
  action.run();
}
</code></pre>

<p>  }
}
```</p>

<p>Unlike <code>handler.post()</code>, <code>runOnUiThread()</code> does not post the runnable if the current thread is already the main thread. Instead, it calls <code>run()</code> synchronously.</p>

<h2>Services</h2>

<p>There is a common misconception that needs to die: a service does not run on a background thread.</p>

<p>All service lifecycle methods (<code>onCreate()</code>, <code>onStartCommand()</code>, etc) run on the main thread (the very same thread that&rsquo;s used to play funky animations in your activities).</p>

<p>Whether you are in a service or an activity, long tasks must be executed in a dedicated background thread. This background thread can live as long as the process of your app lives, even when your activities are long gone.</p>

<p>However, at any time the Android system can decide to kill the app process. A service is a way to ask the system to let us live if possible and be polite by letting the service know before killing the process.</p>

<p>Side note: When an <code>IBinder</code> returned from <code>onBind()</code> receives a call from another process, the method will be executed in a background thread.</p>

<p>Take the time to read the Service documentation &mdash; it&rsquo;s pretty good.</p>

<h2>IntentService</h2>

<p>IntentService provides a simple way to serially process a queue of intents on a background thread.</p>

<p>```java
public class MyService extends IntentService {
  public MyService() {</p>

<pre><code>super("MyService");
</code></pre>

<p>  }</p>

<p>  protected void onHandleIntent(Intent intent) {</p>

<pre><code>// This is called on a background thread.
</code></pre>

<p>  }
}
```</p>

<p>Internally, it uses a <code>Looper</code> to handle the intents on a dedicated <code>HandlerThread</code>. When the service is destroyed, the looper lets you finish handling the current intent, and then the background thread terminates.</p>

<h2>Conclusion</h2>

<p>Most Android lifecycle methods are called on the main thread. Think of these callbacks as simple messages sent to a looper queue.</p>

<p>This article wouldn&rsquo;t be complete without the reminder that goes into almost every Android dev article: Do not block the main thread.</p>

<p>REF:<a href="http://corner.squareup.com/2013/10/android-main-thread-1.html">A journey on the Android Main Thread</a>,<a href="http://corner.squareup.com/2013/12/android-main-thread-2.html">A journey on the Android Main Thread &ndash; Lifecycle bits</a></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Intro to Android Loopers and Handlers]]></title>
    <link href="http://Solarex.github.io/blog/2014/10/13/android-looper-handler/"/>
    <updated>2014-10-13T11:24:00+08:00</updated>
    <id>http://Solarex.github.io/blog/2014/10/13/android-looper-handler</id>
    <content type="html"><![CDATA[<p>What can you do with <code>Loopers</code> and <code>Handlers</code>? Basically, they implement a common concurrency pattern that I call the <code>Pipeline Thread</code>. Here’s how it works:</p>

<ul>
<li>The Pipeline Thread holds a queue of tasks which are just some units of work that can be executed or processed.</li>
<li>Other threads can safely push new tasks into the Pipeline Thread’s queue at any time.</li>
<li>The Pipeline Thread processes the queued tasks one after another. If there are no tasks queued, it blocks until a task appears in the queue.</li>
<li>Sometimes tasks can called messages and other names.</li>
</ul>


<!-- more -->


<p>我们能用<code>Loopers</code>和<code>Handlers</code>来干什么？这两个类实现了一种通用的并发模型，我把它叫做：Pipeline 线程。它是这样工作的：
+ Pipeline 线程持有一个任务队列，这些任务就是一些可以执行的工作单元
+ 其他线程可以自由的将任务加到Pipeline线程的任务队列中去
+ Pipeline线程就按次序一个一个执行任务，如果任务队列中没有任务了，它就会自动阻塞直到有任务到来
+ 有些时候，任务可以叫做消息（messages）或者其他名字</p>

<p><code>Looper</code> is a class that turns a thread into a <code>Pipeline Thread</code> and <code>Handler</code> gives you a mechanism to push tasks into it from any other threads.The <code>Looper</code> is named so because it implements the loop – takes the next task, executes it, then takes the next one and so on. The <code>Handler</code> is called a handler because someone could not invent a better name.</p>

<p>Looper类可以将一个线程转换成Pipeline线程，而Handler提供了一种机制，你可以通过它将任务添加到Pipeline线程中。Looper之所以这么命名是因为它实现了循环——取一个task执行，然后再取下一个task执行，如此循环；Handler如此命名是因为他们无法想出一个更好的名字了~</p>

<p>Here’s what you should put into a Thread&rsquo;s <code>run()</code> method to turn it into a Pipeline Thread and to create a <code>Handler</code> so that other threads can assign tasks to it:</p>

<p>下面就是你需要添加到Thread类的run方法中的代码来创建一个你自己的Pipeline线程，并创建一个<code>Handler</code>以便其他线程可以将任务分发到此Pipeline线程中。</p>

<p>```java
@Override
public void run() {
  try {</p>

<pre><code>// preparing a looper on current thread
// the current thread is being detected implicitly
Looper.prepare();

// now, the handler will automatically bind to the
// Looper that is attached to the current thread
// You don't need to specify the Looper explicitly
handler = new Handler();

// After the following line the thread will start
// running the message loop and will not normally
// exit the loop unless a problem happens or you
// quit() the looper (see below)
Looper.loop();
</code></pre>

<p>  } catch (Throwable t) {</p>

<pre><code>Log.e(TAG, "halted due to an error", t);
</code></pre>

<p>  }
}
```</p>

<p>After that, you can just pass the handler to any other thread. It has a thread-safe interface that includes many operations, but the most straightforward ones are <code>postMessage()</code> and its relatives.</p>

<p>然后，你只要将这个handler对象传到其他任何线程中去，它有一个线程安全的接口，包括了很多操作，但是最主要的操作就是postMessage()以及相关的方法了。</p>

<p>For example, imagine another thread has a reference to the handler that was created in our Pipeline Thread. Here’s how that other thread can schedule an operation to be executed in the Pipeline Thread:</p>

<p>想象一下，一个线程A持有了handler对象的引用，此handler是在Pipeline线程中创建的，下面代码就可以让这个线程A在Pipeline线程中执行操作了：</p>

<p>```java
handler.post(new Runnable() {
  @Override
  public void run() {</p>

<pre><code>// this will be done in the Pipeline Thread
</code></pre>

<p>  }
});
```</p>

<p>By the way, the UI thread has a <code>Looper</code> created for it implicitly, so you can just create a <code>Handler</code> in activity&rsquo;s <code>onCreate()</code> and it will work fine:</p>

<p>UI线程拥有一个Looper（可以通过<code>Looper.getMainLooper()</code>方法获取，判断一个线程是否为主线程可以使用<code>Looper.getLooper() == Looper.getMainLooper()</code>来判断）。所以，你可以在<code>Activity</code>的<code>onCreate()</code>方法中直接新建一个handler对象：</p>

<p>```java
@Override
public void onCreate(Bundle savedInstanceState) {</p>

<pre><code>super.onCreate(savedInstanceState);
setContentView(R.layout.main);

// Create the Handler. It will implicitly bind to the Looper
// that is internally created for this thread (since it is the UI thread)
handler = new Handler();
</code></pre>

<p>}
```</p>

<p>什么时候使用多线程:
1. 耗时操作使用多线程, 耗时操作放在UI线程中会导致用户的操作无法得到响应.
2. 阻塞操作使用多线程, 理由同上.
3. 多核CPU的设备使用多线程, 可以有效提高CPU的利用率.
4. 并行操作使用多线程.</p>

<p>android中的多线程模型主要涉及的类有:Looper, Handler, MessageQueue, Message等.</p>

<p>Looper类用来创建消息队列. 每个线程最多只能有一个消息队列, android中UI线程默认具有消息队列, 但非UI线程在默认情况下是不具备消息队列的. 如果需要在非UI线程中开启消息队列, 需要调用<code>Looper.prepare()</code>方法, 在该方法的执行过程中会创建一个<code>Looper</code>对象, 而<code>Looper</code>的构造函数中会创建一个<code>MessageQueue</code> instance(Looper的构造函数是私有的, 在Looper类之外无法创建其对象).  此后再为该线程绑定一个Handler instance, 然后调用Looper.loop()方法, 就可以不断的从消息队列中取出消息和处理消息了. <code>Looper.myLooper()</code>方法可以得到线程的Looper对象, 如果为null, 说明此时该线程尚未开启消息队列.</p>

<p>Handler类用于处理消息. 该类具有四个构造函数:
1. <code>public Handler()</code>. 创建好的<code>Handler</code> instance将绑定在代码所在的线程的消息队列上, 因此一定要确定该线程开启了消息队列, 否则程序将发生错误. 使用这个构造函数创建<code>Handler</code> instance, 一般来说, 我们需要重写<code>Hanler</code>类的<code>handleMessage()</code>方法, 以便在之后的消息处理时调用.
2. <code>public Handler(Callback callback)</code>. <code>Callback</code>是<code>Handler</code>内部定义的一个接口, 因此想要使用这个构造函数创建<code>Handler</code>对象, 需要自定义一个类实现<code>Callback</code>接口, 并重写接口中定义的<code>handleMessage()</code>方法. 这个构造函数其实与无参的构造函数类似, 也要确保代码所在的线程开启了消息队列. 不同的是在之后处理消息时, 将调用<code>callback</code>的<code>handleMessage()</code>方法, 而不是<code>Handler</code>对象的<code>handleMssage()</code>方法.
3. <code>public Handler(Looper looper)</code>. 这个构造函数表示创建一个<code>Handler</code> instance, 并将其绑定在looper所在的线程上. 此时looper不能为null. 此时一般也需要重写<code>Hanler</code>类的<code>handleMessage()</code>方法
4. <code>public Handler(Looper looper, Callback callback)</code>. 可以结合2和3理解.</p>

<p><code>MessageQueue</code>类用于表示消息队列. 队列中的每一个Message都有一个when字段, 这个字段用来决定Message应该何时出对处理. 消息队列中的每一个Message根据when字段的大小由小到大排列, 排在最前面的消息会首先得到处理, 因此可以说消息队列并不是一个严格的先进先出的队列.</p>

<p><code>Message</code>类用于表示消息. <code>Message</code>对象可以通过arg1, arg2, obj字段和<code>setData()</code>携带数据, 此外还具有很多字段. when字段决定Message应该何时处理, target字段用来表示将由哪个Handler对象处理这个消息, next字段表示在消息队列中排在这个Message之后的下一个Message, callback字段如果不为null表示这个Message包装了一个runnable对象, what字段表示code, 即这个消息具体是什么类型的消息. 每个what都在其handler的namespace中, 我们只需要确保将由同一个handler处理的消息的what属性不重复就可以.</p>

<p>将消息压入消息队列: <code>Message</code>对象的<code>target</code>字段关联了哪个线程的消息队列, 这个消息就会被压入哪个线程的消息队列中.
1. 调用<code>Handler</code>类中以<code>send</code>开头的方法可以将<code>Message</code>对象压入消息队列中, 调用Handler类中以post开头的方法可以将一个runnable对象包装在一个Message对象中, 然后再压入消息队列, 此时入队的Message其callback字段不为null, 值就是这个runnable对象. 调用<code>Handler</code>对象的这些方法入队的<code>Message</code>, 其target属性会被赋值为这个handler对象.
2. 调用<code>Message</code>对象的<code>sendToTarget()</code>方法可以将其本身压入与其target字段(即handler对象)所关联的消息队列中.</p>

<p>将未来得及处理的消息从消息队列中删除:调用Handler对象中以remove开头的方法就可以.</p>

<p>从消息队列中取出消息并处理消息: 所有在消息队列中的消息, 都具有target字段. 消息是在target所关联的线程上被取出和处理的.
1. 如果取出的<code>Message</code>对象的callback字段不为null, 那么就调用<code>callback</code>字段的<code>run()</code>方法(callback字段的类型是runnable). 注意此时并不开启一个新的线程运行run()方法, 而是直接在handler对象(即<code>Message</code>的target字段)所关联的线程上运行.
2. 如果取出的Message对象的callback字段为null, 且<code>Handler</code>对象中的callback字段也为null, 那么这个消息将由<code>Handler</code>对象的<code>handleMessage(msg)</code>方法处理. 注意Message对象的callback字段是Runnable类型的而Handler对象的callback字段是Callback类型的, Handler对象的callback字段是在创建Handler instance的时候指定的, 如果没有指定则这个字段为null, 详见Handler类的四个构造方法.
3. 如果取出的<code>Message</code>对象的callback字段为null, 且Handler对象中的callback字段不为null, 那么这个消息将由<code>Handler</code>对象中的callback字段的handleMessage方法处理.</p>

<p>线程间通信: 有了以上的叙述, 线程间的通信也就好理解了. 假如一个handler关联了A线程上的消息队列, 那么我们可以在B线程上调用handler的相关方法向A线程上的消息队列压入一个Message, 这个Message将在A线程上得到处理.</p>

<p>REF:<a href="http://mindtherobot.com/blog/159/android-guts-intro-to-loopers-and-handlers/">Android Guts: Intro to Loopers and Handlers</a></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Android反编译]]></title>
    <link href="http://Solarex.github.io/blog/2014/10/12/android-decompile/"/>
    <updated>2014-10-12T09:21:00+08:00</updated>
    <id>http://Solarex.github.io/blog/2014/10/12/android-decompile</id>
    <content type="html"><![CDATA[<p>有时候在Google Play Store看到一些有趣的应用，或者对有些应用的资源图片之类的很感兴趣，这时候就需要用到Android反编译APK的一些工具了。</p>

<!-- more -->


<p>在Google Play上安装应用默认安装完成后是不保留应用apk文件的，要下载apk文件，可以从<a href="http://apkleecher.com/">Online APK Downloader</a>或<a href="http://apps.evozi.com/apk-downloader/">Apk Downloader</a>下载。</p>

<p>其实反编译APK主要用到3个工具，<a href="https://code.google.com/p/android-apktool/">apktool</a>用来获取资源文件，<a href="https://code.google.com/p/dex2jar/">dex2jar</a>用来将dex文件转换为jar文件格式，<a href="http://jd.benow.ca/">jd-gui</a>用来查看jar文件中源码。</p>

<ul>
<li>获取资源文件<code>java -jar apktool.jar d example.apk</code></li>
<li>获取jar文件</li>
</ul>


<p><code>bash
mv example.apk example.zip
unzip example.zip
dex2jar.sh classes.dex
</code></p>

<ul>
<li>使用jd-dui查看jar文件<code>jd-gui classes.jar</code></li>
</ul>


<p>上述工具在linux平台下的我已经打包了，可以在<a href="http://Solarex.github.io/downloads/files/decompile.tgz">这里</a>下载。</p>
]]></content>
  </entry>
  
</feed>
