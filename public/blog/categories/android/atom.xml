<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: android | Solarex's Blog]]></title>
  <link href="http://Solarex.github.io/blog/categories/android/atom.xml" rel="self"/>
  <link href="http://Solarex.github.io/"/>
  <updated>2014-10-19T19:22:22+08:00</updated>
  <id>http://Solarex.github.io/</id>
  <author>
    <name><![CDATA[Solarex]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[The Hidden Pitfalls of AsyncTask]]></title>
    <link href="http://Solarex.github.io/blog/2014/10/19/android-asynctask-pitfalls/"/>
    <updated>2014-10-19T15:56:00+08:00</updated>
    <id>http://Solarex.github.io/blog/2014/10/19/android-asynctask-pitfalls</id>
    <content type="html"><![CDATA[<p><center><img src="http://Solarex.github.io/images/android_logo.jpg"/></center></p>


<p>I originally wrote this article when I was (foolishly) still using AsyncTasks. Nowadays I simply consider it a mistake in all cases. As you&rsquo;ll see from the original article, there are a lot of problems with it &ndash; and there are much better solutions.</p>

<p>My preferred alternative these days are combining <a href="https://github.com/Netflix/RxJava">RxJava</a> with schedulers. You get the same effect as an <code>AsyncTask</code> with none of the problems, plus you get an awesome framework in addition. I know, recommending a library to solve a problem is irritating, but RxJava is worth looking at for many reasons.</p>

<p>When <code>AsyncTask</code> was introduced to Android, it was labeled as “<a href="http://android-developers.blogspot.com/2009/05/painless-threading.html">Painless Threading</a>.” Its goal was to make background Threads which could interact with the UI thread easier. It was successful on that count, but it’s not exactly painless – there are a number of cases where <code>AsyncTask</code> is not a silver bullet. It is easy to blindly use <code>AsyncTask</code> without realizing what can go wrong if not handled with care. Below are some of the problems that can arise when using <code>AsyncTask</code> without fully understanding it.</p>

<!-- more -->


<h2>AsyncTask and Rotation</h2>

<p>AsyncTask’s primary goal is to make it easy to run a Thread in the background that can later interact with the UI thread. Therefore the most common use case is to have an <code>AsyncTask</code> run a time-consuming operation that updates a portion of the UI when it’s completed (in <code>AsyncTask.onPostExecute()</code>).</p>

<p>This works great… until you rotate the screen. <strong>When an app is rotated, the entire <code>Activity</code> is destroyed and recreated. When the Activity is restarted, your AsyncTask’s reference to the <code>Activity</code> is invalid, so <code>onPostExecute()</code> will have no effect on the new Activity.</strong> This can be confusing if you are implicitly referencing the current Activity by having AsyncTask as an inner class of the Activity.</p>

<p>The usual solution to this problem is to hold onto a reference to AsyncTask that lasts between configuration changes, which updates the target Activity as it restarts. There are a variety of ways to do this, though they either boil down to using a global holder (such as in the <code>Application</code> object) or passing it through <code>Activity.onRetainNonConfigurationInstance()</code>. For a Fragment-based system, you could use a retained Fragment (via <code>Fragment.setRetainedInstance(true)</code>) to store running AsyncTasks.</p>

<h2>AsyncTasks and the Lifecycle</h2>

<p>Along the same lines as above, it is a misconception to think that just because the Activity that originally spawned the <code>AsyncTask</code> is dead, the <code>AsyncTask</code> is as well. It will continue running on its merry way even if you exit the entire application. <strong>The only way that an <code>AsyncTask</code> finishes early is if it is canceled via <code>AsyncTask.cancel()</code>.</strong></p>

<p>This means that you have to manage the cancellation of AsyncTasks yourself; otherwise you run the risk of bogging down your app with unnecessary background tasks, or of leaking memory. When you know you will no longer need an <code>AsyncTask</code>, be sure to cancel it so that it doesn’t cause any headaches later in the execution of your app.</p>

<h2>Cancelling AsyncTasks</h2>

<p>Suppose you’ve got a search query that runs in an <code>AsyncTask</code>. The user may be able to change the search parameters while the <code>AsyncTask</code> is running, so you call <code>AsyncTask.cancel()</code> and then fire up a new <code>AsyncTask</code> for the next query. <strong>This seems to work… until you check the logs and realize that your <code>AsyncTask</code>s all ran till completion, regardless of whether you called <code>cancel()</code> or not!</strong> This even happens if you pass mayInterruptIfRunning as true – what’s going on?</p>

<p>The problem is that there’s a misconception about what <code>AsyncTask.cancel()</code> actually does. It does not kill the Thread with no regard for the consequences! All it does is set the <code>AsyncTask</code> to a “cancelled” state. <strong>It’s up to you to check whether the AsyncTask has been canceled so that you can halt your operation</strong>. As for mayInterruptIfRunning – all it does is send an <code>interrupt()</code> to the running Thread. In the case that your Thread is uninterruptible, then it won’t stop the Thread at all.There are two simple solutions that cover most situations: Either check <code>AsyncTask.isCancelled()</code> on a regular basis during your long-running operation, or keep your Thread interruptible. Either way, when you call <code>AsyncTask.cancel()</code> these methods should prevent your operation from running longer than necessary.</p>

<p>This advice doesn’t always work, though – what if you’re calling a long-running method that is uninterruptible (such as <code>BitmapFactory.decodeStream()</code>)? The only success I’ve had in this situation is to create a situation which causes an Exception to be thrown (in this case, prematurely closing the stream that BitmapFactory was using). This meant that <code>cancel()</code> alone wouldn’t solve the problem – outside intervention was required.</p>

<h2>Limitations on Concurrent AsyncTasks</h2>

<p>I’m not encouraging people to start hundreds of threads in the background; however, it is worth noting that there are some limitations on the number of <code>AsyncTask</code>s that you can start. The modern <code>AsyncTask</code> is limited to 128 concurrent tasks, with an additional queue of 10 tasks (if supporting Android 1.5, it’s a limit of ten tasks at a time, with a maximum queue of 10 tasks). That means that if you queue up more than 138 tasks before they can complete, your app will crash. Most often I see this problem when people use <code>AsyncTask</code>s to load Bitmaps from the net.</p>

<p>If you are finding yourself running up against these limits, you should start by rethinking your design that calls for so many background threads. Alternatively, you could setup a more intelligent queue for your tasks so that you’re not starting them all at once. If you’re desperate, you can grab a copy of <code>AsyncTask</code> and adjust the pool sizes in the code itself.</p>

<ul>
<li><a href="http://blog.danlew.net/2014/06/21/the-hidden-pitfalls-of-asynctask/">The Hidden Pitfalls of AsyncTask</a></li>
</ul>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Android Tips]]></title>
    <link href="http://Solarex.github.io/blog/2014/10/19/android-tips/"/>
    <updated>2014-10-19T13:00:00+08:00</updated>
    <id>http://Solarex.github.io/blog/2014/10/19/android-tips</id>
    <content type="html"><![CDATA[<p><center><img src="http://Solarex.github.io/images/android_training.jpg"/></center></p>


<ul>
<li><a href="#overview">Android Tips and Tricks</a>

<ul>
<li><a href="#part1">Part I</a></li>
<li><a href="#part2">Part II</a></li>
<li><a href="#part3">Part III</a></li>
<li><a href="#part4">Part IV</a></li>
<li><a href="#part5">Part V</a></li>
</ul>
</li>
</ul>


<h2 id="overview">Android Tips and Tricks</h2>




<h3 id="part1">Part I</h3>


<ul>
<li><p><code>Activity.startActivities()</code> &ndash; Nice for launching to the middle of an app flow.</p></li>
<li><p><code>TextUtils.isEmpty()</code> &ndash; Simple utility I use everywhere.</p></li>
<li><p><code>Html.fromHtml()</code> &ndash; Quick method for formatting Html. It&rsquo;s not particularly fast so I wouldn&rsquo;t use it constantly (e.g., don&rsquo;t use it just to bold part of a string &ndash; construct the Spannable manually instead), but it&rsquo;s fine for rendering text obtained from the web.</p></li>
<li><p><code>TextView.setError()</code> &ndash; Nice UI when validating user input.</p></li>
<li><p><code>Build.VERSION_CODES</code> &ndash; Not only is it handy for routing code, it&rsquo;s also summarizes behavioral differences between each version of Android.</p></li>
</ul>


<!-- more -->


<ul>
<li><p><code>Log.getStackTraceString()</code> &ndash; Convenience utility for logging.</p></li>
<li><p><code>LayoutInflater.from()</code> &ndash; Wraps the long-winded getSystemService() call in a simple utility.</p></li>
<li><p><code>ViewConfiguration.getScaledTouchSlop()</code> &ndash; Using the values provided in ViewConfiguration ensures all touch interaction feels consistent across the OS.</p></li>
<li><p><code>PhoneNumberUtils.convertKeypadLettersToDigits</code> &ndash; Makes handling phone number data a snap, as some companies provide them as letters.</p></li>
<li><p><code>Context.getCacheDir()</code> &ndash; Use the cache dir for caching data. Simple enough but some don&rsquo;t know it exists.</p></li>
<li><p><code>ArgbEvaluator</code> &ndash; Transition from one color to another. As was pointed out by Chris Banes, this class creates a lot of autoboxing churn so it&rsquo;d be better to just rip out the logic and run it yourself.</p></li>
<li><p><code>ContextThemeWrapper</code> &ndash; Nice class for changing the theme of a Context on the fly.</p></li>
<li><p><code>Space</code> &ndash; Lightweight View which skips drawing. Great for any situation that might require a placeholder.</p></li>
<li><p><code>ValueAnimator.reverse()</code> &ndash; I love this for canceling animations smoothly.</p></li>
</ul>


<h3 id="part2">Part II</h3>


<ul>
<li><p><code>DateUtils.formatDateTime()</code> &ndash; One-stop shop for localized date/time strings.</p></li>
<li><p><code>AlarmManager.setInexactRepeating</code> &ndash; Saves on battery life by grouping multiple alarms together. Even if you&rsquo;re only calling a single alarm this is better (just make sure to call AlarmManager.cancel() when done).</p></li>
<li><p><code>Formatter.formatFileSize()</code> &ndash; A localized file size formatter.</p></li>
<li><p><code>ActionBar.hide()/.show()</code> &ndash; Animates the action bar hiding/showing. Lets you switch to full-screen gracefully.</p></li>
<li><p><code>Linkify.addLinks()</code> &ndash; If you need to control how links are added to text.</p></li>
<li><p><code>StaticLayout</code> &ndash; Useful for measuring text that you&rsquo;re about to render into a custom View.</p></li>
<li><p><code>Activity.onBackPressed()</code> &ndash; Easy way to manage the back button. While I wouldn&rsquo;t normally hijack back, sometimes it&rsquo;s necessary to make a flow work.</p></li>
<li><p><code>GestureDetector</code> &ndash; Listens to motion events and fires listener events for common actions (like clicks, scrolls and flings). So much easier than implementing your own motion event system.</p></li>
<li><p><code>DrawFilter</code> &ndash; Lets you manipulate a Canvas even if you&rsquo;re not calling the draw commands. For example, you could create a custom View which sets a DrawFilter which anti-aliases the draws of the parent View.</p></li>
<li><p><code>ActivityManager.getMemoryClass()</code> &ndash; Gives you an idea of how much memory the device has. Great for figuring out how large to make your caches.</p></li>
<li><p><code>SystemClock.sleep()</code> &ndash; Convenience method which guarantees sleeping the amount of time entered. I use it for debugging and simulating network delays.</p></li>
<li><p><code>ViewStub</code> &ndash; A View that initially does nothing, but can later inflate a layout. This is a great placeholder for lazy-loading Views. Its only drawback is that it doesn&rsquo;t support <merge> tags, so it can create unnecessary nesting in the hierarchy if you&rsquo;re not careful.</p></li>
<li><p><code>DisplayMetrics.density</code> &ndash; You can get the density of the screen this way. Most of the time you&rsquo;ll be better off letting the system scale dimensions automatically, but occasionally it&rsquo;s useful to have more control (especially with custom Views).</p></li>
<li><p><code>Pair.create()</code> &ndash; Handy class, handy creator method.</p></li>
</ul>


<h3 id="part3">Part III</h3>


<ul>
<li><p><code>UrlQuerySanitizer</code> &ndash; Sanitize URLs with this handy utility.</p></li>
<li><p><code>Fragment.setArguments</code> &ndash; Since you can&rsquo;t use a Fragment constructor w/ parameters this is the second best thing. Arguments set before creation last throughout the entire Fragment&rsquo;s lifecycle (even if it&rsquo;s destroyed/recreated due to a configuration change).</p></li>
<li><p><code>DialogFragment.setShowsDialog()</code> &ndash; Neat trick &ndash; DialogFragments can act like normal Fragments! That way you can have the same Fragment do double-duty. I usually create a third View generation method that both onCreateView() and onCreateDialog() call into when creating a dual-purpose Fragment.</p></li>
<li><p><code>FragmentManager.enableDebugLogging()</code> &ndash; Help when you need it when figuring out Fragments.</p></li>
<li><p><code>LocalBroadcastManager</code> &ndash; Safer than global broadcasts. Simple and quick. Event buses like otto may make more sense for your use case though.</p></li>
<li><p><code>PhoneNumberUtils.formatNumber()</code> &ndash; Let someone else figure out this problem for you.</p></li>
<li><p><code>Region.op()</code> &ndash; I found this useful for comparing two generic areas before rendering. If I&rsquo;ve got two Paths, do they overlap? I can figure that out with this method.</p></li>
<li><p><code>Application.registerActivityLifecycleCallbacks</code> &ndash; Though lacking documentation I feel this is self-evident. Just a handy tool.</p></li>
<li><p><code>versionNameSuffix</code> &ndash; This gradle setting lets you modify the versionName field in your manifest based on different build types. For example, I would setup my debug build type to end in &ldquo;-SNAPSHOT&rdquo;; that way you can easily tell if you&rsquo;re on a debug build or release build.</p></li>
<li><p><code>CursorJoiner</code> &ndash; If you&rsquo;re using a single database then a join in SQL is the natural solution, but what if you&rsquo;ve received data from two separate ContentProviders? In that case CursorJoiner can be helpful.</p></li>
<li><p><code>Genymotion</code> &ndash; A much faster Android emulator. I use it all day.</p></li>
<li><p><code>-nodpi</code> &ndash; Most qualifiers (-mdpi, -hdpi, -xhdpi, etc.) automatically scale assets/dimensions if you&rsquo;re on a device that isn&rsquo;t explicitly defined. Sometimes you just want something consistent though; in that case use -nodpi.</p></li>
<li><p><code>BroadcastRecevier.setDebugUnregister()</code> &ndash; Another handy debugging tool.</p></li>
<li><p><code>Activity.recreate()</code> &ndash; Forces an Activity to recreate itself for whatever reason.</p></li>
<li><p><code>PackageManager.checkSignatures()</code> &ndash; You can use this to find out if two apps (presumably your own) are installed at the same time. Without checking signatures someone could imitate your app easily by just using the same package name.</p></li>
</ul>


<h3 id="part4">Part IV</h3>


<ul>
<li><p><code>Activity.isChangingConfigurations()</code> &ndash; Often times you don&rsquo;t need to do quite as much saving of state if all that&rsquo;s happening is the configuration is changing.</p></li>
<li><p><code>SearchRecentSuggestionsProvider</code> &ndash; A quick and easy way to create a recents suggestion provider.</p></li>
<li><p><code>ViewTreeObserver</code> &ndash; This is an amazing utility; it can be grabbed from any View and used to monitor the state of the View hierarchy. My most often use for it is to determine when Views have been measured (usually for animation purposes).</p></li>
<li><p><code>org.gradle.daemon=true</code> &ndash; Helps reduce the startup time of of Gradle builds. Only really applies to command-line builds as Android Studio already tries to use the daemon.</p></li>
<li><p><code>DatabaseUtils</code> &ndash; A variety of useful tools for database operations.</p></li>
<li><p><code>android:weightSum</code> (LinearLayout) &ndash; Want to use layout weights, but don&rsquo;t want them to fill the entire LinearLayout? That&rsquo;s what weightSum can do by defining the total weight.</p></li>
<li><p><code>android:duplicateParentState</code> (View) &ndash; Makes the child duplicate the state of the parent &ndash; for example, if you&rsquo;ve got a ViewGroup that is clickable, then you can use this to make its children change state when it is clicked.</p></li>
<li><p><code>android:clipChildren</code> (ViewGroup) &ndash; If disabled, this lets the children of a ViewGroup draw outside their parent&rsquo;s bounds. Great for animations.</p></li>
<li><p><code>android:fillViewport</code> (ScrollView) &ndash; Best explained in this post, this helps solve a problem with ScrollViews that may not always have enough content to actually fill the height of the screen.</p></li>
<li><p><code>android:tileMode</code> (BitmapDrawable) &ndash; Lets you create repeated patterns with images.</p></li>
<li><p><code>android:enterFadeDuration/android:exitFadeDuration</code> (Drawables) &ndash; For Drawables that have multiple states, this lets you define a fade before/after the drawable shows.</p></li>
<li><p><code>android:scaleType</code> (ImageView) &ndash; Defines how to scale/crop a drawable within an ImageView. &ldquo;centerCrop&rdquo; and &ldquo;centerInside&rdquo; are regular settings for me.</p></li>
<li><p><code>&lt;merge&gt;</code> &ndash; Lets you include a layout in another without creating a duplicate ViewGroup (more info). Also good for custom ViewGroups; you can inflate a layout with <merge> inside the constructor to define its children automatically.</p></li>
<li><p><code>AtomicFile</code> &ndash; Manipulates a file atomically by using a backup file. I&rsquo;ve written this myself before, it&rsquo;s good to have an official (and better-written) version of it.</p></li>
</ul>


<h3 id="part5">Part V</h3>


<ul>
<li><p><code>ViewDragHelper</code> &ndash; Dragging Views is a complex problem and this class helps a lot. If you want an example, DrawerLayout uses it for swiping. Flavient Laurent also wrote an excellent article about it.</p></li>
<li><p><code>PopupWindow</code> &ndash; Used all around Android without you even realizing it (action bars, autocomplete, edittext errors), this class is the primary method for creating floating content.</p></li>
<li><p><code>ActionBar.getThemedContext()</code> &ndash; ActionBar theming is surprisingly complex (and can be different from the theming of the rest of the Activity). This gets you a Context so if you create your own Views they will be properly themed.</p></li>
<li><p><code>ThumbnailUtils</code> &ndash; Helps create thumbnails; in general I&rsquo;d just use whatever image library was already in place (e.g. Picasso or Volley), but it can also create video thumbnails!</p></li>
<li><p><code>Context.getExternalFilesDir()</code> &ndash; While you do have permission to write anywhere on the SD card if you ask for it, it&rsquo;s much more polite to write your data in the correct designated folder. That way it gets cleaned up and users get a common experience. Additionally, as of Kit Kat you can write to this folder without permission, and each user has their own external files dir.</p></li>
<li><p><code>SparseArray</code> &ndash; A more efficient version of Map&lt;Integer, Object>. Be sure to check out sister classes SparseBooleanArray, SparseIntArray and SparseLongArray as well.</p></li>
<li><p><code>PackageManager.setComponentEnabledSetting()</code> &ndash; Lets you enable/disable components in your app&rsquo;s manifest. What&rsquo;s nice here is being able to shut off unnecessary functionality &ndash; for example, a BroadcastReceiver that is unnecessary due to the current app configuration.</p></li>
<li><p><code>SQLiteDatabase.yieldIfContendedSafely()</code> &ndash; Lets you temporarily stop a db transaction so you don&rsquo;t tie up too much of the system.</p></li>
<li><p><code>Environment.getExternalStoragePublicDirectory()</code> &ndash; Again, users like a consistent experience with their SD card; using this method will grab the correct directory for placing typed files (music, pictures, etc.) on their drive.</p></li>
<li><p><code>View.generateViewId()</code> &ndash; Every once in a while I&rsquo;ve wanted to dynamically generate view IDs. The problem is ensuring you aren&rsquo;t clobbering existing IDs (or other generated ones).</p></li>
<li><p><code>ActivityManager.clearApplicationUserData()</code> &ndash; A reset button for your app. Perhaps the easiest way to log out a user, ever.</p></li>
<li><p><code>Context.createConfigurationContext()</code> &ndash; Customize your configuration context. Common problem I&rsquo;ve run into: forcing part of an app to render in a particular locale (not that I normally condone this sort of behavior, but you never know). This would make it a lot easier to do so.</p></li>
<li><p><code>ActivityOptions</code> &ndash; Nice custom animations when moving between Activities. ActivityOptionsCompat is good for backwards compatible functionality.</p></li>
<li><p><code>AdapterViewFlipper.fyiWillBeAdvancedByHostKThx()</code> &ndash; Because it&rsquo;s funny and for no other reason. There are other amusing tidbits in AOSP (like GRAVITY_DEATH_STAR_I) but unlike those this one is actually useful.</p></li>
<li><p><code>ViewParent.requestDisallowInterceptTouchEvent()</code> &ndash; The Android touch event system defaults handle what you want most of the time, but sometimes you need this method to wrest event control from parents. (By the way, if you want to know about the touch system, this talk is amazing.)</p></li>
</ul>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Android Context]]></title>
    <link href="http://Solarex.github.io/blog/2014/10/14/android-context/"/>
    <updated>2014-10-14T10:11:00+08:00</updated>
    <id>http://Solarex.github.io/blog/2014/10/14/android-context</id>
    <content type="html"><![CDATA[<center><p><img src="http://Solarex.github.io/images/android_robot.png" width="255" height="300"></p></center>


<p>Context is probably the most used element in Android applications…it may also be the most misused.Context objects are so common, and get passed around so frequently, it can be easy to create a situation you didn’t intend.  Loading resources, launching a new Activity, obtaining a system service, getting internal file paths, and creating views all require a Context (and that’s not even getting started on the full list!) to accomplish the task.  What I’d like to do is provide for you some insights on how Context works alongside some tips that will (hopefully) allow you to leverage it more effectively in your applications.</p>

<!-- more -->


<h2>Context Types</h2>

<p>Not all Context instances are created equal.  Depending on the Android application component, the Context you have access to varies slightly:</p>

<ul>
<li><p><strong>Application</strong> – is a singleton instance running in your application process.  It can be accessed via methods like getApplication() from an Activity or Service, and getApplicationContext() from any other object that inherits from Context.  Regardless of where or how it is accessed, you will always receive the same instance from within your process.</p></li>
<li><p><strong>Activity/Service</strong> – inherit from ContextWrapper which implements the same API, but proxies all of its method calls to a hidden internal Context instance, also known as its base context.  Whenever the framework creates a new Activity or Service instance, it also creates a new ContextImpl instance to do all of the heavy lifting that either component will wrap.  Each Activity or Service, and their corresponding base context, are unique per-instance.</p></li>
<li><p><strong>BroadcastReceiver</strong> – is not a Context in and of itself, but the framework passes a Context to it in onReceive() each time a new broadcast event comes in.  This instance is a ReceiverRestrictedContext with two main functions disabled; calling registerReceiver() and bindService().  These two functions are not allowed from within an existing BroadcastReceiver.onReceive().  Each time a receiver processes a broadcast, the Context handed to it is a new instance.</p></li>
<li><p><strong>ContentProvider</strong> – is also not a Context but is given one when created that can be accessed via <code>getContext()</code>.  If the <code>ContentProvider</code> is running local to the caller (i.e. same application process), then this will actually return the same Application singleton.  However, if the two are in separate processes, this will be a newly created instance representing the package the provider is running in.</p></li>
</ul>


<h2>Saved References</h2>

<p>The first issue we need to address comes from saving a reference to a <code>Context</code> in an object or class that has a lifecycle that extends beyond that of the instance you saved.  For example, creating a custom singleton that requires a <code>Context</code> to load resources or access a <code>ContentProvider</code>, and saving a reference to the current <code>Activity</code> or <code>Service</code> in that singleton.</p>

<p>Bad Singleton</p>

<p>```java
public class CustomManager {</p>

<pre><code>private static CustomManager sInstance;

public static CustomManager getInstance(Context context) {
    if (sInstance == null) {
        sInstance = new CustomManager(context);
    }

    return sInstance;
}

private Context mContext;

private CustomManager(Context context) {
    mContext = context;
}
</code></pre>

<p>}
```</p>

<p>The problem here is we don’t know where that <code>Context</code> came from, and it is not safe to hold a reference to the object if it ends up being an <code>Activity</code> or a <code>Service</code>.  This is a problem because a singleton is managed by a single static reference inside the enclosing class.  This means that our object, and ALL the other objects referenced by it, will never be garbage collected.  If this <code>Context</code> were an Activity, we would effectively hold hostage in memory all the views and other potentially large objects associated with it; creating a leak.</p>

<p>To protect against this, we modify the singleton to always reference the application context:</p>

<p>Better Singleton</p>

<p>```java
public class CustomManager {</p>

<pre><code>private static CustomManager sInstance;

public static CustomManager getInstance(Context context) {
    if (sInstance == null) {
        //Always pass in the Application Context
        sInstance = new CustomManager(context.getApplicationContext());
    }

    return sInstance;
}

private Context mContext;

private CustomManager(Context context) {
    mContext = context;
}
</code></pre>

<p>}
```</p>

<p>Now it doesn’t matter where our <code>Context</code> came from, because the reference we are holding is safe.  The application context is itself a singleton, so we aren’t leaking anything by creating another static reference to it.  Another great example of places where this can crop up is saving references to a <code>Context</code> from inside a running background thread or a pending Handler.</p>

<p>So why can’t we always just reference the application context?  Take the middleman out of the equation, as it were, and never have to worry about creating leaks?  The answer, as I alluded to in the introduction, is because one <code>Context</code> is not equal to another.</p>

<h2>Context Capabilities</h2>

<p>The common actions you can safely take with a given <code>Context</code> object depends on where it came from originally.  Below is a table of the common places an application will receive a <code>Context</code>, and in each case what it is useful for:</p>

<table border="1" width="90%" align="center">
<thead>
<tr>
<th></th>
<th align="center">Application</th>
<th align="center">Activity</th>
<th align="center">Service</th>
<th align="center">ContentProvider</th>
<th align="center">BroadcastReceiver</th>
</tr>
</thead>
<tbody>
<tr>
<td>Show a Dialog</td>
<td align="center">NO</td>
<td align="center">YES</td>
<td align="center">NO</td>
<td align="center">NO</td>
<td align="center">NO</td>
</tr>
<tr>
<td>Start an Activity</td>
<td align="center">NO<sup>1</sup></td>
<td align="center">YES</td>
<td align="center">NO<sup>1</sup></td>
<td align="center">NO<sup>1</sup></td>
<td align="center">NO<sup>1</sup></td>
</tr>
<tr>
<td>Layout Inflation</td>
<td align="center">NO<sup>2</sup></td>
<td align="center">YES</td>
<td align="center">NO<sup>2</sup></td>
<td align="center">NO<sup>2</sup></td>
<td align="center">NO<sup>2</sup></td>
</tr>
<tr>
<td>Start a Service</td>
<td align="center">YES</td>
<td align="center">YES</td>
<td align="center">YES</td>
<td align="center">YES</td>
<td align="center">YES</td>
</tr>
<tr>
<td>Bind to a Service</td>
<td align="center">YES</td>
<td align="center">YES</td>
<td align="center">YES</td>
<td align="center">YES</td>
<td align="center">NO</td>
</tr>
<tr>
<td>Send a Broadcast</td>
<td align="center">YES</td>
<td align="center">YES</td>
<td align="center">YES</td>
<td align="center">YES</td>
<td align="center">YES</td>
</tr>
<tr>
<td>Register BroadcastReceiver</td>
<td align="center">YES</td>
<td align="center">YES</td>
<td align="center">YES</td>
<td align="center">YES</td>
<td align="center">NO<sup>3</sup></td>
</tr>
<tr>
<td>Load Resource Values</td>
<td align="center">YES</td>
<td align="center">YES</td>
<td align="center">YES</td>
<td align="center">YES</td>
<td align="center">YES</td>
</tr>
</tbody>
</table>


<ul>
<li>An application CAN start an <code>Activity</code> from here, but it requires that a new task be created.  This may fit specific use cases, but can create non-standard back stack behaviors in your application and is generally not recommended or considered good practice.</li>
<li>This is legal, but inflation will be done with the default theme for the system on which you are running, not what’s defined in your application.</li>
<li>Allowed if the receiver is null, which is used for obtaining the current value of a sticky broadcast, on Android 4.2 and above.</li>
</ul>


<h2>User Interface</h2>

<p>You can see from looking at the previous table that there are a number of functions the application context is not properly suited to handle; all of them related to working with the UI.  In fact, the only implementation equipped to handle all tasks associated with the UI is <code>Activity</code>; the other instances fare pretty much the same in all categories.</p>

<p>Luckily, these three actions are things an application doesn’t really have any place doing outside the scope of an <code>Activity</code>; it’s almost like the framework was designed that way on purpose.  Attempting to show a Dialog that was created with a reference to the application context, or starting an <code>Activity</code> from the application context will throw an exception and crash your application…a strong indicator something has gone wrong.</p>

<p>The less obvious issue is inflating layouts.  If you read my last piece on layout inflation, you already know that it can be a slightly mysterious process with some hidden behaviors;  using the right <code>Context</code> is linked to another one of those behaviors.  While the framework will not complain and will return a perfectly good view hierarchy from a <code>LayoutInflater</code> created with the application context, the themes and styles from your app will not be considered in the process.  This is because <code>Activity</code> is the only <code>Context</code> on which the themes defined in your manifest are actually attached.  Any other instance will use the system default theme to inflate your views, leading to a display output you probably didn’t expect.</p>

<h2>The Intersection of these Rules</h2>

<p>Invariably, someone will arrive at the conclusion that these two rules conflict.  There is a case in the application’s current design where a long-term reference must be saved and we must save an <code>Activity</code> because the tasks we want to accomplish include manipulation of the UI.  If that is the case, I would urge you to reconsider your design, as this would be a textbook instance of fighting the framework.</p>

<h2>The Rule of Thumb</h2>

<p>In most cases, use the <code>Context</code> directly available to you from the enclosing component you’re working within.  You can safely hold a reference to it as long as that reference does not extend beyond the lifecycle of that component. As soon as you need to save a reference to a <code>Context</code> from an object that lives beyond your <code>Activity</code> or <code>Service</code>, even temporarily, switch that reference you save over to the application context.</p>

<p>Context对象是最常见的对象，经常用于参数传递，因此也会出现一些你意想不到的情况。加载资源文件，启动一个新的Activity，获取一个系统服务，获取内部文件路径和创建view全部（这些仅仅是一部分）都需要一个Context对象来完成这些操作。我们想做的是给你展示Context如何工作，以及提供一些建议会（希望会）让你在开发中更合理的使用Context。</p>

<h2>Context类型</h2>

<p>并不是所有的Context对象都相同，根据Android应用组件的不同，可以分为以下几种：</p>

<ul>
<li><strong>Application</strong>：它是应用程序的一个单例，它可以通过<code>Activity</code>或<code>Service</code>的<code>getApplication()</code>方法获取，也可以在任何继承<code>Context</code>类的的对象中通过<code>getApplicationContext()</code>来获取。不管它是怎么获取的，这些方法返回的都是App中同一个实例。</li>
<li><strong>Activity/Service</strong>：它们继承自<code>ContextWrapper</code>，<code>ContextWrapper</code>实现了<code>Context</code>同样的API，但是隐藏了内部<code>Context</code>对象的方法调用，<code>Context</code>也是<code>ContextWrapper</code>的父类。每当系统创建一个<code>Activity</code>或<code>Service</code>对象的时候，它也为它们创建了新的<code>ContextWrapper</code>对象。每个<code>Activity</code>或<code>Service</code>对象，包括他们对应的context对象都是唯一的。</li>
<li><strong>BroadcastReceiver</strong>：它并不拥有<code>Context</code>对象，但是系统在一个新的广播到来的时候通过<code>onReceiver()</code>方法传入一个<code>Context</code>对象，这是一个<code>ReceiverRestrictedContext</code>，它的两个主要方法，<code>registerReceiver()</code>和<code>bindService()</code>都被禁用了。每一次receiver处理一个广播，传入的<code>Context</code>对象都是一个新的实例。</li>
<li><strong>ContentProvider</strong>：同样也不是一个<code>Context</code>对象，但是在创建的时候会通过<code>getContext()</code>方法传入一个context对象。如果<code>ContentProvider</code>是在本地调用的话（在同一个进程中），那么这会返回一个应用单例。然而，如果是在不同的进程中调用的话，它会新建一个context对象表示当前provider运行的进程。</li>
</ul>


<h2>Saved References</h2>

<p>第一个问题是，我们想在一个对象中保存一个Context对象的引用，并且这个对象的生命周期超过了你保存的Context对象。比如：创建一个需要一个Context对象的单例来加载文件资源或访问一个<code>ContentProvider</code>，并且在这个单例中保存当前<code>Activity</code>或<code>Service</code>的引用。</p>

<p>Bad Singleton这里的问题在于，我们并不知道Context从哪里来，并且如果单例保存了Activity或Service的引用，如果它们被销毁了，这样是不安全的。这个问题是因为单例在类里面保存了一个静态引用。这就意味着那个对象，以及这个对象引用的所有对象都不会被gc回收。如果Context对象是一个Activity，我们就会始终持有这个Activity的所有View以及其他可能很大的对象，最终导致内存泄露。</p>

<p>为了防止出现这种情况，我们可以修改这个类让它持有Application Context,Better Singleton：现在，不管context对象是从哪里传入的，因为现在单例持有的是Application Context，这个是安全的，因为Application Context 本身就是一个单例，因此不会造成内存泄露。还有一个类似的问题就是在一个后台线程（background thread）或一个延时Handler中持有一个对Context的引用。
既然Application Context有那么多好处，我们为什么不用Application Context来处理一切呢？这个问题的答案就是，前面提到过的，是因为<strong>这些Context并不都是相同的。</strong></p>

<p>从上文中可以知道，Context有多种来源，而不同来源的Context所具有的通用操作也不一样，下表列出了各种不同Context 的作用域：这几个Context只有Activity的Context是“看的见的”，其他组件的Context都是“看不见的”。因此，如果你想创建一个比如Dialog，Activity等“看的见”的组件就必须要用Activity的Context。比如，你想调用getString或getResource方法获取res文件夹下的资源时，所有的Context对象都可以使用。因为这些东西都是“看不见”的。</p>

<h2>用户界面</h2>

<p>你可以从上面的表格中看到Application Context有很多事情是做不了的，它不能做的事情都与UI有关。事实上，只有Activity才能够处理与UI有关的任务，其他的Context都是非常相似的（不能处理与UI有关的任务）。
这3个任务（“Show a Dialog”，“Start a Activity”，“Layout Inflation”）似乎就是Android系统就是这么设计的，让Activity来处理这些与UI有关的任务。想要使用Application Context对象来新建一个Dialog或者启动一个Activity系统就会抛出异常，然后程序就会崩溃。
Infalting layouts是一个容易被忽略的问题，如果你读过这篇文章<a href="http://www.doubleencore.com/2013/05/layout-inflation-as-intended/">layout inflation</a>，你就会明白这里面隐藏着一些坑…使用不同的Context就是会带你走向不同坑。当你使用LayoutInflator，并且使用Application Context后，它会返回一个View，但是这个View的主题和样式就会被忽略。这是因为，Activity 才是系统配置文件中的唯一持有主题和样式的Context。其他所有的Context都会使用系统默认的主题来渲染你的xml来生成View，最终就导致了界面并不是你想要的。</p>

<h2>结论</h2>

<p>很多情况下，你可以在一个组件内部使用Context对象，你可以很安全的持有Context的引用，前提就是你的对象生命周期小于Context的生命周期。如果你的对象需要持有一个比Context生命周期要长的Context引用时，即使你的对象也是一个临时对象，也请你考虑保存Application Context 的引用！</p>

<p>REF:<a href="http://www.doubleencore.com/2013/06/context/">Context</a></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[A journey on the Android Main Thread]]></title>
    <link href="http://Solarex.github.io/blog/2014/10/13/android-main-thread/"/>
    <updated>2014-10-13T16:51:00+08:00</updated>
    <id>http://Solarex.github.io/blog/2014/10/13/android-main-thread</id>
    <content type="html"><![CDATA[<p>When facing bugs that were related to how we interact with the main thread, I decided to get a closer look at what the main thread really is.</p>

<p>```java
public class BigBang {
  public static void main(String&hellip; args) {</p>

<pre><code>// The Java universe starts here.
</code></pre>

<p>  }
}
```</p>

<p>All Java programs start with a call to a <code>public static void main()</code> method. This is true for Java Desktop programs, JEE servlet containers, and Android applications.</p>

<p>When the Android system boots, it starts a Linux process called <code>ZygoteInit</code>. This process is a Dalvik VM that loads the <a href="https://android.googlesource.com/platform/frameworks/base/+/refs/heads/master/preloaded-classes">most common classes</a> of the Android SDK on a thread, and then waits.</p>

<!-- more -->


<p>When starting a new Android application, the Android system forks the <code>ZygoteInit</code> process. The thread in the child fork stops waiting, and calls <code>ActivityThread.main()</code>.</p>

<h2>Loopers</h2>

<p>Before going any further, we need to look at the <code>Looper</code> class.</p>

<p>Using a looper is a good way to dedicate one thread to process messages serially.</p>

<p>Each looper has a queue of <code>Message</code> objects (a <code>MessageQueue</code>).</p>

<p>A looper has a <code>loop()</code> method that will process each message in the queue, and block when the queue is empty.</p>

<p>The <code>Looper.loop()</code> method code is similar to this:</p>

<p>```java
void loop() {
  while(true) {</p>

<pre><code>Message message = queue.next(); // blocks if empty.
dispatchMessage(message);
message.recycle();
</code></pre>

<p>  }
}
```</p>

<p>Each looper is associated with one thread. To create a new looper and associate it to the current thread, you must call <code>Looper.prepare()</code>. The loopers are stored in a static <code>ThreadLocal</code> in the <code>Looper</code> class. You can retrieve the <code>Looper</code> associated to the current thread by calling <code>Looper.myLooper()</code>.</p>

<p>The <code>HandlerThread</code> class does everything for you:</p>

<p><code>java
HandlerThread thread = new HandlerThread("SquareHandlerThread");
thread.start(); // starts the thread.
Looper looper = thread.getLooper();
</code></p>

<p>Its code is similar to this:</p>

<p>```java
class HandlerThread extends Thread {
  Looper looper;
  public void run() {</p>

<pre><code>Looper.prepare(); // Create a Looper and store it in a ThreadLocal.
looper = Looper.myLooper(); // Retrieve the looper instance from the ThreadLocal, for later use.
Looper.loop(); // Loop forever.
</code></pre>

<p>  }
}
```</p>

<h2>Handlers</h2>

<p>A handler is the natural companion to a looper.</p>

<p>A handler has two purposes:</p>

<ul>
<li>Send messages to a looper message queue from any thread.</li>
<li>Hndle messages dequeued by a looper on the thread associated to that looper.</li>
</ul>


<p>```java
// Each handler is associated to one looper.
Handler handler = new Handler(looper) {
  public void handleMessage(Message message) {</p>

<pre><code>// Handle the message on the thread associated to the given looper.
if (message.what == DO_SOMETHING) {
  // do something
}
</code></pre>

<p>  }
};</p>

<p>// Create a new message associated to that handler.
Message message = handler.obtainMessage(DO_SOMETHING);</p>

<p>// Add the message to the looper queue.
// Can be called from any thread.
handler.sendMessage(message);
```</p>

<p>You can associate multiple handlers to one looper. The looper delivers the message to <code>message.target</code>.</p>

<p>A popular and simpler way to use a handler is to post a <code>Runnable</code>:</p>

<p>```java
// Create a message containing a reference to the runnable and add it to the looper queue
handler.post(new Runnable() {
  public void run() {</p>

<pre><code>// Runs on the thread associated to the looper associated to that handler.
</code></pre>

<p>  }
});
```</p>

<p>A handler can also be created without providing any looper:</p>

<p><code>java
// DON'T DO THIS
Handler handler = new Handler();
</code></p>

<p>The handler no argument constructor calls <code>Looper.myLooper()</code> and retrieves the looper associated with the current thread. This may or may not be the thread you actually want the handler to be associated with.</p>

<p>Most of the time, you just want to create a handler to post on the main thread:</p>

<p><code>java
Handler handler = new Handler(Looper.getMainLooper());
</code></p>

<p>Back to PSVM
Let&rsquo;s look at <code>ActivityThread.main()</code> again. Here is what it is essentially doing:</p>

<p>```java
public class ActivityThread {
  public static void main(String&hellip; args) {</p>

<pre><code>Looper.prepare();

// You can now retrieve the main looper at any time by calling Looper.getMainLooper().
Looper.setMainLooper(Looper.myLooper());

// Post the first messages to the looper.
// { ... }

Looper.loop();
</code></pre>

<p>  }
}
```</p>

<p>Now you know why this thread is called the main thread :) .</p>

<p>Note: As you would expect, one of the first things that the main thread will do is create the <code>Application</code> and call <code>Application.onCreate()</code>.</p>

<h2>Activities love orientation changes</h2>

<p>Let&rsquo;s start with the activity lifecycle and the magic behind the handling of configuration changes.</p>

<h3>Why it matters</h3>

<p>This article was inspired by a real crash that occurred in Square Register.
A simplified version of the code is:</p>

<p>```java
public class MyActivity extends Activity {
  protected void onCreate(Bundle savedInstanceState) {</p>

<pre><code>super.onCreate(savedInstanceState);
Handler handler = new Handler(Looper.getMainLooper());
handler.post(new Runnable() {
  public void run() {
    doSomething();
  }
});
</code></pre>

<p>  }</p>

<p>  void doSomething() {</p>

<pre><code>// Uses the activity instance
</code></pre>

<p>  }
}
```</p>

<p>As we will see, <code>doSomething()</code> can be called after the activity <code>onDestroy()</code> method has been called due to a configuration change. At that point, you should not use the activity instance anymore.</p>

<h3>A refresher on orientation changes</h3>

<p>The device orientation can change at any time. We will simulate an orientation change while the activity is being created using <code>Activity#setRequestedOrientation(int)</code>.</p>

<p>Can you predict the log output when starting this activity in portrait?</p>

<p>```java
public class MyActivity extends Activity {
  protected void onCreate(Bundle savedInstanceState) {</p>

<pre><code>super.onCreate(savedInstanceState);
Log.d("Square", "onCreate()");
if (savedInstanceState == null) {
  Log.d("Square", "Requesting orientation change");
  setRequestedOrientation(ActivityInfo.SCREEN_ORIENTATION_LANDSCAPE);
}
</code></pre>

<p>  }</p>

<p>  protected void onResume() {</p>

<pre><code>super.onResume();
Log.d("Square", "onResume()");
</code></pre>

<p>  }</p>

<p>  protected void onPause() {</p>

<pre><code>super.onPause();
Log.d("Square", "onPause()");
</code></pre>

<p>  }</p>

<p>  protected void onDestroy() {</p>

<pre><code>super.onDestroy();
Log.d("Square", "onDestroy()");
</code></pre>

<p>  }
}
```</p>

<p>If you know the Android lifecycle, you probably predicted this:</p>

<p><code>java
onCreate()
Requesting orientation change
onResume()
onPause()
onDestroy()
onCreate()
onResume()
</code></p>

<p>The Android Lifecycle goes on normally, the activity is created, resumed, and then the orientation change is taken into account and the activity is paused, destroyed, and a new activity is created and resumed.</p>

<h3>Orientation changes and the main thread</h3>

<p>Here is an important detail to remember: an orientation change leads to recreating the activity via a simple post of a message to the main thread looper queue.</p>

<p>Let&rsquo;s look at that by writing a spy that will read the content of the looper queue via reflection:</p>

<p>```java
public class MainLooperSpy {
  private final Field messagesField;
  private final Field nextField;
  private final MessageQueue mainMessageQueue;</p>

<p>  public MainLooperSpy() {</p>

<pre><code>try {
  Field queueField = Looper.class.getDeclaredField("mQueue");
  queueField.setAccessible(true);
  messagesField = MessageQueue.class.getDeclaredField("mMessages");
  messagesField.setAccessible(true);
  nextField = Message.class.getDeclaredField("next");
  nextField.setAccessible(true);
  Looper mainLooper = Looper.getMainLooper();
  mainMessageQueue = (MessageQueue) queueField.get(mainLooper);
} catch (Exception e) {
  throw new RuntimeException(e);
}
</code></pre>

<p>  }</p>

<p>  public void dumpQueue() {</p>

<pre><code>try {
  Message nextMessage = (Message) messagesField.get(mainMessageQueue);
  Log.d("MainLooperSpy", "Begin dumping queue");
  dumpMessages(nextMessage);
  Log.d("MainLooperSpy", "End dumping queue");
} catch (IllegalAccessException e) {
  throw new RuntimeException(e);
}
</code></pre>

<p>  }</p>

<p>  public void dumpMessages(Message message) throws IllegalAccessException {</p>

<pre><code>if (message != null) {
  Log.d("MainLooperSpy", message.toString());
  Message next = (Message) nextField.get(message);
  dumpMessages(next);
}
</code></pre>

<p>  }
}
```</p>

<p>As you can see, the message queue is merely a linked list where each message has a reference to the next message.</p>

<p>We log the content of the queue right after the orientation change:</p>

<p>```java
public class MyActivity extends Activity {
  private final MainLooperSpy mainLooperSpy = new MainLooperSpy();</p>

<p>  protected void onCreate(Bundle savedInstanceState) {</p>

<pre><code>super.onCreate(savedInstanceState);
Log.d("Square", "onCreate()");
if (savedInstanceState == null) {
  Log.d("Square", "Requesting orientation change");
  setRequestedOrientation(ActivityInfo.SCREEN_ORIENTATION_LANDSCAPE);
  mainLooperSpy.dumpQueue();
}
</code></pre>

<p>  }
}
```</p>

<p>Here is the output:</p>

<p><code>java
onCreate()
Requesting orientation change
Begin dumping queue
{ what=118 when=-94ms obj={1.0 208mcc15mnc en_US ldltr sw360dp w598dp h335dp 320dpi nrml land finger -keyb/v/h -nav/h s.44?spn} }
{ what=126 when=-32ms obj=ActivityRecord{41fd2b48 token=android.os.BinderProxy@41fcce50 no component name} }
End dumping queue
</code></p>

<p>A quick look at the <code>ActivityThread</code> class tells us what those 118 and 126 messages are:</p>

<p>```java
public final class ActivityThread {
  private class H extends Handler {</p>

<pre><code>public static final int CONFIGURATION_CHANGED   = 118;
public static final int RELAUNCH_ACTIVITY       = 126;
</code></pre>

<p>  }
}
```</p>

<p>Requesting an orientation change added <code>CONFIGURATION_CHANGED</code> and a <code>RELAUNCH_ACTIVITY</code> message to the main thread looper queue.</p>

<p>Let&rsquo;s take a step back and think about what&rsquo;s going on:</p>

<p>When the activity starts for the first time, the queue is empty. The message currently being executed is <code>LAUNCH_ACTIVITY</code>, which creates the activity instance, calls <code>onCreate()</code> and then <code>onResume()</code> in a row. Then only the main looper processes the next message in the queue.</p>

<p>When a device orientation change is detected, a <code>RELAUNCH_ACTIVITY</code> is posted to the queue.</p>

<p>When that message is processed, it:</p>

<ul>
<li>calls <code>onSaveInstanceState()</code>, <code>onPause()</code>, <code>onDestroy()</code> on the old activity instance,</li>
<li>creates a new activity instance,</li>
<li>calls <code>onCreate()</code> and <code>onResume()</code> on that new activity instance.</li>
</ul>


<p>All that in one message handling. Any message you post in the meantime will be handled after <code>onResume()</code> has been called.</p>

<h3>Tying it all together</h3>

<p>What could happen if you post to a handler in <code>onCreate()</code> during an orientation change? Let&rsquo;s look at the two cases, right before and right after the orientation change:</p>

<p>```java
public class MyActivity extends Activity {
  private final MainLooperSpy mainLooperSpy = new MainLooperSpy();</p>

<p>  protected void onCreate(Bundle savedInstanceState) {</p>

<pre><code>super.onCreate(savedInstanceState);
Log.d("Square", "onCreate()");
if (savedInstanceState == null) {
  Handler handler = new Handler(Looper.getMainLooper());
  handler.post(new Runnable() {
    public void run() {
      Log.d("Square", "Posted before requesting orientation change");
    }
  });
  Log.d("Square", "Requesting orientation change");
  setRequestedOrientation(ActivityInfo.SCREEN_ORIENTATION_LANDSCAPE);
  handler.post(new Runnable() {
    public void run() {
      Log.d("Square", "Posted after requesting orientation change");
    }
  });
  mainLooperSpy.dumpQueue();
}
</code></pre>

<p>  }</p>

<p>  protected void onResume() {</p>

<pre><code>super.onResume();
Log.d("Square", "onResume()");
</code></pre>

<p>  }</p>

<p>  protected void onPause() {</p>

<pre><code>super.onPause();
Log.d("Square", "onPause()");
</code></pre>

<p>  }</p>

<p>  protected void onDestroy() {</p>

<pre><code>super.onDestroy();
Log.d("Square", "onDestroy()");
</code></pre>

<p>  }
}
```</p>

<p>Here is the output:</p>

<p><code>java
onCreate()
Requesting orientation change
Begin dumping queue
{ what=0 when=-129ms }
{ what=118 when=-96ms obj={1.0 208mcc15mnc en_US ldltr sw360dp w598dp h335dp 320dpi nrml land finger -keyb/v/h -nav/h s.46?spn} }
{ what=126 when=-69ms obj=ActivityRecord{41fd6b68 token=android.os.BinderProxy@41fd0ae0 no component name} }
{ what=0 when=-6ms }
End dumping queue
onResume()
Posted before requesting orientation change
onPause()
onDestroy()
onCreate()
onResume()
Posted after requesting orientation change
</code></p>

<p>To sum things up: at the end on <code>onCreate()</code>, the queue contained four messages. The first was the post before the orientation change, then the two messages related to the orientation change, and then only the post after the orientation change. The logs show that these were executed in order.</p>

<p>Therefore, any message posted before the orientation change will be handled before <code>onPause()</code> of the leaving activity, and any message posted after the orientation change will be handled after <code>onResume()</code> of the incoming activity.</p>

<p>The practical implication is that when you post a message, you have no guarantee that the activity instance that existed at the time it was sent will still be running when the message is handled (even if you post from <code>onCreate()</code> or <code>onResume()</code>). If your message holds a reference to a view or an activity, the activity won&rsquo;t be garbage collected until the message is handled.</p>

<h3>What could you do?</h3>

<h4>The real fix</h4>

<p>Stop calling <code>handler.post()</code> when you are already on the main thread. In most cases, <code>handler.post()</code> is used as a quick fix to ordering problems. Fix your architecture instead of messing it up with random <code>handler.post()</code> calls.</p>

<h4>If you have a good reason to post</h4>

<p>Make sure your message does not hold a reference to an activity, as you would do for a background operation.</p>

<h4>If you really need that activity reference</h4>

<p>Remove the message from the queue with <code>handler.removeCallbacks()</code> in the activity <code>onPause()</code>.</p>

<h4>If you want to get fired</h4>

<p>Use <code>handler.postAtFrontOfQueue()</code> to make sure a message posted before <code>onPause()</code> is always handled before <code>onPause()</code>. Your code will become really hard to read and understand. Seriously, don&rsquo;t.</p>

<h4>A word on <code>runOnUiThread()</code></h4>

<p>Did you notice that we created a handler and used <code>handler.post()</code> instead of directly calling <code>Activity.runOnUiThread()</code>?</p>

<p>Here is why:</p>

<p>```java
public class Activity {
  public final void runOnUiThread(Runnable action) {</p>

<pre><code>if (Thread.currentThread() != mUiThread) {
  mHandler.post(action);
} else {
  action.run();
}
</code></pre>

<p>  }
}
```</p>

<p>Unlike <code>handler.post()</code>, <code>runOnUiThread()</code> does not post the runnable if the current thread is already the main thread. Instead, it calls <code>run()</code> synchronously.</p>

<h2>Services</h2>

<p>There is a common misconception that needs to die: a service does not run on a background thread.</p>

<p>All service lifecycle methods (<code>onCreate()</code>, <code>onStartCommand()</code>, etc) run on the main thread (the very same thread that&rsquo;s used to play funky animations in your activities).</p>

<p>Whether you are in a service or an activity, long tasks must be executed in a dedicated background thread. This background thread can live as long as the process of your app lives, even when your activities are long gone.</p>

<p>However, at any time the Android system can decide to kill the app process. A service is a way to ask the system to let us live if possible and be polite by letting the service know before killing the process.</p>

<p>Side note: When an <code>IBinder</code> returned from <code>onBind()</code> receives a call from another process, the method will be executed in a background thread.</p>

<p>Take the time to read the Service documentation &mdash; it&rsquo;s pretty good.</p>

<h2>IntentService</h2>

<p>IntentService provides a simple way to serially process a queue of intents on a background thread.</p>

<p>```java
public class MyService extends IntentService {
  public MyService() {</p>

<pre><code>super("MyService");
</code></pre>

<p>  }</p>

<p>  protected void onHandleIntent(Intent intent) {</p>

<pre><code>// This is called on a background thread.
</code></pre>

<p>  }
}
```</p>

<p>Internally, it uses a <code>Looper</code> to handle the intents on a dedicated <code>HandlerThread</code>. When the service is destroyed, the looper lets you finish handling the current intent, and then the background thread terminates.</p>

<h2>Conclusion</h2>

<p>Most Android lifecycle methods are called on the main thread. Think of these callbacks as simple messages sent to a looper queue.</p>

<p>This article wouldn&rsquo;t be complete without the reminder that goes into almost every Android dev article: Do not block the main thread.</p>

<p>REF:<a href="http://corner.squareup.com/2013/10/android-main-thread-1.html">A journey on the Android Main Thread</a>,<a href="http://corner.squareup.com/2013/12/android-main-thread-2.html">A journey on the Android Main Thread &ndash; Lifecycle bits</a></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Intro to Android Loopers and Handlers]]></title>
    <link href="http://Solarex.github.io/blog/2014/10/13/android-looper-handler/"/>
    <updated>2014-10-13T11:24:00+08:00</updated>
    <id>http://Solarex.github.io/blog/2014/10/13/android-looper-handler</id>
    <content type="html"><![CDATA[<p>What can you do with <code>Loopers</code> and <code>Handlers</code>? Basically, they implement a common concurrency pattern that I call the <code>Pipeline Thread</code>. Here’s how it works:</p>

<ul>
<li>The Pipeline Thread holds a queue of tasks which are just some units of work that can be executed or processed.</li>
<li>Other threads can safely push new tasks into the Pipeline Thread’s queue at any time.</li>
<li>The Pipeline Thread processes the queued tasks one after another. If there are no tasks queued, it blocks until a task appears in the queue.</li>
<li>Sometimes tasks can called messages and other names.</li>
</ul>


<!-- more -->


<p>我们能用<code>Loopers</code>和<code>Handlers</code>来干什么？这两个类实现了一种通用的并发模型，我把它叫做：Pipeline 线程。它是这样工作的：
+ Pipeline 线程持有一个任务队列，这些任务就是一些可以执行的工作单元
+ 其他线程可以自由的将任务加到Pipeline线程的任务队列中去
+ Pipeline线程就按次序一个一个执行任务，如果任务队列中没有任务了，它就会自动阻塞直到有任务到来
+ 有些时候，任务可以叫做消息（messages）或者其他名字</p>

<p><code>Looper</code> is a class that turns a thread into a <code>Pipeline Thread</code> and <code>Handler</code> gives you a mechanism to push tasks into it from any other threads.The <code>Looper</code> is named so because it implements the loop – takes the next task, executes it, then takes the next one and so on. The <code>Handler</code> is called a handler because someone could not invent a better name.</p>

<p>Looper类可以将一个线程转换成Pipeline线程，而Handler提供了一种机制，你可以通过它将任务添加到Pipeline线程中。Looper之所以这么命名是因为它实现了循环——取一个task执行，然后再取下一个task执行，如此循环；Handler如此命名是因为他们无法想出一个更好的名字了~</p>

<p>Here’s what you should put into a Thread&rsquo;s <code>run()</code> method to turn it into a Pipeline Thread and to create a <code>Handler</code> so that other threads can assign tasks to it:</p>

<p>下面就是你需要添加到Thread类的run方法中的代码来创建一个你自己的Pipeline线程，并创建一个<code>Handler</code>以便其他线程可以将任务分发到此Pipeline线程中。</p>

<p>```java
@Override
public void run() {
  try {</p>

<pre><code>// preparing a looper on current thread
// the current thread is being detected implicitly
Looper.prepare();

// now, the handler will automatically bind to the
// Looper that is attached to the current thread
// You don't need to specify the Looper explicitly
handler = new Handler();

// After the following line the thread will start
// running the message loop and will not normally
// exit the loop unless a problem happens or you
// quit() the looper (see below)
Looper.loop();
</code></pre>

<p>  } catch (Throwable t) {</p>

<pre><code>Log.e(TAG, "halted due to an error", t);
</code></pre>

<p>  }
}
```</p>

<p>After that, you can just pass the handler to any other thread. It has a thread-safe interface that includes many operations, but the most straightforward ones are <code>postMessage()</code> and its relatives.</p>

<p>然后，你只要将这个handler对象传到其他任何线程中去，它有一个线程安全的接口，包括了很多操作，但是最主要的操作就是postMessage()以及相关的方法了。</p>

<p>For example, imagine another thread has a reference to the handler that was created in our Pipeline Thread. Here’s how that other thread can schedule an operation to be executed in the Pipeline Thread:</p>

<p>想象一下，一个线程A持有了handler对象的引用，此handler是在Pipeline线程中创建的，下面代码就可以让这个线程A在Pipeline线程中执行操作了：</p>

<p>```java
handler.post(new Runnable() {
  @Override
  public void run() {</p>

<pre><code>// this will be done in the Pipeline Thread
</code></pre>

<p>  }
});
```</p>

<p>By the way, the UI thread has a <code>Looper</code> created for it implicitly, so you can just create a <code>Handler</code> in activity&rsquo;s <code>onCreate()</code> and it will work fine:</p>

<p>UI线程拥有一个Looper（可以通过<code>Looper.getMainLooper()</code>方法获取，判断一个线程是否为主线程可以使用<code>Looper.getLooper() == Looper.getMainLooper()</code>来判断）。所以，你可以在<code>Activity</code>的<code>onCreate()</code>方法中直接新建一个handler对象：</p>

<p>```java
@Override
public void onCreate(Bundle savedInstanceState) {</p>

<pre><code>super.onCreate(savedInstanceState);
setContentView(R.layout.main);

// Create the Handler. It will implicitly bind to the Looper
// that is internally created for this thread (since it is the UI thread)
handler = new Handler();
</code></pre>

<p>}
```</p>

<p>什么时候使用多线程:
1. 耗时操作使用多线程, 耗时操作放在UI线程中会导致用户的操作无法得到响应.
2. 阻塞操作使用多线程, 理由同上.
3. 多核CPU的设备使用多线程, 可以有效提高CPU的利用率.
4. 并行操作使用多线程.</p>

<p>android中的多线程模型主要涉及的类有:Looper, Handler, MessageQueue, Message等.</p>

<p>Looper类用来创建消息队列. 每个线程最多只能有一个消息队列, android中UI线程默认具有消息队列, 但非UI线程在默认情况下是不具备消息队列的. 如果需要在非UI线程中开启消息队列, 需要调用<code>Looper.prepare()</code>方法, 在该方法的执行过程中会创建一个<code>Looper</code>对象, 而<code>Looper</code>的构造函数中会创建一个<code>MessageQueue</code> instance(Looper的构造函数是私有的, 在Looper类之外无法创建其对象).  此后再为该线程绑定一个Handler instance, 然后调用Looper.loop()方法, 就可以不断的从消息队列中取出消息和处理消息了. <code>Looper.myLooper()</code>方法可以得到线程的Looper对象, 如果为null, 说明此时该线程尚未开启消息队列.</p>

<p>Handler类用于处理消息. 该类具有四个构造函数:
1. <code>public Handler()</code>. 创建好的<code>Handler</code> instance将绑定在代码所在的线程的消息队列上, 因此一定要确定该线程开启了消息队列, 否则程序将发生错误. 使用这个构造函数创建<code>Handler</code> instance, 一般来说, 我们需要重写<code>Hanler</code>类的<code>handleMessage()</code>方法, 以便在之后的消息处理时调用.
2. <code>public Handler(Callback callback)</code>. <code>Callback</code>是<code>Handler</code>内部定义的一个接口, 因此想要使用这个构造函数创建<code>Handler</code>对象, 需要自定义一个类实现<code>Callback</code>接口, 并重写接口中定义的<code>handleMessage()</code>方法. 这个构造函数其实与无参的构造函数类似, 也要确保代码所在的线程开启了消息队列. 不同的是在之后处理消息时, 将调用<code>callback</code>的<code>handleMessage()</code>方法, 而不是<code>Handler</code>对象的<code>handleMssage()</code>方法.
3. <code>public Handler(Looper looper)</code>. 这个构造函数表示创建一个<code>Handler</code> instance, 并将其绑定在looper所在的线程上. 此时looper不能为null. 此时一般也需要重写<code>Hanler</code>类的<code>handleMessage()</code>方法
4. <code>public Handler(Looper looper, Callback callback)</code>. 可以结合2和3理解.</p>

<p><code>MessageQueue</code>类用于表示消息队列. 队列中的每一个Message都有一个when字段, 这个字段用来决定Message应该何时出对处理. 消息队列中的每一个Message根据when字段的大小由小到大排列, 排在最前面的消息会首先得到处理, 因此可以说消息队列并不是一个严格的先进先出的队列.</p>

<p><code>Message</code>类用于表示消息. <code>Message</code>对象可以通过arg1, arg2, obj字段和<code>setData()</code>携带数据, 此外还具有很多字段. when字段决定Message应该何时处理, target字段用来表示将由哪个Handler对象处理这个消息, next字段表示在消息队列中排在这个Message之后的下一个Message, callback字段如果不为null表示这个Message包装了一个runnable对象, what字段表示code, 即这个消息具体是什么类型的消息. 每个what都在其handler的namespace中, 我们只需要确保将由同一个handler处理的消息的what属性不重复就可以.</p>

<p>将消息压入消息队列: <code>Message</code>对象的<code>target</code>字段关联了哪个线程的消息队列, 这个消息就会被压入哪个线程的消息队列中.
1. 调用<code>Handler</code>类中以<code>send</code>开头的方法可以将<code>Message</code>对象压入消息队列中, 调用Handler类中以post开头的方法可以将一个runnable对象包装在一个Message对象中, 然后再压入消息队列, 此时入队的Message其callback字段不为null, 值就是这个runnable对象. 调用<code>Handler</code>对象的这些方法入队的<code>Message</code>, 其target属性会被赋值为这个handler对象.
2. 调用<code>Message</code>对象的<code>sendToTarget()</code>方法可以将其本身压入与其target字段(即handler对象)所关联的消息队列中.</p>

<p>将未来得及处理的消息从消息队列中删除:调用Handler对象中以remove开头的方法就可以.</p>

<p>从消息队列中取出消息并处理消息: 所有在消息队列中的消息, 都具有target字段. 消息是在target所关联的线程上被取出和处理的.
1. 如果取出的<code>Message</code>对象的callback字段不为null, 那么就调用<code>callback</code>字段的<code>run()</code>方法(callback字段的类型是runnable). 注意此时并不开启一个新的线程运行run()方法, 而是直接在handler对象(即<code>Message</code>的target字段)所关联的线程上运行.
2. 如果取出的Message对象的callback字段为null, 且<code>Handler</code>对象中的callback字段也为null, 那么这个消息将由<code>Handler</code>对象的<code>handleMessage(msg)</code>方法处理. 注意Message对象的callback字段是Runnable类型的而Handler对象的callback字段是Callback类型的, Handler对象的callback字段是在创建Handler instance的时候指定的, 如果没有指定则这个字段为null, 详见Handler类的四个构造方法.
3. 如果取出的<code>Message</code>对象的callback字段为null, 且Handler对象中的callback字段不为null, 那么这个消息将由<code>Handler</code>对象中的callback字段的handleMessage方法处理.</p>

<p>线程间通信: 有了以上的叙述, 线程间的通信也就好理解了. 假如一个handler关联了A线程上的消息队列, 那么我们可以在B线程上调用handler的相关方法向A线程上的消息队列压入一个Message, 这个Message将在A线程上得到处理.</p>

<p>REF:<a href="http://mindtherobot.com/blog/159/android-guts-intro-to-loopers-and-handlers/">Android Guts: Intro to Loopers and Handlers</a></p>
]]></content>
  </entry>
  
</feed>
