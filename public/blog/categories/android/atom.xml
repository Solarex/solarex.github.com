<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: android | Solarex's Blog]]></title>
  <link href="http://Solarex.github.io/blog/categories/android/atom.xml" rel="self"/>
  <link href="http://Solarex.github.io/"/>
  <updated>2014-10-27T15:22:07+08:00</updated>
  <id>http://Solarex.github.io/</id>
  <author>
    <name><![CDATA[Solarex]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[Dealing with AsyncTask and Screen Orientation]]></title>
    <link href="http://Solarex.github.io/blog/2014/10/26/android-dealing-with-asynctask-and-screen-orientation/"/>
    <updated>2014-10-26T19:31:00+08:00</updated>
    <id>http://Solarex.github.io/blog/2014/10/26/android-dealing-with-asynctask-and-screen-orientation</id>
    <content type="html"><![CDATA[<p><center><img src="http://Solarex.github.io/images/android_logo.jpg"/></center></p>


<p>A common task in Android is to perform some background activity in another thread, meanwhile displaying a ProgressDialog to the user. Example of these tasks include downloading some data from internet, logging into an application, etc. Implementing an AsyncTask is fairly a simple job, the big challenge is how to handle it properly when an orientation change occurs.</p>

<!-- more -->


<p>In this article I will walk though a series of potential solutions to address the screen orientation issues when using an AsyncTask.</p>

<p>So, lets create a proof of concept application that makes use of an AsyncTask which does not handle configuration changes yet, and then present a few solutions.</p>

<p>Here’s the AsyncTask implementation that we will be using during the tutorial:</p>

<p><code>java
public class AsyncTaskExample extends AsyncTask&lt;String, Integer, String&gt; {
 
    private final TaskListener listener;
 
    public AsyncTaskExample(TaskListener listener) {
        this.listener = listener;
    }
 
    @Override
    protected void onPreExecute() {
        listener.onTaskStarted();
    }
 
    @Override
    protected String doInBackground(String... params) {
        for (int i = 1; i &lt;= 10; i++) {
            Log.d("GREC", "AsyncTask is working: " + i);
            try {
                Thread.sleep(1000);
            } catch (InterruptedException e) {
                e.printStackTrace();
            }
        }
        return "All Done!";
    }
 
    @Override
    protected void onPostExecute(String result) {
        listener.onTaskFinished(result);
    }
}
</code></p>

<ul>
<li><code>doInBackground()</code> – this will be called by the AsyncTask on a background thread, and performs all the heavy work. For the sake of this example, I just wrote a simple loop  with a delay of 1 sec between iterations to simulate a task that takes some time.</li>
<li>The constructor of the class takes a listener as a parameter. The listener will be used to delegate the work of <code>onPreExecute()/onPostExecute()</code> to the calling Activity.</li>
</ul>


<p>This is the interface definition used by AsyncTaskExample:</p>

<p><code>java
public interface TaskListener {
    void onTaskStarted();
 
    void onTaskFinished(String result);
}
</code></p>

<p>And here’s the usage of AsyncTaskExample (the problematic case):</p>

<p><code>java
public class MainActivity extends Activity implements TaskListener, OnClickListener {
 
    private ProgressDialog progressDialog;
 
    @Override
    public void onCreate(Bundle savedInstanceState) {
        super.onCreate(savedInstanceState);
        setContentView(R.layout.main);
        findViewById(R.id.start).setOnClickListener(this);
    }
 
    @Override
    public void onClick(View v) {
        if (v.getId() == R.id.start) {
            new AsyncTaskExample(this).execute();
        }
    }
 
    @Override
    public void onTaskStarted() {
        progressDialog = ProgressDialog.show(CopyOfMainActivity.this, "Loading", "Please wait a moment!");
    }
 
    @Override
    public void onTaskFinished(String result) {
        if (progressDialog != null) {
            progressDialog.dismiss();
        }
    }
}
</code></p>

<p>The Activity implements the TaskListener interface and provides appropriate implementation for its methods,  displaying the ProgressDialog when the task is started, and dismissing it when the task is finished. The AsyncTask is fired when clicking on a button.</p>

<p>Now, if you run this example without changing the screen orientation, the AsyncTask will start and finish its work normally. Problems begin to appear when the device orientation is changed while the AsyncTask is in the middle of the work. The application will crash, and an exception similar to these ones will be thrown: java.lang.IllegalArgumentException: View not attached to window manager, or Activity has leaked window com.android.internal.policy….</p>

<p>The cause relies in the Activity life cycle. A change in device orientation is interpreted as a configuration change which causes the current activity to be destroyed and then recreated. Android calls onPause(), onStop(), and onDestroy() on currently instance of activity, then a new instance of the same activity is recreated calling onCreate(), onStart(), and onResume(). The reason why Android have to do this, is because depending of screen orientation, portrait or landscape, we may need to load and display different resources, and only through re-creation Android can guarantee that all our resources will be re-requested.</p>

<p>But don’t panic, you are not alone, there are several solutions that will help us to deal with this situation.</p>

<h3>Solution 1 – Think twice if you really need an AsyncTask.</h3>

<p>AsyncTasks are good for performing background work, but they are bound to the Activity which adds some complexity. For things like making HTTP requests to a server perhaps you should consider an IntentService. IntentService used in conjunction with a BroadcastReceiver or ResultReceiver to deliver results, could do a better job than an AsyncTask in certain situations.</p>

<h3>Solution 2 – Put the AsyncTask in a Fragment.</h3>

<p>Using fragments probably is the cleanest way to handle configuration changes. By default, Android destroys and recreates the fragments just like activities, however, fragments have the ability to retain their instances, simply by calling: <code>setRetainInstance(true)</code>, in one of its callback methods, for example in the onCreate().</p>

<p>There’s however one aspect that should be taken in consideration in order to achieve the desired result. Our AsyncTask uses a ProgressDialog to signal when the AsyncTask is started, and dismisses it when the task is done. This complicates a bit the things because even if we are using <code>setRetainInstance(true)</code>, we should close all windows and dialogs when the Activity is destroyed, otherwise we will get an: <code>Activity has leaked window com.android.internal.policy…</code>  exception. This happens when you try to show a dialog after you have exited the Activity.</p>

<p>In order to address this issue, we will add some logic to keep track of AsyncTask status (running/not running). We will dismiss the ProgressDialog when the fragment is detached from activity, and check in <code>onActivityCreated()</code> the status of AsyncTask. If the status is “running”, this means we are returning from a screen orientation and we will just re-create and display the ProgressDialog to show that the AsyncTask is still working.</p>

<p><code>java
public class ExampleFragment extends Fragment implements TaskListener, OnClickListener {
 
    private ProgressDialog progressDialog;
    private boolean isTaskRunning = false;
    private AsyncTaskExample asyncTask;
 
    @Override
    public void onCreate(Bundle savedInstanceState) {
        super.onCreate(savedInstanceState);
        setRetainInstance(true);
    }
 
    @Override
    public void onActivityCreated(Bundle savedInstanceState) {
        super.onActivityCreated(savedInstanceState);
        // If we are returning here from a screen orientation
        // and the AsyncTask is still working, re-create and display the
        // progress dialog.
        if (isTaskRunning) {
            progressDialog = ProgressDialog.show(getActivity(), "Loading", "Please wait a moment!");
        }
    }
 
    @Override
    public View onCreateView(LayoutInflater inflater, ViewGroup container, Bundle savedInstanceState) {
        View view = inflater.inflate(R.layout.fragment_layout, container, false);
        Button button = (Button) view.findViewById(R.id.start);
        button.setOnClickListener(this);
        return view;
    }
 
    @Override
    public void onClick(View v) {
        if (!isTaskRunning) {
            asyncTask = new AsyncTaskExample(this);
            asyncTask.execute();
        }
    }
 
    @Override
    public void onTaskStarted() {
        isTaskRunning = true;
        progressDialog = ProgressDialog.show(getActivity(), "Loading", "Please wait a moment!");
    }
 
    @Override
    public void onTaskFinished(String result) {
        if (progressDialog != null) {
            progressDialog.dismiss();
        }
        isTaskRunning = false;
    }
 
    @Override
    public void onDetach() {
        // All dialogs should be closed before leaving the activity in order to avoid
        // the: Activity has leaked window com.android.internal.policy... exception
        if (progressDialog != null &amp;&amp; progressDialog.isShowing()) {
            progressDialog.dismiss();
        }
        super.onDetach();
    }
}
</code></p>

<h3>Solution 3 – Lock the screen orientation</h3>

<p>You could do this in 2 ways:</p>

<p>a) permanently locking the screen orientation of the activity, specifying the screenOrientation attribute in the AndroidManifest with “portrait” or “landscape” values:</p>

<p><code>xml
&lt;activity
   android:screenOrientation="portrait"
   ...  /&gt;
</code></p>

<p>b) or, temporarily locking the screen in <code>onPreExecute()</code>, and unlocking it in <code>onPostExecute()</code>, thus preventing any orientation change while the AsyncTask is working:</p>

<p><code>java
@Override
public void onTaskStarted() {
    lockScreenOrientation();
    progressDialog = ProgressDialog.show(CopyOfCopyOfMainActivity.this, "Loading", "Please wait a moment!");
}
 
@Override
public void onTaskFinished(String result) {
    if (progressDialog != null) {
        progressDialog.dismiss();
    }
    unlockScreenOrientation();
}
 
private void lockScreenOrientation() {
    int currentOrientation = getResources().getConfiguration().orientation;
    if (currentOrientation == Configuration.ORIENTATION_PORTRAIT) {
        setRequestedOrientation(ActivityInfo.SCREEN_ORIENTATION_PORTRAIT);
    } else {
        setRequestedOrientation(ActivityInfo.SCREEN_ORIENTATION_LANDSCAPE);
    }
}
 
private void unlockScreenOrientation() {
    setRequestedOrientation(ActivityInfo.SCREEN_ORIENTATION_SENSOR);
}
</code></p>

<h4>Solution 4 – Prevent the Activity from being recreated.</h4>

<p>This is the easiest way to handle configuration changes, but the less advised. The only thing you need to do is to specify the configChanges attribute followed by a list of values that specifies when the activity should prevent itself from restarting.</p>

<p><code>xml
&lt;activity
   android:configChanges="orientation|keyboardHidden"
   android:name=".MainActivity"
   .... /&gt;
</code></p>

<p>Using this approach however, is not recommended, and this is clearly stated in the Android documentation: Using this attribute should be avoided and used only as a last-resort.</p>

<p>You may ask what’s wrong with this approach. Well, if you build the above example against Android 2.2 it will work fine, but if you build it against Android 3.0 and higher, you may notice that the application still crashes on orientation change. This is because starting  with Android 3.0 you need also to handle the <code>screenSize</code>, and <code>smallestScreenSize</code>:</p>

<p><code>xml
&lt;activity
   android:configChanges="orientation|keyboardHidden|screenSize|smallestScreenSize"
   android:name=".MainActivity"
   .... /&gt;
</code></p>

<p>As it turns out, not only a screen orientation causes the Activity to recreate, there are also other events which may produce configuration changes and restart the Activity, and there’s a good chance that we won’t handle them all. This is why the use of this technique is discouraged.</p>

<p><embed src="http://player.youku.com/player.php/sid/XODExOTY3MzY0/v.swf" allowFullScreen="true" quality="high" width="480" height="400" align="middle" allowScriptAccess="always" type="application/x-shockwave-flash"></embed></p>

<p><embed src="http://player.youku.com/player.php/sid/XODExOTg2MTgw/v.swf" allowFullScreen="true" quality="high" width="480" height="400" align="middle" allowScriptAccess="always" type="application/x-shockwave-flash"></embed></p>

<p>REF:</p>

<ul>
<li><a href="http://androidresearch.wordpress.com/2013/05/10/dealing-with-asynctask-and-screen-orientation/">Dealing with AsyncTask and Screen Orientation</a></li>
</ul>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Android ContentProvider]]></title>
    <link href="http://Solarex.github.io/blog/2014/10/24/android-contentprovider/"/>
    <updated>2014-10-24T12:16:00+08:00</updated>
    <id>http://Solarex.github.io/blog/2014/10/24/android-contentprovider</id>
    <content type="html"><![CDATA[<center><p><img src="http://Solarex.github.io/images/android_logo.jpg"/></p></center>


<ul>
<li><a href="#overview">Android ContentProvider</a>

<ul>
<li><a href="#basics">Content Provider Basics</a></li>
<li><a href="#using">Using Content Providers</a></li>
<li><a href="#writing">Writing your own Content Provider</a></li>
<li><a href="#performance">Better Performance with ContentProviderOperation</a></li>
</ul>
</li>
</ul>


<h2 id="overview">Android ContentProvider</h2>


<p>This is a tutorial covering Android&rsquo;s ContentProvider.</p>

<!-- more -->




<h3 id="basics">ContentProvider Basics</h3>


<h4>What are content providers?</h4>

<p>Content providers are Android’s central mechanism that enables you to access data of other applications – mostly information stored in databases or flat files. As such content providers are one of Android’s central component types to support the modular approach common to Android. Without content providers accessing data of other apps would be a mess.</p>

<p>Content providers support the four basic operations, normally called CRUD-operations. CRUD is the acronym for <code>create</code>, <code>read</code>, <code>update</code> and <code>delete</code>. With content providers those objects simply represent data – most often a record (tuple) of a database – but they could also be a photo on your SD-card or a video on the web.Android provides some standard content providers to access contacts, media files, preferences and so on.</p>

<h4>Content URIs</h4>

<p>The most important concept to understand when dealing with content providers is the content URI. Whenever you want to access data from a content provider you have to specify a URI. URIs for content providers look like this:</p>

<p><code>bash
content://authority/optionalPath/optionalId
</code></p>

<p>They contain four parts: The scheme to use, an authority, an optional path and an optional id.</p>

<ul>
<li>The scheme for content providers is always “content”. The colon and double-slash “://” are a fixed part of the URI-RFC and separate the scheme from the authority.</li>
<li>The next part is the authority for the content provider. Authorities have to be unique for every content provider. Thus the naming conventions should follow the Java package name rules. That is you should use the reversed domain name of your organization plus a qualifier for each and every content provider you publish. The Android documentation recommends to use the fully qualified class name of your ContentProvider-subclass.</li>
<li>The third part, the optional path, is used to distinguish the kinds of data your content provider offers. The content provider for Android’s mediastore, for example, distinguishes between audio files, video files and images using different paths for each of these types of media. This way a content provider can support different types of data that are nevertheless related. For totally unrelated data though you should use different content providers – and thus different authorities.</li>
<li>The last element is the optional id, which – if present – must be numeric. The id is used whenever you want to access a single record (e.g. a specific video file).</li>
</ul>


<p>There are two types of URIs: <code>directory-based</code> and <code>id-based</code> URIs. If no id is specified a URI is automatically a directory-based URI.</p>

<ul>
<li>You use <code>directory-based</code> URIs to access multiple elements of the same type (e.g. all songs of a band). All CRUD-operations are possible with directory-based URIs.</li>
<li>You use <code>id-based</code> URIs if you want to access a specific element. You cannot create objects using an id-based URI – but reading, updating and deleting is possible.</li>
</ul>


<p>The path of content URIs can contain additional information to limit the scope. The <code>MediaStore</code> content provider for example distinguishes between audio and other types. In addition to this it offers URIs that limit its operations to albums only or others to genres only. Content providers normally have constants for the URIs they support.</p>

<h4>Content Types</h4>

<p>Besides URIs another important concept to understand is the use of content types. Content types also have a standardized format which was first defined in RFC 1049 and refined in RFC 2045.</p>

<p>A content type consist of a media type and a subtype divided by a slash. A typical example is “image/png”. The media type “image” describes the content as an image file which is further specified to be of the Portable Network Graphic variety by the subtype “png”.</p>

<p>As with URIs there is also a standard for content types in Android. Table below lists the only two media types that Android accepts for content providers. As you can see, those two media types match the two types of URIs mentioned above.</p>

<table>
<caption><center>The media types used for content providers</center></caption>
<tr>
<th>Type</th>
<th>Usage</th>
<th>Constant</th>
</tr>
<tr>
<td>vnd.android.cursor.item</td>
<td>Used for single records</td>
<td>ContentResolver.CURSOR_ITEM_BASE_TYPE</td>
</tr>
<tr>
<td>vnd.android.cursor.dir</td>
<td>Used for multiple records</td>
<td>ContentResolver.CURSOR_DIR_BASE_TYPE</td>
</tr>
</table>


<p>The subtype on the other hand is used for content provider specific details and should differ for all types your content provider supports. The naming convention for subtypes is vnd.yourcompanyname.contenttype. Most content providers support multiple subtypes. In the case of a media player for example you might have subtypes for genre, band, titles, musicians and so on.</p>

<h4>Which standard Content Providers are available?</h4>

<p>A number of content providers are part of Android’s API. All these standard providers are defined in the package <code>android.provider</code>. The following table lists the standard providers and what they are used for.</p>

<table>
<caption>The standard content providers of Android</caption>
<tr>
<th>Provider</th>
<th>Since&nbsp;&nbsp;&nbsp;&nbsp;</th>
<th>Usage</th>
</tr>
<tr>
<td>Browser</td>
<td>SDK 1</td>
<td>Manages your web-searches, bookmarks and browsing-history.</td>
</tr>
<tr>
<td>CalendarContract</td>
<td>SDK 14</td>
<td>Manages the calendars on the user&#8217;s device.</td>
</tr>
<tr>
<td>CallLog</td>
<td>SDK 1</td>
<td>Keeps track of your call history.</td>
</tr>
<tr>
<td>Contacts</td>
<td>SDK 1</td>
<td>The old and deprecated content provider for managing contacts. You should only use this provider if you need to support an SDK prior to SDK 5!</td>
</tr>
<tr>
<td>ContactsContract</td>
<td>SDK 5</td>
<td>Deals with all aspects of contact management. Supersedes the Contacts-content provider.</td>
</tr>
<tr>
<td>MediaStore</td>
<td>SDK 1</td>
<td>The content provider responsible for all your media files like music, video and pictures.</td>
</tr>
<tr>
<td>Settings</td>
<td>SDK 1</td>
<td>Manages all global settings of your device.</td>
</tr>
<tr>
<td>UserDictionary</td>
<td>SDK 3</td>
<td>Keeps track of words you add to the default dictionary.</td>
</tr>
</table>


<p>Please make use of the standard providers whenever you need data they provide. For example there are apps that ignore the UserDictionary (e.g. Swype). So the user might end up adding the same words in multiple apps – which is pretty annoying. Something like this will not help your rating in Android’s Market.</p>

<p>Of course you should always keep in mind that not all of the standard providers might be present on certain devices. E.g. a tablet might have no CallLog. Thus you should always test for availability. <strong>One way to do so is querying a content provider and checking if the returned cursor is null</strong>. That’s the return value when the provider doesn’t exist. The other CRUD-methods though throw an exception in case you pass in an unknown URI.</p>

<h3 id="using">Using ContentProviders</h3>


<h4>ContentResolver</h4>

<p>Whenever you want to use another content provider you first have to access a <code>ContentResolver</code> object. This object is responsible for finding the correct content provider.</p>

<p>The <code>ContentResolver</code> decides which provider to use based on the authority part of the URI. <strong>A content provider must provide its authority within the manifest file.</strong> From these entries Android creates a mapping between the authorities and the corresponding ContentProvider implementations to use.</p>

<p>You always interact with the <code>ContentResolver</code> and never with <code>ContentProvider</code> objects themselves. This supports loose coupling and also guarantees the correct lifecycle of the content provider.</p>

<p>You can get the <code>ContentResolver</code> object by calling <code>getContentResolver()</code> on the <code>Context</code> object. The <code>Context</code> object should always be available since the Activity and Service classes inherit from Context and the other components also provide easy access to it.</p>

<p>Since you only use the class <code>ContentResolver</code> it has to provide all necessary CRUD-methods. Any arguments provided to the methods of the <code>ContentResolver</code> are passed on to the respective methods of the <code>ContentProvider</code> subclass.</p>

<table>
<caption>The CRUD methods of the ContentResolver object</caption>
<tr>
<th>Method</th>
<th>Usage</th>
</tr>
<tr>
<td>delete</td>
<td>Deletes the object(s) for the URI provided. The URI can be item- or directory-based</td>
</tr>
<tr>
<td>insert</td>
<td>Inserts one object. The URI must be directory-based</td>
</tr>
<tr>
<td>query</td>
<td>Queries for all objects that fit the URI. The URI can be item- or directory-based</td>
</tr>
<tr>
<td>update</td>
<td>Updates one or all object(s). The URI can be item- or directory-based</td>
</tr>
</table>


<p>There are also two methods for applying multiple CRUD operations at once as shown in the next table.</p>

<table>
<caption>ContentResolver methods for dealing with multiple content provider operations</caption>
<tr>
<th>Method</th>
<th>Usage</th>
</tr>
<tr>
<td>applyBatch</td>
<td>Allows you to execute a list of <code>ContentProviderOperation</code> objects. Each <code>ContentProviderOperation</code> object can take its own URI and type of operation</td>
</tr>
<tr>
<td>bulkInsert</td>
<td>Allows you to insert an array of <code>ContentValues</code> for a directory-based URI. You can only specify one URI for all objects you want to add</td>
</tr>
</table>


<h4>Querying for data</h4>

<p>Querying data is probably the operation you will use most often. That’s true for your own providers but also for standard providers which offer some very valuable information.</p>

<table>
<caption>The arguments of the query method</caption>
<tr>
<th>Type</th>
<th>Name</th>
<th>Usage</th>
</tr>
<tr>
<td>URI</td>
<td>uri</td>
<td>The URI of the object(s) to access. This is the only argument that must not be null</td>
</tr>
<tr>
<td>String[]</td>
<td>projection</td>
<td>This String array indicates which columns/attributes of the objects you want to access</td>
</tr>
<tr>
<td>String</td>
<td>selection</td>
<td>With this argument you can determine which records to return</td>
</tr>
<tr>
<td>String[]</td>
<td>selectionArgs</td>
<td>The binding parameters to the previous selection argument</td>
</tr>
<tr>
<td>String</td>
<td>sortOrder</td>
<td>If the result should be ordered you must use this argument to determine the sort order</td>
</tr>
</table>


<p>The return value of the query method is a <code>Cursor</code> object. The cursor is used to navigate between the rows of the result and to read the columns of the current row. Cursors are important resources that have to be closed whenever you have no more use for them – otherwise you keep valuable resources from being released.</p>

<p>The following code snippet shows how to make use of this provider. I use the <code>CONTENT_URI</code> of <code>UserDictionary.Words</code> to access the dictionary. For this example I am only interested in the IDs of the words and the words itself.</p>

<p>```java
ContentResolver resolver = getContentResolver();
String[] projection = new String[]{BaseColumns._ID, UserDictionary.Words.WORD};
Cursor cursor =</p>

<pre><code>  resolver.query(UserDictionary.Words.CONTENT_URI, 
        projection, 
        null, 
        null, 
        null);
</code></pre>

<p>if (cursor.moveToFirst()) {
   do {</p>

<pre><code>  long id = cursor.getLong(0);
  String word = cursor.getString(1);
  // do something meaningful
</code></pre>

<p>   } while (cursor.moveToNext());
}
```</p>

<h4>Inserting new records</h4>

<p>Very often your app needs to insert data. For the built-in content providers of Android this could be because you want to add events to the Calendar provider, people to the Contacts provider, words to the UserDictionary provider and so on.</p>

<p>The correct content URI for inserts can only be a <code>directory-based</code> URI because only these represent a collection of related items.</p>

<p>The values to insert are specified using a <code>ContentValues</code> object.This object is not much more than a collection of key/value pairs. Of course, the keys of your ContentValues object must match columns/attributes of the objects you want to update – otherwise you will get an exception. For all columns of the new object for which no key/value-pair is provided the default value is used – which most often is null.</p>

<table>
<caption>The arguments of the insert method</caption>
<tr>
<th>Type</th>
<th>Name</th>
<th>Usage</th>
</tr>
<tr>
<td>URI</td>
<td>uri</td>
<td>The directory-based URI to which to add the object. This argument must not be null</td>
</tr>
<tr>
<td>ContentValues</td>
<td>values</td>
<td>The values for the object to add. This argument also must not be null</td>
</tr>
</table>


<p>The following code snippet shows you how to add data using a content provider:</p>

<p><code>java
ContentValues values = new ContentValues();
values.put(Words.WORD, "Beeblebrox");
resolver.insert(UserDictionary.Words.CONTENT_URI, values);
</code></p>

<p>If you want to add multiple records to the same URI you can use the <code>bulkInsert()</code> method. This method differs from the normal <code>insert()</code> method only in that it takes an array of <code>ContentValue</code> objects instead of just one <code>ContentValues</code> object. So for each record you want to add, there must be an entry within the <code>ContentValues</code> array. If you want to add to different URIs though – or if you want to mix insert, update and delete operations, you should use <code>applyBatch()</code>.</p>

<h4>Updating data</h4>

<p>To update records you basically provide the URI, a <code>ContentValues</code> object and optionally also a where-clause and arguments for this where-clause.</p>

<table>
<caption>The arguments of the update method</caption>
<tr>
<th>Type</th>
<th>Name</th>
<th>Usage</th>
</tr>
<tr>
<td>URI</td>
<td>uri</td>
<td>The URI of the object(s) to access. This argument must not be null</td>
</tr>
<tr>
<td>ContentValues</td>
<td>values</td>
<td>The values to substitute the current data with. This argument also must not be null</td>
</tr>
<tr>
<td>String</td>
<td>selection</td>
<td>With this argument you can determine which records to update</td>
</tr>
<tr>
<td>String[]</td>
<td>selectionArgs</td>
<td>The binding parameters to the previous selection argument</td>
</tr>
</table>


<p>In the next snippet I am going to change the word I’ve just added in the previous section.</p>

<p><code>java
values.clear();
values.put(Words.WORD, "Zaphod");
Uri uri = ContentUris.withAppendedId(Words.CONTENT_URI, id);
long noUpdated = resolver.update(uri, values, null, null);
</code></p>

<p>Here we use a ContentValues object again. The keys of your ContentValues object must of course match columns/attributes of the objects you want to update – otherwise you would get an exception. The update method changes only those columns for which keys are present in the ContentValues object.</p>

<p>Note the call to <code>ContentUris.withAppendedId()</code>. This is a helper method to create an <code>id-based</code> URI from a directory-based one. You use it all the time since content providers only provide constants for directory-based URIs. So whenever you want to access a specific object you should use this method.</p>

<p>Since I changed only one record, a URI with an appended ID is sufficient. But if you want to update multiple values, you should use the normal URI and a selection clause. You will see an example for the latter when I show you how to delete entries.</p>

<p>There is also the call to <code>values.clear()</code>. This resets the ContentValues object and thus recycles the object. This way you are reducing costly garbage collector operations.</p>

<h4>Deleting data</h4>

<p>The next snippet shows how to delete records. It finally deletes the word. In this code sample you can see how to use the selection and selectionArgs arguments. The array of the selectionArgs argument is used to substitute all question marks found in the selection argument.</p>

<p>```java
long noDeleted = resolver.delete</p>

<pre><code>  (Words.CONTENT_URI, 
  Words.WORD + " = ? ", 
  new String[]{"Zaphod"});
</code></pre>

<p>```</p>

<p>The delete method takes the same arguments as the update method with the exception being the values argument. Since the record is deleted anyway, substitute values are not needed.</p>

<table>
<caption>The arguments of the delete method</caption>
<tr>
<th>Type</th>
<th>Name</th>
<th>Usage</th>
</tr>
<tr>
<td>URI</td>
<td>uri</td>
<td>The URI of the object(s) to access. This is the only argument which must not be null</td>
</tr>
<tr>
<td>String</td>
<td>selection</td>
<td>With this argument you can determine which records to delete</td>
</tr>
<tr>
<td>String[]</td>
<td>selectionArgs</td>
<td>The binding parameters to the previous selection argument</td>
</tr>
</table>




<h3 id="writing">Writing your own ContentProvider</h3>


<p>Implementing a content provider involves always the following steps:</p>

<ul>
<li>Create a class that extends <code>ContentProvider</code></li>
<li>Create a contract class</li>
<li>Create the <code>UriMatcher</code> definition</li>
<li>Implement the <code>onCreate()</code> method</li>
<li>Implement the <code>getType()</code> method</li>
<li>Implement the CRUD methods</li>
<li>Add the content provider to your <code>AndroidManifest.xml</code></li>
</ul>


<h4>Create a class that extends ContentProvider</h4>

<p>You start by sub-classing ContentProvider. Since ContentProvider is an abstract class you have to implement the six abstract methods. These methods are explained in detail later on, for now simply use the stubs created by the IDE of your choice.</p>

<table>
<caption>The abstract methods you have to implement</caption>
<tr>
<th>Method</th>
<th>Usage</th>
</tr>
<tr>
<td>onCreate()</td>
<td>Prepares the content provider</td>
</tr>
<tr>
<td>getType(Uri)</td>
<td>Returns the MIME type for this URI</td>
</tr>
<tr>
<td>delete(Uri uri, String selection, String[] selectionArgs)</td>
<td>Deletes records</td>
</tr>
<tr>
<td>insert(Uri uri, ContentValues values)</td>
<td>Adds records</td>
</tr>
<tr>
<td>query(Uri uri, String[] projection, String selection, String[] selectionArgs, String sortOrder)</td>
<td>Return records based on selection criteria</td>
</tr>
<tr>
<td>update(Uri uri, ContentValues values, String selection, String[] selectionArgs)</td>
<td>Modifies data</td>
</tr>
</table>


<h4>Create a contract class</h4>

<p>Up to now your code is still missing most of the functionality. But before implementing the CRUD methods you should think about your role as a provider. Content providers by its very definition provide data to clients. Those clients need to know how to access your data. And you should treat your URIs and authority like an API. You basically enter into a contract with your client. And your public API should reflect this.</p>

<p>Thus the official Android documentation recommends to create a contract class. This class defines all publicly available elements, like the authority, the content URIs of your tables, the columns, the content types and also any intents your app offers in addition to your provider.</p>

<p>This class is your public API. What you define here is what clients can use. It’s also the abstraction you provide. You can do behind the scenes whatever you like. The client won’t notice. You can change the data structure without problems – if your contract class remains unchanged.</p>

<p>The downside is: You shouldn’t change the contract in any way that might break existing clients. It’s a contract after all :&ndash;)</p>

<p>If you really think you must get rid of something you provided earlier on, use analytics to find out when a deprecated feature isn’t used anymore.</p>

<p>So here is what a typical contract class looks like:</p>

<p>```java
public final class LentItemsContract {</p>

<pre><code>/**
 * The authority of the lentitems provider.
 */
public static final String AUTHORITY = 
      "de.openminds.samples.cpsample.lentitems";
/**
 * The content URI for the top-level 
 * lentitems authority.
 */
public static final Uri CONTENT_URI = 
      Uri.parse("content://" + AUTHORITY);

/**
 * Constants for the Items table 
 * of the lentitems provider.
 */
public static final class Items 
      implements CommonColumns { ... }

/**
 * Constants for the Photos table of the 
 * lentitems provider. For each item there 
 * is exactly one photo. You can 
 * safely call insert with the an already 
 * existing ITEMS_ID. You won't get constraint 
 * violations. The content provider takes care 
 * of this.&lt;br&gt; 
 * Note: The _ID of the new record in this case
 * differs from the _ID of the old record.
 */
public static final class Photos 
      implements BaseColumns { ... }

/**
 * Constants for a joined view of Items and 
 * Photos. The _id of this joined view is 
 * the _id of the Items table.
 */
public static final class ItemEntities 
      implements CommonColumns { ...}

/**
 * This interface defines common columns 
 * found in multiple tables.
 */
public static interface CommonColumns 
      extends BaseColumns { ... }
</code></pre>

<p>}
```</p>

<p>You can see the exported tables Photos, Items and ItemEntities which are separate inner classes of the contract class. There is also the authority of the provider and the root content URI. If your app also exports activities accessible via intents you should document those here as well. And you should document any permissions your provider uses.</p>

<p>One thing in the above snippet is noteworthy: The inner class ItemEntities represents a virtual table that doesn’t exist in the database. In this case I simply use joins in the query method but you could also use views within the database to back up virtual tables. Clients cannot join tables of content providers, thus you should consider offering plausible joins yourself.</p>

<p>The following snippet shows what to do within the inner classes of your contract class:</p>

<p>```java
/<em>*
 * Constants for the Items table
 * of the lentitems provider.
 </em>/
public static final class Items</p>

<pre><code>  implements CommonColumns {
/**
 * The content URI for this table. 
 */
public static final Uri CONTENT_URI =
      Uri.withAppendedPath(
            LentItemsContract.CONTENT_URI, 
            "items");
/**
 * The mime type of a directory of items.
 */
public static final String CONTENT_TYPE = 
      ContentResolver.CURSOR_DIR_BASE_TYPE + 
      "/vnd.de.openminds.lentitems_items";
/**
 * The mime type of a single item.
 */
public static final String CONTENT_ITEM_TYPE = 
      ContentResolver.CURSOR_ITEM_BASE_TYPE + 
      "/vnd.de.openminds.lentitems_items";
/**
 * A projection of all columns 
 * in the items table.
 */
public static final String[] PROJECTION_ALL =
      {_ID, NAME, BORROWER};
/**
 * The default sort order for 
 * queries containing NAME fields.
 */
public static final String SORT_ORDER_DEFAULT = 
      NAME + " ASC";
</code></pre>

<p>}
```</p>

<p>As you can see the inner classes are the place for any column definitions, the content URIs and the content types of the respective tables.</p>

<h4>Create the UriMatcher definitions</h4>

<p>To deal with multiple URIs Android provides the helper class UriMatcher. This class eases the parsing of URIs. In the next code sample you can see that you initialize the UriMatcher by adding a set of paths with correspondig int values. Whenever you ask if a URI matches, the UriMatcher returns the corresponding int value to indicate which one matches. It is common practise to use constants for these int values. The code sample shows how to add id based paths as well as dir based paths.</p>

<p>```java
// helper constants for use with the UriMatcher
private static final int ITEM_LIST = 1;
private static final int ITEM_ID = 2;
private static final int PHOTO_LIST = 5;
private static final int PHOTO_ID = 6;
private static final int ENTITY_LIST = 10;
private static final int ENTITY_ID = 11;
private static final UriMatcher URI_MATCHER;</p>

<p>// prepare the UriMatcher
static {</p>

<pre><code>URI_MATCHER = new UriMatcher(UriMatcher.NO_MATCH);
URI_MATCHER.addURI(LentItemsContract.AUTHORITY, 
      "items", 
      ITEM_LIST);
URI_MATCHER.addURI(LentItemsContract.AUTHORITY, 
      "items/#", 
      ITEM_ID);
URI_MATCHER.addURI(LentItemsContract.AUTHORITY, 
      "photos", 
      PHOTO_LIST);
URI_MATCHER.addURI(LentItemsContract.AUTHORITY, 
      "photos/#", 
      PHOTO_ID);
</code></pre>

<p>   URI_MATCHER.addURI(LentItemsContract.AUTHORITY,</p>

<pre><code>     "entities", 
     ENTITY_LIST);
</code></pre>

<p>   URI_MATCHER.addURI(LentItemsContract.AUTHORITY,</p>

<pre><code>     "entities/#", 
     ENTITY_ID);
</code></pre>

<p>}
```</p>

<p>You pass the authority, a path pattern and an int value to the addURI() method. Android returns the int value later on when you try to match patterns.</p>

<p>The patterns of the sample above are the most common patterns. But you are not limited to those. Android’s calendar content provider for examples offers search URIs to find certain instances of events. And the content provider for contacts also offers non standard URIs – for example to provide access to the contact photo. You can take a look at the source of CalendarProvider2 or ContactsProvider2 to see how to use those non-standard URIs with the UriMatcher.</p>

<h4>Implement the onCreate() method</h4>

<p>Back to the actual content provider class. First implement the onCreate() method.</p>

<p>The onCreate() method is a lifecycle method and runs on the UI thread. Thus you should avoid executing any long-lasting tasks in this method. Your content provider is usually created at the start of your app. And you want this to be as fast as possible. So even if your users do not get any “Application Not Responding” error messages, they won’t like anything that delays the perceived starting time of your app. Thus consider to do any long lasting stuff within the CRUD methods.</p>

<p>Normally content providers use a database as the underlying data store. In this case you would create a reference to your SQLiteOpenHelper in onCreate() – but you wouldn’t try to get hold of an SQLiteDatabase object. In the original version of this post, my recommendation has been to get a reference to the database in this method. Please, do not do this!</p>

<p>```java
public class LentItemsProvider extends ContentProvider {</p>

<pre><code>private LentItemsOpenHelper mHelper = null;
@Override
public boolean onCreate() {
    mHelper = new LentItemsOpenHelper(getContext());
    return true;
}
</code></pre>

<p>   //&hellip;
}
```</p>

<h4>Implement the getType() method</h4>

<p>Every content provider must return the content type for its supported URIs. The signature of the method takes a URI and returns a String. The next code sample shows the getType() method of the sample application.</p>

<p>```java
@Override
public String getType(Uri uri) {
   switch (URI_MATCHER.match(uri)) {
   case ITEM_LIST:</p>

<pre><code>  return Items.CONTENT_TYPE;
</code></pre>

<p>   case ITEM_ID:</p>

<pre><code>  return Items.CONTENT_ITEM_TYPE;
</code></pre>

<p>   case PHOTO_ID:</p>

<pre><code>  return Photos.CONTENT_PHOTO_TYPE;
</code></pre>

<p>   case PHOTO_LIST:</p>

<pre><code>  return Photos.CONTENT_TYPE;
</code></pre>

<p>   case ENTITY_ID:</p>

<pre><code>  return ItemEntities.CONTENT_ENTITY_TYPE;
</code></pre>

<p>   case ENTITY_LIST:</p>

<pre><code>  return ItemEntities.CONTENT_TYPE;
</code></pre>

<p>   default:</p>

<pre><code>  throw new IllegalArgumentException("Unsupported URI: " + uri);
</code></pre>

<p>   }
}
```</p>

<p>As you can see this method is pretty simple. You just have to return the appropriate content type – defined within your contract class – for the URI passed into this method.</p>

<h4>UriMatcher</h4>

<p>The previous code sample shows how to make use of the UriMatcher. The pattern is also repeated within each of the CRUD methods, so let’s digg into it.</p>

<p>When you initialize the UriMatcher you state for each URI which int value belongs to it. Now whenever you need to react diffently depending on the URI you use the UriMatcher. It’s match() method returns the int value used during initialization. And usually you use this within a switch statement. This switch statement has case branches for the constants used during initialization.</p>

<p>You can use a “#” as a placeholder for an arbitrary numeric value and a “*” as a placeholder for arbitrary text. All other parts must be exactly as passed to the addURI() method.</p>

<h4>Adding records using insert()</h4>

<p>As expected this method is used by your clients to insert records into your datastore. The method only makes sense for dir based URIs, thus you first have to check if the right kind of URI is passed to the insert() method. Only then can you actually insert the values into the datastore you use.</p>

<p>The content provider API is record-based – probably since most underlying datastores are record based databases anyway. This makes implementing the insert() method very easy, since it allows you to simply pass the ContentValues object on to the SQLiteDatabase’s insert() method.</p>

<p>```java
public Uri insert(Uri uri, ContentValues values) {
   if (URI_MATCHER.match(uri) != ITEM_LIST</p>

<pre><code>     &amp;&amp; URI_MATCHER.match(uri) != PHOTO_LIST) {
     throw new IllegalArgumentException(
           "Unsupported URI for insertion: " + uri);
</code></pre>

<p>   }
   SQLiteDatabase db = mHelper.getWritableDatabase();
   if (URI_MATCHER.match(uri) == ITEM_LIST) {</p>

<pre><code>  long id = 
        db.insert(
              DBSchema.TBL_ITEMS, 
              null, 
              values);
  return getUriForId(id, uri);
</code></pre>

<p>   } else {</p>

<pre><code>  // this insertWithOnConflict is a special case; 
  // CONFLICT_REPLACE means that an existing entry 
  // which violates the UNIQUE constraint on the 
  // item_id column gets deleted. In this case this 
  // INSERT behaves nearly like an UPDATE. Though 
  // the new row has a new primary key.
  // See how I mentioned this in the Contract class.
  long id = 
        db.insertWithOnConflict(
              DBSchema.TBL_PHOTOS, 
              null, 
              values, 
              SQLiteDatabase.CONFLICT_REPLACE);
  return getUriForId(id, uri);
</code></pre>

<p>   }
}</p>

<p>private Uri getUriForId(long id, Uri uri) {
   if (id > 0) {</p>

<pre><code>  Uri itemUri = ContentUris.withAppendedId(uri, id);
  if (!isInBatchMode()) {
     // notify all listeners of changes:
     getContext().
           getContentResolver().
                 notifyChange(itemUri, null);
  }
  return itemUri;
</code></pre>

<p>   }
   // s.th. went wrong:
   throw new SQLException(</p>

<pre><code>     "Problem while inserting into uri: " + uri);
</code></pre>

<p>}
```</p>

<h4>Notifying listeners of dataset changes</h4>

<p>Clients often want to be notified about changes in the underlying datastore of your content provider. So inserting data, as well as deleting or updating data should trigger this notification.</p>

<p>That’s why I used the following line in the code sample above:</p>

<p><code>java
getContext().getContentResolver().notifyChange(itemUri, null);
</code></p>

<p>Of course you should only call this method when there really has been a change – that’s why I test if the id is a positive number.</p>

<p>Alas, it is not possible to notify the client of the actual change that has occurred. You can only state which URI has changed. Most often this is enough – though sometimes a client would like to know if this was an addition of a record, a deletion of entries or an update. Sadly, Android offers us no possibility to help those clients</p>

<h4>Querying the content provider for records</h4>

<p>Returning records from your ContentProvider is pretty easy. Android has a helper class, you can use here: The SQLiteQueryBuilder. Within the query() method of a content provider you can use this class as shown below.</p>

<p>```java
@Override
public Cursor query(Uri uri, String[] projection,</p>

<pre><code>  String selection, String[] selectionArgs, 
  String sortOrder) {
</code></pre>

<p>   SQLiteDatabase db = mHelper.getReadableDatabase();
   SQLiteQueryBuilder builder = new SQLiteQueryBuilder();
   boolean useAuthorityUri = false;
   switch (URI_MATCHER.match(uri)) {
   case ITEM_LIST:</p>

<pre><code>  builder.setTables(DBSchema.TBL_ITEMS);
  if (TextUtils.isEmpty(sortOrder)) {
     sortOrder = Items.SORT_ORDER_DEFAULT;
  }
  break;
</code></pre>

<p>   case ITEM_ID:</p>

<pre><code>  builder.setTables(DBSchema.TBL_ITEMS);
  // limit query to one row at most:
  builder.appendWhere(Items._ID + " = " +
        uri.getLastPathSegment());
  break;
</code></pre>

<p>   case PHOTO_LIST:</p>

<pre><code>  builder.setTables(DBSchema.TBL_PHOTOS);
  break;
</code></pre>

<p>   case PHOTO_ID:</p>

<pre><code>  builder.setTables(DBSchema.TBL_PHOTOS);
  // limit query to one row at most:
  builder.appendWhere(Photos._ID + 
        " = " + 
        uri.getLastPathSegment());
  break;
</code></pre>

<p>   case ENTITY_LIST:</p>

<pre><code>  builder.setTables(DBSchema.LEFT_OUTER_JOIN_STATEMENT);
  if (TextUtils.isEmpty(sortOrder)) {
     sortOrder = ItemEntities.SORT_ORDER_DEFAULT;
  }
  useAuthorityUri = true;
  break;
</code></pre>

<p>   case ENTITY_ID:</p>

<pre><code>  builder.setTables(DBSchema.LEFT_OUTER_JOIN_STATEMENT);
  // limit query to one row at most:
  builder.appendWhere(DBSchema.TBL_ITEMS + 
        "." + 
        Items._ID + 
        " = " +
        uri.getLastPathSegment());
  useAuthorityUri = true;
  break;
</code></pre>

<p>   default:</p>

<pre><code>  throw new IllegalArgumentException(
        "Unsupported URI: " + uri);
</code></pre>

<p>   }
   Cursor cursor =</p>

<pre><code>     builder.query(
     db, 
     projection, 
     selection, 
     selectionArgs,
     null, 
     null, 
     sortOrder);
</code></pre>

<p>   // if we want to be notified of any changes:
   if (useAuthorityUri) {</p>

<pre><code>  cursor.setNotificationUri(
        getContext().getContentResolver(), 
        LentItemsContract.CONTENT_URI);
</code></pre>

<p>   }
   else {</p>

<pre><code>  cursor.setNotificationUri(
        getContext().getContentResolver(), 
        uri);
</code></pre>

<p>   }
   return cursor;
}
```</p>

<p>After creating a new object you first define into which table(s) to insert. Then you might want to add a default sort order if none is specified by the caller of your code. Next you have to add a WHERE clause that matches the id for id based queries before you finally pass all arguments on to the builder’s query() method. This method returns a Cursor object which you simply return to your caller.</p>

<p>There is one additional thing though you have to take care of. That is the SQLiteDatabase object you have to pass to the SQLiteQueryBuilder&rsquo;s query() method. I recommend to get access to the SQLiteDatabase object within each CRUD method.</p>

<p>Now you might wonder if I ever close the object. Well, I don’t :&ndash;) But this is no problem. SQLiteOpenHelper keeps just one SQLiteDatabase object per SQLiteSession. This makes accessing the object very efficient. With version checking and all that is happening in the background it wouldn’t work too well otherwise. I will delve into all these details in one of my upcoming posts within my SQLite series. So for now simply believe me: There is no leak here! If you use just one SQLiteOpenHelper object within your app you will only have at most one SQLiteDatabase object at any time – unless you pass this object needlessly around and leak it that way. Finally: Android destroys the content provider when it’s no longer needed and cleans up any ressources. Very convenient!</p>

<h4>Updating and deleting records of your content provider</h4>

<p>The code for updating and deleting records looks pretty much the same. I’m going to show you how to update records and afterwards I will briefly describe the necessary changes for deleting.</p>

<p>```java
@Override
public int update(Uri uri, ContentValues values, String selection,</p>

<pre><code>  String[] selectionArgs) {
</code></pre>

<p>   SQLiteDatabase db = mHelper.getWritableDatabase();
   int updateCount = 0;
   switch (URI_MATCHER.match(uri)) {
   case ITEM_LIST:</p>

<pre><code>  updateCount = db.update(
        DBSchema.TBL_ITEMS, 
        values, 
        selection,
        selectionArgs);
  break;
</code></pre>

<p>   case ITEM_ID:</p>

<pre><code>  String idStr = uri.getLastPathSegment();
  String where = Items._ID + " = " + idStr;
  if (!TextUtils.isEmpty(selection)) {
     where += " AND " + selection;
  }
  updateCount = db.update(
        DBSchema.TBL_ITEMS, 
        values, 
        where,
        selectionArgs);
  break;
</code></pre>

<p>   default:</p>

<pre><code>  // no support for updating photos or entities!
  throw new IllegalArgumentException("Unsupported URI: " + uri);
</code></pre>

<p>   }
   // notify all listeners of changes:
   if (updateCount > 0 &amp;&amp; !isInBatchMode()) {</p>

<pre><code>  getContext().getContentResolver().notifyChange(uri, null);
</code></pre>

<p>   }
   return updateCount;
}
```</p>

<p>First you once again use your UriMatcher to distinguish between dir based and id based URIs. If you use a dir based URI, you simply pass this call on to the SQLiteDatabase&rsquo;s update() method substituting the URI with the correct table name. In case of an id based URI you have to extract the id from the URI to form a valid WHERE clause. After this call SQLiteDatabase‘s update() method. Finally you return the number of modified records.</p>

<p>The only changes you have to make for your delete() method is to change the method names and to get rid of the ContentValues object. Everthing else is exactly as shown in the update() method’s code sample.</p>

<p>```java
@Override
public int delete(Uri uri, String selection, String[] selectionArgs) {
   SQLiteDatabase db = mHelper.getWritableDatabase();
   int delCount = 0;
   switch (URI_MATCHER.match(uri)) {
   case ITEM_LIST:</p>

<pre><code>  delCount = db.delete(
        DBSchema.TBL_ITEMS, 
        selection, 
        selectionArgs);
  break;
</code></pre>

<p>   case ITEM_ID:</p>

<pre><code>  String idStr = uri.getLastPathSegment();
  String where = Items._ID + " = " + idStr;
  if (!TextUtils.isEmpty(selection)) {
     where += " AND " + selection;
  }
  delCount = db.delete(
        DBSchema.TBL_ITEMS, 
        where, 
        selectionArgs);
  break;
</code></pre>

<p>   default:</p>

<pre><code>  // no support for deleting photos or entities -
  // photos are deleted by a trigger when the item is deleted
  throw new IllegalArgumentException("Unsupported URI: " + uri);
</code></pre>

<p>   }
   // notify all listeners of changes:
   if (delCount > 0 &amp;&amp; !isInBatchMode()) {</p>

<pre><code>  getContext().getContentResolver().notifyChange(uri, null);
</code></pre>

<p>   }
   return delCount;
}
```</p>

<p>Lifecycle</p>

<p>As with all components Android also manages the creation and destruction of a content provider. But a content provider has no visible state and there is also nothing the user has entered that should not be lost. Because of this Android can shut down the content provider whenever it sees fit.</p>

<p>So instead of the many methods you usually have to take care of in your activities or fragments, you have to implement just this one method: onCreate(). Keep this method as fast as possible. It runs on the UI thread when your app starts up. So it has to be fast otherwise the first impression with your app won’t be too impressive.</p>

<p>Normally that’s just it. But there are two other callback methods you might want to react to depending on circumstances:</p>

<ul>
<li>When your content provider needs to react to changed settings (e.g. the user selected language) you have to implement the onConfigurationChanged() method that takes a Configuration object as parameter.</li>
<li>When your content provider keeps large amounts of data around (which you should strive to avoid) you should also implement the onLowMemory() method to release these data.</li>
</ul>


<h4>Configuring your content provider</h4>

<p>As with any component in Android you also have to register your content provider within the AndroidManifest.xml file. The next code sample shows the configuration of the sample content provider.</p>

<p><code>xml
&lt;provider
   android:name=".provider.LentItemsProvider"
   android:authorities="de.openminds.samples.cpsample.lentitems"
   android:exported="true"
   android:grantUriPermissions="true"
   android:label="LentItemsProvider"
   android:readPermission="de.openminds.samples.cpsample.lentitems.READ"
   android:writePermission="de.openminds.samples.cpsample.lentitems.WRITE" /&gt;
</code></p>

<p>You use a <provider> element for each content provider you want to register. Of its many attributes you usually will use authorities, name and possibly one of the permission attributes.</p>

<p>The name attribute simply is the fully qualified class name of your ContentProvider subclass. As always it is possible to use a simple “.” for the default-package of your application.</p>

<p>I have explained the rules for authorities in detail in the post about content provider clients. It should be akin to Java’s package naming conventions and must be unique among all content providers on any device it is going to be installed on. So don’t be sloppy with the provider’s authority.</p>

<h4>Think about necessary permissions</h4>

<p>As you have seen above, you can – and probably should – add restrictions to your content provider. By using one of the permission attributes you force clients to be open to their users about the use of your content provider’s data.</p>

<p>If you do not export your content provider this is no issue for you. But if you do, think carefully about what you want clients to be able to do and how to set permissions accordingly.</p>

<h4>When to use content providers</h4>

<p>As described in the introductory post, one reason to use content providers, is to export data. So, should you use content providers only to provide data to external applications? Or when would it be appropriate to prefer them for your own application over directly accessing the database?</p>

<p>I recommend to use a content provider whenever your app needs to react to changes in the underlying data store – even to changes from within your app itself. And this of course is more often true than not. You might for example have a ListView which displays summary information of the data held in your data store. Now if you delete or add an entry and return to your list the list should reflect these changes. This is easily done using a content provider in combination with using Loaders. Using the database directly you would have to trigger a new query on your own.</p>

<p>You must use content providers if you want to use search suggestions. In that case Android leaves you no choice.</p>

<p>Android also demands that you use content providers with sync adapters. But contrary to search suggestions you can work around this requirement with a stub provider. But, well, I like content providers, so I recommend to use a proper one with sync adapters.</p>

<h3 id="performance">Better Performance with ContentProviderOperation</h3>


<p>ContentProviders are one of Android’s core building blocks. They represent a relational interface to data – either in databases or (cached) data from the cloud.</p>

<p>Sometimes you want to use them for multiple operations in a row. Like updating different sources and so on. In those cases you could call the respective ContentResolver methods multiple times or you could execute a batch of operations. The latter is the recommended practise.</p>

<p>To create, delete or update a set of data in a batch like fashion you should use the class ContentProviderOperation.</p>

<p>According to Android’s documentation it is recommended to use ContentProviderOperations for multiple reasons:</p>

<ul>
<li>All operations execute within the same transaction – thus data integrity is assured</li>
<li>This helps improve performance since starting, running and closing one transaction offers far better performance than opening and committing multiple transactions</li>
<li>Finally using one batch operation instead of multiple isolated operations reduces the number of context switches between your app and the content provider you are using. This of course also helps to improve the performance of your app – and by using less cpu cycles also reduces the power consumption.</li>
<li>To create an object of <code>ContentProviderOperation</code> you need to build it using the inner class <code>ContentProviderOperation.Builder</code>. You obtain an object of the Builder class by calling one of the three static methods newInsert, newUpdate or newDelete:</li>
</ul>


<table>
<caption>Methods to obtain a Builder object</caption>
<tr>
<th>Method</th>
<th>Usage</th>
</tr>
<tr>
<td>newInsert</td>
<td>Create a Builder object suitable for an insert operation</td>
</tr>
<tr>
<td>newUpdate</td>
<td>Create a Builder object suitable for an update operation</td>
</tr>
<tr>
<td>newDelete</td>
<td>Create a Builder object suitable for a delete operation</td>
</tr>
</table>


<p>The Builder is an example of the Gang of Four Builder pattern. A Builder defines an interface for how to create objects. Concrete instances then create specific objects for the task at hand. In this case we have three different Builders for creating ContentProviderOperation objects. These objects can be used to create, update or delete ContentProvider data sets.</p>

<p>Typically all steps necessary to create a ContentProviderOperation object are done in one round of method chaining. That’s possible because all methods of the Builder class return a Builder object themself. The one exception is the build() method, which instead returns the desired object: Our completely created ContentProviderOperation object. So a typical chain might look like this:</p>

<p>```java
ArrayList<ContentProviderOperation> ops =
   new ArrayList<ContentProviderOperation>();
ops.add(
   ContentProviderOperation.newInsert(RawContacts.CONTENT_URI)</p>

<pre><code>   .withValue(RawContacts.ACCOUNT_TYPE, "someAccountType")
   .withValue(RawContacts.ACCOUNT_NAME, "someAccountName")
   .withYieldAllowed(true)
   .build());
</code></pre>

<p>```</p>

<p>Of course you could also use a ContentValues object as usual and use the withValues(values) method instead.</p>

<p>The Builder class has among others these methods you can use to define which objects to delete or how to create or update an object:</p>

<table>
<caption>Some important methods of the Builder object</caption>
<tr>
<th>Method</th>
<th>Usage</th>
</tr>
<tr>
<td>withSelection (String selection, String[] selectionArgs)</td>
<td>Specifies on which subset of the existing data set to operate. Only usable with ContentProviderOperation objects used to update or delete data</td>
</tr>
<tr>
<td>withValue (String key, Object value)</td>
<td>Defines the desired value for one column. Only usable with ContentProviderOperation objects used to create or update data</td>
</tr>
<tr>
<td>withValues (ContentValues values)</td>
<td>Defines the desired values for multiple columns. Only usable with ContentProviderOperation objects used to create or update data</td>
</tr>
</table>


<p>As you can see in the code sample I presented above you need an ArrayList of ContentProviderOperation objects. For every ContentProvider-CRUD method you have to use one ContentProviderOperation object and add it to this list. I will explain in a later blog post about the method withValueBackReference() why it has to be an ArrayList and not say a LinkedList.</p>

<p>The list is finally passed to the applyBatch() method of the ContentResolver object:</p>

<p>```java
try {
   getContentResolver().</p>

<pre><code>  applyBatch(ContactsContract.AUTHORITY, ops);
</code></pre>

<p>} catch (RemoteException e) {
   // do s.th.
} catch (OperationApplicationException e) {
   // do s.th.
}
```</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Android Loader]]></title>
    <link href="http://Solarex.github.io/blog/2014/10/24/android-loader/"/>
    <updated>2014-10-24T06:34:00+08:00</updated>
    <id>http://Solarex.github.io/blog/2014/10/24/android-loader</id>
    <content type="html"><![CDATA[<p><center><img src="http://Solarex.github.io/images/android_logo.jpg"/></center></p>


<ul>
<li><a href="#overview">Android Loader</a>

<ul>
<li><a href="#before">Life before Loaders</a></li>
<li><a href="#loadermanager">Understanding the LoaderManager</a></li>
<li><a href="#implementing">Implementing Loaders</a></li>
</ul>
</li>
</ul>


<h2 id="overview">Android Loader</h2>


<p>This post gives a brief introduction to Loaders and the LoaderManager. The first section describes how data was loaded prior to the release of Android 3.0, pointing out out some of the flaws of the pre-Honeycomb APIs. The second section defines the purpose of each class and summarizes their powerful ability in asynchronously loading data.</p>

<!-- more -->




<h3 id="before">Life before Loaders</h3>


<p>Before Android 3.0, many Android applications lacked in responsiveness. UI interactions glitched, transitions between activities lagged, and ANR (Application Not Responding) dialogs rendered apps totally useless. This lack of responsiveness stemmed mostly from the fact that developers were performing queries on the UI thread—a very poor choice for lengthy operations like loading data.</p>

<p>While the <a href="http://developer.android.com/guide/practices/responsiveness.html">documentation</a> has always stressed the importance of instant feedback, the pre-Honeycomb APIs simply did not encourage this behavior. Before Loaders, cursors were primarily managed and queried for with two (now deprecated) Activity methods:</p>

<ul>
<li><p><code>public void startManagingCursor(Cursor)</code>:Tells the activity to take care of managing the cursor&rsquo;s lifecycle based on the activity&rsquo;s lifecycle. The cursor will automatically be deactivated (<code>deactivate()</code>) when the activity is stopped, and will automatically be closed (<code>close()</code>) when the activity is destroyed. When the activity is stopped and then later restarted, the Cursor is re-queried (<code>requery()</code>) for the most up-to-date data.</p></li>
<li><p><code>public Cursor managedQuery(Uri, String, String, String, String)</code>:A wrapper around the <code>ContentResolver's query()</code> method. In addition to performing the query, it begins management of the cursor (that is, <code>startManagingCursor(cursor)</code> is called before it is returned).</p></li>
</ul>


<p>While convenient, these methods were deeply flawed in that they performed queries on the UI thread. What&rsquo;s more, the &ldquo;managed cursors&rdquo; did not retain their data across Activity configuration changes. The need to <code>requery()</code> the cursor&rsquo;s data in these situations was unnecessary, inefficient, and made orientation changes clunky and sluggish as a result.</p>

<h4>The Problem with &ldquo;Managed Cursors&rdquo;</h4>

<p>Let&rsquo;s illustrate the problem with &ldquo;managed cursors&rdquo; through a simple code sample. Given below is a ListActivity that loads data using the pre-Honeycomb APIs. The activity makes a query to the ContentProvider and begins management of the returned cursor. The results are then bound to a SimpleCursorAdapter, and are displayed on the screen in a ListView. The code has been condensed for simplicity.</p>

<p>```java
public class SampleListActivity extends ListActivity {</p>

<p>  private static final String[] PROJECTION = new String[] {&ldquo;_id&rdquo;, &ldquo;text_column&rdquo;};</p>

<p>  @Override
  protected void onCreate(Bundle savedInstanceState) {</p>

<pre><code>super.onCreate(savedInstanceState);

// Performs a "managed query" to the ContentProvider. The Activity 
// will handle closing and requerying the cursor.
//
// WARNING!! This query (and any subsequent re-queries) will be
// performed on the UI Thread!!
Cursor cursor = managedQuery(
    CONTENT_URI,  // The Uri constant in your ContentProvider class
    PROJECTION,   // The columns to return for each data row
    null,         // No where clause
    null,         // No where clause
    null);        // No sort order

String[] dataColumns = { "text_column" };
int[] viewIDs = { R.id.text_view };

// Create the backing adapter for the ListView.
//
// WARNING!! While not readily obvious, using this constructor will 
// tell the CursorAdapter to register a ContentObserver that will
// monitor the underlying data source. As part of the monitoring
// process, the ContentObserver will call requery() on the cursor 
// each time the data is updated. Since Cursor#requery() is performed 
// on the UI thread, this constructor should be avoided at all costs!
SimpleCursorAdapter adapter = new SimpleCursorAdapter(
    this,                // The Activity context
    R.layout.list_item,  // Points to the XML for a list item
    cursor,              // Cursor that contains the data to display
    dataColumns,         // Bind the data in column "text_column"...
    viewIDs);            // ...to the TextView with id "R.id.text_view"

// Sets the ListView's adapter to be the cursor adapter that was 
// just created.
setListAdapter(adapter);
</code></pre>

<p>  }
}
```</p>

<p>There are three problems with the code above. If you have understood this post so far, the first two shouldn&rsquo;t be difficult to spot:</p>

<ul>
<li>managedQuery performs a query on the main UI thread. This leads to unresponsive apps and should no longer be used.</li>
<li>As seen in the <a href="http://grepcode.com/file/repository.grepcode.com/java/ext/com.google.android/android/1.5_r4/android/app/Activity.java#Activity.managedQuery%28android.net.Uri%2Cjava.lang.String%5B%5D%2Cjava.lang.String%2Cjava.lang.String%29">Activity.java</a>, the call to <code>managedQuery</code> begins management of the returned cursor with a call to <code>startManagingCursor(cursor)</code>. Having the activity manage the cursor seems convenient at first, as we no longer need to worry about deactivating/closing the cursor ourselves. However, this signals the activity to call <code>requery()</code> on the cursor each time the activity returns from a stopped state, and therefore puts the UI thread at risk. This cost significantly outweighs the convenience of having the activity deactivate/close the cursor for us.</li>
<li>The <code>SimpleCursorAdapter</code> constructor (line 32) is deprecated and should not be used. The problem with this constructor is that it will have the <code>SimpleCursorAdapter</code> auto-requery its data when changes are made. More specifically, the <code>CursorAdapter</code> will register a <code>ContentObserver</code> that monitors the underlying data source for changes, calling <code>requery()</code> on its bound cursor each time the data is modified. The standard constructor should be used instead (if you intend on loading the adapter&rsquo;s data with a CursorLoader, make sure you pass 0 as the last argument). Don&rsquo;t worry if you couldn&rsquo;t spot this one&hellip; it&rsquo;s a very subtle bug.</li>
</ul>


<p>With the first Android tablet about to be released, something had to be done to encourage UI-friendly development. The larger, 7-10" Honeycomb tablets called for more complicated, interactive, multi-paned layouts. Further, the introduction of the Fragment meant that applications were about to become more dynamic and event-driven. A simple, single-threaded approach to loading data could no longer be encouraged. Thus, the Loader and the LoaderManager were born.</p>

<p>Prior to Honeycomb, it was difficult to manage cursors, synchronize correctly with the UI thread, and ensure all queries occurred on a background thread. Android 3.0 introduced the Loader and LoaderManager classes to help simplify the process. Both classes are available for use in the Android Support Library, which supports all Android platforms back to Android 1.6.</p>

<p>The new Loader API is a huge step forward, and significantly improves the user experience. Loaders ensure that all cursor operations are done asynchronously, thus eliminating the possibility of blocking the UI thread. Further, when managed by the LoaderManager, Loaders retain their existing cursor data across the activity instance (for example, when it is restarted due to a configuration change), thus saving the cursor from unnecessary, potentially expensive re-queries. As an added bonus, Loaders are intelligent enough to monitor the underlying data source for updates, re-querying automatically when the data is changed.</p>

<p>Since the introduction of Loaders in Honeycomb and Compatibility Library, Android applications have changed for the better. Making use of the now deprecated startManagingCursor and managedQuery methods are extremely discouraged; not only do they slow down your app, but they can potentially bring it to a screeching halt. Loaders, on the other hand, significantly speed up the user experience by offloading the work to a separate background thread.</p>

<h3 id="loadermanager">Understanding the LoaderManager</h3>


<p>For now, you should think of Loaders as simple, self-contained objects that (1) load data on a separate thread, and (2) monitor the underlying data source for updates, re-querying when changes are detected. This is more than enough to get you through the contents of this post.</p>

<h4>What is the LoaderManager?</h4>

<p>Simply stated, the <code>LoaderManager</code> is responsible for managing one or more Loaders associated with an <code>Activity</code> or <code>Fragment</code>. Each Activity and each Fragment has exactly one LoaderManager instance that is in charge of starting, stopping, retaining, restarting, and destroying its Loaders. These events are sometimes initiated directly by the client, by calling <code>initLoader()</code>, <code>restartLoader()</code>, or <code>destroyLoader()</code>. Just as often, however, these events are triggered by major Activity/Fragment lifecycle events. For example, when an Activity is destroyed, the Activity instructs its LoaderManager to destroy and close its Loaders (as well as any resources associated with them, such as a Cursor).</p>

<p>The <code>LoaderManager</code> does not know how data is loaded, nor does it need to. Rather, the <code>LoaderManager</code> instructs its <code>Loaders</code> when to start/stop/reset their load, retaining their state across configuration changes and providing a simple interface for delivering results back to the client. In this way, the <code>LoaderManager</code> is a much more intelligent and generic implementation of the now-deprecated <code>startManagingCursor</code> method. While both manage data across the twists and turns of the Activity lifecycle, the <code>LoaderManager</code> is far superior for several reasons:</p>

<ul>
<li><p><code>startManagingCursor</code> manages Cursors, whereas the <code>LoaderManager</code> manages <code>Loader&lt;D&gt;</code> objects. The advantage here is that <code>Loader&lt;D&gt;</code> is generic, where D is the container object that holds the loaded data. In other words, the data source doesn&rsquo;t have to be a <code>Cursor</code>; it could be a <code>List</code>, a <code>JSONArray</code>&hellip; anything. The <code>LoaderManager</code> is independent of the container object that holds the data and is much more flexible as a result.</p></li>
<li><p>Calling <code>startManagingCursor</code> will make the <code>Activity</code> call <code>requery()</code> on the managed cursor. As mentioned in the previous post, <code>requery()</code> is a potentially expensive operation that is performed on the main UI thread. Subclasses of the <code>Loader&lt;D&gt;</code> class, on the other hand, are expected to load their data asynchronously, so using the <code>LoaderManager</code> will never block the UI thread.</p></li>
<li><p><code>startManagingCursor</code> does not retain the Cursor&rsquo;s state across configuration changes. Instead, each time the Activity is destroyed due to a configuration change (a simple orientation change, for example), the <code>Cursor</code> is destroyed and must be requeried. The <code>LoaderManager</code> is much more intelligent in that it retains its Loaders' state across configuration changes, and thus doesn&rsquo;t need to requery its data.</p></li>
<li><p>The <code>LoaderManager</code> provides seamless monitoring of data! Whenever the Loader&rsquo;s data source is modified, the <code>LoaderManager</code> will receive a new asynchronous load from the corresponding Loader, and will return the updated data to the client. (Note: the LoaderManager will only be notified of these changes if the Loader is implemented correctly. ).</p></li>
</ul>


<p>If you feel overwhelmed by the details above, I wouldn&rsquo;t stress over it. The most important thing to take away from this is that the <code>LoaderManager</code> makes your life easy. It initializes, manages, and destroys Loaders for you, reducing both coding complexity and subtle lifecycle-related bugs in your Activitys and Fragments. Further, interacting with the <code>LoaderManager</code> involves implementing three simple callback methods. We discuss the <code>LoaderManager.LoaderCallbacks&lt;D&gt;</code> in the next section.</p>

<h4>Implementing the LoaderManager.LoaderCallbacks<D> Interface</h4>

<p>The <code>LoaderManager.LoaderCallbacks&lt;D&gt;</code> interface is a simple contract that the <code>LoaderManager</code> uses to report data back to the client. Each <code>Loader</code> gets its own callback object that the <code>LoaderManager</code> will interact with. This callback object fills in the gaps of the abstract <code>LoaderManager</code> implementation, telling it how to instantiate the <code>Loader (onCreateLoader)</code> and providing instructions when its load is complete/reset (<code>onLoadFinished</code> and <code>onLoadReset</code>, respectively). Most often you will implement the callbacks as part of the component itself, by having your Activity or Fragment implement the <code>LoaderManager.LoaderCallbacks&lt;D&gt;</code> interface:</p>

<p>```java
public class SampleActivity extends Activity implements LoaderManager.LoaderCallbacks<D> {</p>

<p>  public Loader<D> onCreateLoader(int id, Bundle args) { &hellip; }</p>

<p>  public void onLoadFinished(Loader<D> loader, D data) { &hellip; }</p>

<p>  public void onLoaderReset(Loader<D> loader) { &hellip; }</p>

<p>  /<em> &hellip; </em>/
}
```</p>

<p>Once instantiated, the client passes the callbacks object (&ldquo;this&rdquo;, in this case) as the third argument to the <code>LoaderManager</code>&rsquo;s <code>initLoader</code> method, and will be bound to the <code>Loader</code> as soon as it is created.</p>

<p>Overall, implementing the callbacks is straightforward. Each callback method serves a specific purpose that makes interacting with the <code>LoaderManager</code> easy:</p>

<ul>
<li><p><code>onCreateLoader</code> is a factory method that simply returns a new <code>Loader</code>. The <code>LoaderManager</code> will call this method when it first creates the <code>Loader</code>.</p></li>
<li><p><code>onLoadFinished</code> is called automatically when a <code>Loader</code> has finished its load. This method is typically where the client will update the application&rsquo;s UI with the loaded data. The client may (and should) assume that new data will be returned to this method each time new data is made available. Remember that it is the Loader&rsquo;s job to monitor the data source and to perform the actual asynchronous loads. The <code>LoaderManager</code> will receive these loads once they have completed, and then pass the result to the callback object&rsquo;s <code>onLoadFinished</code> method for the client (i.e. the Activity/Fragment) to use.</p></li>
<li><p>Lastly, <code>onLoadReset</code> is called when the Loader&rsquo;s data is about to be reset. This method gives you the opportunity to remove any references to old data that may no longer be available.</p></li>
</ul>


<h4>Transitioning from Managed Cursors to the LoaderManager</h4>

<p>The code below is similar in behavior to the sample in my previous section. The difference, of course, is that it has been updated to use the <code>LoaderManager</code>. The <code>CursorLoader</code> ensures that all queries are performed asynchronously, thus guaranteeing that we won&rsquo;t block the UI thread. Further, the <code>LoaderManager</code> manages the <code>CursorLoader</code> across the <code>Activity</code> lifecycle, retaining its data on configuration changes and directing each new data load to the callback&rsquo;s <code>onLoadFinished</code> method, where the Activity is finally free to make use of the queried <code>Cursor</code>.</p>

<p>```java
public class SampleListActivity extends ListActivity implements</p>

<pre><code>LoaderManager.LoaderCallbacks&lt;Cursor&gt; {
</code></pre>

<p>  private static final String[] PROJECTION = new String[] { &ldquo;_id&rdquo;, &ldquo;text_column&rdquo; };</p>

<p>  // The loader&rsquo;s unique id. Loader ids are specific to the Activity or
  // Fragment in which they reside.
  private static final int LOADER_ID = 1;</p>

<p>  // The callbacks through which we will interact with the LoaderManager.
  private LoaderManager.LoaderCallbacks<Cursor> mCallbacks;</p>

<p>  // The adapter that binds our data to the ListView
  private SimpleCursorAdapter mAdapter;</p>

<p>  @Override
  public void onCreate(Bundle savedInstanceState) {</p>

<pre><code>super.onCreate(savedInstanceState);

String[] dataColumns = { "text_column" };
int[] viewIDs = { R.id.text_view };

// Initialize the adapter. Note that we pass a 'null' Cursor as the
// third argument. We will pass the adapter a Cursor only when the
// data has finished loading for the first time (i.e. when the
// LoaderManager delivers the data to onLoadFinished). Also note
// that we have passed the '0' flag as the last argument. This
// prevents the adapter from registering a ContentObserver for the
// Cursor (the CursorLoader will do this for us!).
mAdapter = new SimpleCursorAdapter(this, R.layout.list_item,
    null, dataColumns, viewIDs, 0);

// Associate the (now empty) adapter with the ListView.
setListAdapter(mAdapter);

// The Activity (which implements the LoaderCallbacks&lt;Cursor&gt;
// interface) is the callbacks object through which we will interact
// with the LoaderManager. The LoaderManager uses this object to
// instantiate the Loader and to notify the client when data is made
// available/unavailable.
mCallbacks = this;

// Initialize the Loader with id '1' and callbacks 'mCallbacks'.
// If the loader doesn't already exist, one is created. Otherwise,
// the already created Loader is reused. In either case, the
// LoaderManager will manage the Loader across the Activity/Fragment
// lifecycle, will receive any new loads once they have completed,
// and will report this new data back to the 'mCallbacks' object.
LoaderManager lm = getLoaderManager();
lm.initLoader(LOADER_ID, null, mCallbacks);
</code></pre>

<p>  }</p>

<p>  @Override
  public Loader<Cursor> onCreateLoader(int id, Bundle args) {</p>

<pre><code>// Create a new CursorLoader with the following query parameters.
return new CursorLoader(SampleListActivity.this, CONTENT_URI,
    PROJECTION, null, null, null);
</code></pre>

<p>  }</p>

<p>  @Override
  public void onLoadFinished(Loader<Cursor> loader, Cursor cursor) {</p>

<pre><code>// A switch-case is useful when dealing with multiple Loaders/IDs
switch (loader.getId()) {
  case LOADER_ID:
    // The asynchronous load is complete and the data
    // is now available for use. Only now can we associate
    // the queried Cursor with the SimpleCursorAdapter.
    mAdapter.swapCursor(cursor);
    break;
}
// The listview now displays the queried data.
</code></pre>

<p>  }</p>

<p>  @Override
  public void onLoaderReset(Loader<Cursor> loader) {</p>

<pre><code>// For whatever reason, the Loader's data is now unavailable.
// Remove any references to the old data by replacing it with
// a null Cursor.
mAdapter.swapCursor(null);
</code></pre>

<p>  }
}
```</p>

<p>As its name suggests, the <code>LoaderManager</code> is responsible for managing Loaders across the Activity/Fragment lifecycle. The <code>LoaderManager</code> is simple and its implementation usually requires very little code.</p>

<h3 id="implementing">Implementing Loaders</h3>


<p>This section introduces the <code>Loader&lt;D&gt;</code> class as well as custom <code>Loader</code> implementations.</p>

<h4>Loader Basics</h4>

<p><code>Loaders</code> are responsible for performing queries on a separate thread, monitoring the data source for changes, and delivering new results to a registered listener (usually the <code>LoaderManager</code>) when changes are detected. These characteristics make <code>Loaders</code> a powerful addition to the Android SDK for several reasons:</p>

<ul>
<li><p>They encapsulate the actual loading of data. The <code>Activity/Fragment</code> no longer needs to know how to load data. Instead, the <code>Activity/Fragment</code> delegates the task to the <code>Loader</code>, which carries out the request behind the scenes and has its results delivered back to the <code>Activity/Fragment</code>.</p></li>
<li><p>They abstract out the idea of threads from the client. The Activity/Fragment does not need to worry about offloading queries to a separate thread, as the <code>Loader</code> will do this automatically. This reduces code complexity and eliminates potential thread-related bugs.</p></li>
<li><p>They are entirely event-driven. <code>Loaders</code> monitor the underlying data source and automatically perform new loads for up-to-date results when changes are detected. This makes working with Loaders easy, as the client can simply trust that the Loader will auto-update its data on its own. All the Activity/Fragment has to do is initialize the <code>Loader</code> and respond to any results that might be delivered. Everything in between is done by the Loader.</p></li>
</ul>


<p>Loaders are a somewhat advanced topic and may take some time getting used to. We begin by analyzing its four defining characteristics in the next section.</p>

<h4>What Makes Up a Loader?</h4>

<p>There are four characteristics which ultimately determine a Loader’s behavior:</p>

<ul>
<li><p>A task to perform the asynchronous load. To ensure that loads are done on a separate thread, subclasses should extend <code>AsyncTaskLoader&lt;D&gt;</code> as opposed to the <code>Loader&lt;D&gt;</code> class. <code>AsyncTaskLoader&lt;D&gt;</code> is an abstract Loader which provides an <code>AsyncTask</code> to do its work. When subclassed, implementing the asynchronous task is as simple as implementing the abstract <code>loadInBackground()</code> method, which is called on a worker thread to perform the data load.</p></li>
<li><p>A registered listener to receive the Loader&rsquo;s results when it completes a load. For each of its <code>Loaders</code>, the <code>LoaderManager</code> registers an <code>OnLoadCompleteListener&lt;D&gt;</code> which will forward the Loader’s delivered results to the client with a call to <code>onLoadFinished(Loader&lt;D&gt; loader, D result)</code>. Loaders should deliver results to these registered listeners with a call to <code>Loader#deliverResult(D result)</code>.You don&rsquo;t need to worry about registering a listener for your Loader unless you plan on using it without the <code>LoaderManager</code>. The <code>LoaderManager</code> will act as this &ldquo;listener&rdquo; and will forward any results that the Loader delivers to the <code>LoaderCallbacks#onLoadFinished</code> method.</p></li>
<li><p>One of three distinct states. Any given Loader will either be in a started, stopped, or reset state:</p>

<ul>
<li><code>Loaders</code> in a started state execute loads and may deliver their results to the listener at any time. Started Loaders should monitor for changes and perform new loads when changes are detected. Once started, the Loader will remain in a started state until it is either stopped or reset. This is the only state in which <code>onLoadFinished</code> will ever be called.</li>
<li><code>Loaders</code> in a stopped state continue to monitor for changes but should not deliver results to the client. From a stopped state, the <code>Loader</code> may either be started or reset.</li>
<li><code>Loaders</code> in a reset state should not execute new loads, should not deliver new results, and should not monitor for changes. When a loader enters a reset state, it should invalidate and free any data associated with it for garbage collection (likewise, the client should make sure they remove any references to this data, since it will no longer be available). More often than not, reset Loaders will never be called again; however, in some cases they may be started, so they should be able to start running properly again if necessary.</li>
</ul>
</li>
<li>An observer to receive notifications when the data source has changed. <code>Loaders</code> should implement an observer of some sort (i.e. a <code>ContentObserver</code>, a <code>BroadcastReceiver</code>, etc.) to monitor the underlying data source for changes. When a change is detected, the observer should call <code>Loader#onContentChanged()</code>, which will either (a) force a new load if the Loader is in a started state or, (b) raise a flag indicating that a change has been made so that if the <code>Loader</code> is ever started again, it will know that it should reload its data.</li>
</ul>


<p>By now you should have a basic understanding of how Loaders work. If not, I suggest you let it sink in for a bit and come back later to read through once more (reading the <a href="http://developer.android.com/reference/android/content/Loader.html">documentation</a> never hurts either!). That being said, let’s get our hands dirty with the actual code!</p>

<h4>Implementing the Loader</h4>

<p>As I stated earlier, there is a lot that you must keep in mind when implementing your own custom Loaders. Subclasses must implement <code>loadInBackground()</code> and should override <code>onStartLoading()</code>, <code>onStopLoading()</code>, <code>onReset()</code>, <code>onCanceled()</code>, and <code>deliverResult(D results)</code> to achieve a fully functioning <code>Loader</code>. Overriding these methods is very important as the <code>LoaderManager</code> will call them regularly depending on the state of the Activity/Fragment lifecycle. For example, when an Activity is first started, the Activity instructs the <code>LoaderManager</code> to start each of its <code>Loaders</code> in <code>Activity#onStart()</code>. If a <code>Loader</code> is not already started, the <code>LoaderManager</code> calls <code>startLoading()</code>, which puts the <code>Loader</code> in a started state and immediately calls the <code>Loader’s</code> <code>onStartLoading()</code> method. In other words, a lot of work that the <code>LoaderManager</code> does behind the scenes relies on the Loader being correctly implemented, so don’t take the task of implementing these methods lightly!</p>

<p>The code below serves as a template of what a <code>Loader</code> implementation typically looks like. The <code>SampleLoader</code> queries a list of <code>SampleItem</code> objects and delivers a <code>List&lt;SampleItem&gt;</code> to the client:</p>

<p>```java
public class SampleLoader extends AsyncTaskLoader&lt;List<SampleItem>> {</p>

<p>  // We hold a reference to the Loader’s data here.
  private List<SampleItem> mData;</p>

<p>  public SampleLoader(Context ctx) {</p>

<pre><code>// Loaders may be used across multiple Activitys (assuming they aren't
// bound to the LoaderManager), so NEVER hold a reference to the context
// directly. Doing so will cause you to leak an entire Activity's context.
// The superclass constructor will store a reference to the Application
// Context instead, and can be retrieved with a call to getContext().
super(ctx);
</code></pre>

<p>  }</p>

<p>  /<em><em><em><em><em><em><em><em><em><em><em><em><em><em><em><em><em><em><em><em><em><em><em><em><em><em><em><em><em><em><em><em><em><em><em><em><em><em><em><em><em><em><em><em><em><em><em><em><em><em><strong>/
  /</strong> (1) A task that performs the asynchronous load <strong>/
  /</strong></em></em></em></em></em></em></em></em></em></em></em></em></em></em></em></em></em></em></em></em></em></em></em></em></em></em></em></em></em></em></em></em></em></em></em></em></em></em></em></em></em></em></em></em></em></em></em></em></em></em>/</p>

<p>  @Override
  public List<SampleItem> loadInBackground() {</p>

<pre><code>// This method is called on a background thread and should generate a
// new set of data to be delivered back to the client.
List&lt;SampleItem&gt; data = new ArrayList&lt;SampleItem&gt;();

// TODO: Perform the query here and add the results to 'data'.

return data;
</code></pre>

<p>  }</p>

<p>  /<em><em><em><em><em><em><em><em><em><em><em><em><em><em><em><em><em><em><em><em><em><em><em><em><em><em><em><em><em><em><em><em><em><em><em><em><em><em><em><em><em><em><em><em><em><em><em><em><em><em><em><em><em><em><strong>/
  /</strong> (2) Deliver the results to the registered listener <strong>/
  /</strong></em></em></em></em></em></em></em></em></em></em></em></em></em></em></em></em></em></em></em></em></em></em></em></em></em></em></em></em></em></em></em></em></em></em></em></em></em></em></em></em></em></em></em></em></em></em></em></em></em></em></em></em></em></em>/</p>

<p>  @Override
  public void deliverResult(List<SampleItem> data) {</p>

<pre><code>if (isReset()) {
  // The Loader has been reset; ignore the result and invalidate the data.
  releaseResources(data);
  return;
}

// Hold a reference to the old data so it doesn't get garbage collected.
// We must protect it until the new data has been delivered.
List&lt;SampleItem&gt; oldData = mData;
mData = data;

if (isStarted()) {
  // If the Loader is in a started state, deliver the results to the
  // client. The superclass method does this for us.
  super.deliverResult(data);
}

// Invalidate the old data as we don't need it any more.
if (oldData != null &amp;&amp; oldData != data) {
  releaseResources(oldData);
}
</code></pre>

<p>  }</p>

<p>  /<em><em><em><em><em><em><em><em><em><em><em><em><em><em><em><em><em><em><em><em><em><em><em><em><em><em><em><em><em><em><em><em><em><em><em><em><em><em><em><em><em><em><em><em><em><em><em><em><em><em><em><em><em><em><em><strong>/
  /</strong> (3) Implement the Loader’s state-dependent behavior <strong>/
  /</strong></em></em></em></em></em></em></em></em></em></em></em></em></em></em></em></em></em></em></em></em></em></em></em></em></em></em></em></em></em></em></em></em></em></em></em></em></em></em></em></em></em></em></em></em></em></em></em></em></em></em></em></em></em></em></em>/</p>

<p>  @Override
  protected void onStartLoading() {</p>

<pre><code>if (mData != null) {
  // Deliver any previously loaded data immediately.
  deliverResult(mData);
}

// Begin monitoring the underlying data source.
if (mObserver == null) {
  mObserver = new SampleObserver();
  // TODO: register the observer
}

if (takeContentChanged() || mData == null) {
  // When the observer detects a change, it should call onContentChanged()
  // on the Loader, which will cause the next call to takeContentChanged()
  // to return true. If this is ever the case (or if the current data is
  // null), we force a new load.
  forceLoad();
}
</code></pre>

<p>  }</p>

<p>  @Override
  protected void onStopLoading() {</p>

<pre><code>// The Loader is in a stopped state, so we should attempt to cancel the 
// current load (if there is one).
cancelLoad();

// Note that we leave the observer as is. Loaders in a stopped state
// should still monitor the data source for changes so that the Loader
// will know to force a new load if it is ever started again.
</code></pre>

<p>  }</p>

<p>  @Override
  protected void onReset() {</p>

<pre><code>// Ensure the loader has been stopped.
onStopLoading();

// At this point we can release the resources associated with 'mData'.
if (mData != null) {
  releaseResources(mData);
  mData = null;
}

// The Loader is being reset, so we should stop monitoring for changes.
if (mObserver != null) {
  // TODO: unregister the observer
  mObserver = null;
}
</code></pre>

<p>  }</p>

<p>  @Override
  public void onCanceled(List<SampleItem> data) {</p>

<pre><code>// Attempt to cancel the current asynchronous load.
super.onCanceled(data);

// The load has been canceled, so we should release the resources
// associated with 'data'.
releaseResources(data);
</code></pre>

<p>  }</p>

<p>  private void releaseResources(List<SampleItem> data) {</p>

<pre><code>// For a simple List, there is nothing to do. For something like a Cursor, we 
// would close it in this method. All resources associated with the Loader
// should be released here.
</code></pre>

<p>  }</p>

<p>  /<em><em><em><em><em><em><em><em><em><em><em><em><em><em><em><em><em><em><em><em><em><em><em><em><em><em><em><em><em><em><em><em><em><em><em><em><em><em><em><em><em><em><em><em><em><em><em><em><em><em><em><em><em><em><em><em><em><em><em><em><em><em><em><em><em><em><em><strong>/
  /</strong> (4) Observer which receives notifications when the data changes <strong>/
  /</strong></em></em></em></em></em></em></em></em></em></em></em></em></em></em></em></em></em></em></em></em></em></em></em></em></em></em></em></em></em></em></em></em></em></em></em></em></em></em></em></em></em></em></em></em></em></em></em></em></em></em></em></em></em></em></em></em></em></em></em></em></em></em></em></em></em></em></em>/</p>

<p>  // NOTE: Implementing an observer is outside the scope of this post (this example
  // uses a made-up &ldquo;SampleObserver&rdquo; to illustrate when/where the observer should
  // be initialized).</p>

<p>  // The observer could be anything so long as it is able to detect content changes
  // and report them to the loader with a call to onContentChanged(). For example,
  // if you were writing a Loader which loads a list of all installed applications
  // on the device, the observer could be a BroadcastReceiver that listens for the
  // ACTION_PACKAGE_ADDED intent, and calls onContentChanged() on the particular
  // Loader whenever the receiver detects that a new application has been installed.
  // Please don’t hesitate to leave a comment if you still find this confusing! :)
  private SampleObserver mObserver;
}
```</p>

<p>REF:</p>

<ul>
<li><a href="http://www.androiddesignpatterns.com/2012/07/loaders-and-loadermanager-background.html">Life Before Loaders</a></li>
<li><a href="http://www.androiddesignpatterns.com/2012/07/understanding-loadermanager.html">Understanding the LoaderManager</a></li>
<li><a href="http://www.androiddesignpatterns.com/2012/08/implementing-loaders.html">Implementing the Loaders</a></li>
<li><a href="http://www.androiddesignpatterns.com/2012/09/tutorial-loader-loadermanager.html">Tutorial:AppListLoader</a>,<a href="https://github.com/alexjlockwood/AppListLoader">AppListLoader</a></li>
</ul>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[The Hidden Pitfalls of AsyncTask]]></title>
    <link href="http://Solarex.github.io/blog/2014/10/19/android-asynctask-pitfalls/"/>
    <updated>2014-10-19T15:56:00+08:00</updated>
    <id>http://Solarex.github.io/blog/2014/10/19/android-asynctask-pitfalls</id>
    <content type="html"><![CDATA[<p><center><img src="http://Solarex.github.io/images/android_logo.jpg"/></center></p>


<p>I originally wrote this article when I was (foolishly) still using AsyncTasks. Nowadays I simply consider it a mistake in all cases. As you&rsquo;ll see from the original article, there are a lot of problems with it &ndash; and there are much better solutions.</p>

<p>My preferred alternative these days are combining <a href="https://github.com/Netflix/RxJava">RxJava</a> with schedulers. You get the same effect as an <code>AsyncTask</code> with none of the problems, plus you get an awesome framework in addition. I know, recommending a library to solve a problem is irritating, but RxJava is worth looking at for many reasons.</p>

<p>When <code>AsyncTask</code> was introduced to Android, it was labeled as “<a href="http://android-developers.blogspot.com/2009/05/painless-threading.html">Painless Threading</a>.” Its goal was to make background Threads which could interact with the UI thread easier. It was successful on that count, but it’s not exactly painless – there are a number of cases where <code>AsyncTask</code> is not a silver bullet. It is easy to blindly use <code>AsyncTask</code> without realizing what can go wrong if not handled with care. Below are some of the problems that can arise when using <code>AsyncTask</code> without fully understanding it.</p>

<!-- more -->


<h2>AsyncTask and Rotation</h2>

<p>AsyncTask’s primary goal is to make it easy to run a Thread in the background that can later interact with the UI thread. Therefore the most common use case is to have an <code>AsyncTask</code> run a time-consuming operation that updates a portion of the UI when it’s completed (in <code>AsyncTask.onPostExecute()</code>).</p>

<p>This works great… until you rotate the screen. <strong>When an app is rotated, the entire <code>Activity</code> is destroyed and recreated. When the Activity is restarted, your AsyncTask’s reference to the <code>Activity</code> is invalid, so <code>onPostExecute()</code> will have no effect on the new Activity.</strong> This can be confusing if you are implicitly referencing the current Activity by having AsyncTask as an inner class of the Activity.</p>

<p>The usual solution to this problem is to hold onto a reference to AsyncTask that lasts between configuration changes, which updates the target Activity as it restarts. There are a variety of ways to do this, though they either boil down to using a global holder (such as in the <code>Application</code> object) or passing it through <code>Activity.onRetainNonConfigurationInstance()</code>. For a Fragment-based system, you could use a retained Fragment (via <code>Fragment.setRetainedInstance(true)</code>) to store running AsyncTasks.</p>

<h2>AsyncTasks and the Lifecycle</h2>

<p>Along the same lines as above, it is a misconception to think that just because the Activity that originally spawned the <code>AsyncTask</code> is dead, the <code>AsyncTask</code> is as well. It will continue running on its merry way even if you exit the entire application. <strong>The only way that an <code>AsyncTask</code> finishes early is if it is canceled via <code>AsyncTask.cancel()</code>.</strong></p>

<p>This means that you have to manage the cancellation of AsyncTasks yourself; otherwise you run the risk of bogging down your app with unnecessary background tasks, or of leaking memory. When you know you will no longer need an <code>AsyncTask</code>, be sure to cancel it so that it doesn’t cause any headaches later in the execution of your app.</p>

<h2>Cancelling AsyncTasks</h2>

<p>Suppose you’ve got a search query that runs in an <code>AsyncTask</code>. The user may be able to change the search parameters while the <code>AsyncTask</code> is running, so you call <code>AsyncTask.cancel()</code> and then fire up a new <code>AsyncTask</code> for the next query. <strong>This seems to work… until you check the logs and realize that your <code>AsyncTask</code>s all ran till completion, regardless of whether you called <code>cancel()</code> or not!</strong> This even happens if you pass mayInterruptIfRunning as true – what’s going on?</p>

<p>The problem is that there’s a misconception about what <code>AsyncTask.cancel()</code> actually does. It does not kill the Thread with no regard for the consequences! All it does is set the <code>AsyncTask</code> to a “cancelled” state. <strong>It’s up to you to check whether the AsyncTask has been canceled so that you can halt your operation</strong>. As for mayInterruptIfRunning – all it does is send an <code>interrupt()</code> to the running Thread. In the case that your Thread is uninterruptible, then it won’t stop the Thread at all.There are two simple solutions that cover most situations: Either check <code>AsyncTask.isCancelled()</code> on a regular basis during your long-running operation, or keep your Thread interruptible. Either way, when you call <code>AsyncTask.cancel()</code> these methods should prevent your operation from running longer than necessary.</p>

<p>This advice doesn’t always work, though – what if you’re calling a long-running method that is uninterruptible (such as <code>BitmapFactory.decodeStream()</code>)? The only success I’ve had in this situation is to create a situation which causes an Exception to be thrown (in this case, prematurely closing the stream that BitmapFactory was using). This meant that <code>cancel()</code> alone wouldn’t solve the problem – outside intervention was required.</p>

<h2>Limitations on Concurrent AsyncTasks</h2>

<p>I’m not encouraging people to start hundreds of threads in the background; however, it is worth noting that there are some limitations on the number of <code>AsyncTask</code>s that you can start. The modern <code>AsyncTask</code> is limited to 128 concurrent tasks, with an additional queue of 10 tasks (if supporting Android 1.5, it’s a limit of ten tasks at a time, with a maximum queue of 10 tasks). That means that if you queue up more than 138 tasks before they can complete, your app will crash. Most often I see this problem when people use <code>AsyncTask</code>s to load Bitmaps from the net.</p>

<p>If you are finding yourself running up against these limits, you should start by rethinking your design that calls for so many background threads. Alternatively, you could setup a more intelligent queue for your tasks so that you’re not starting them all at once. If you’re desperate, you can grab a copy of <code>AsyncTask</code> and adjust the pool sizes in the code itself.</p>

<ul>
<li><a href="http://blog.danlew.net/2014/06/21/the-hidden-pitfalls-of-asynctask/">The Hidden Pitfalls of AsyncTask</a></li>
</ul>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Android Tips]]></title>
    <link href="http://Solarex.github.io/blog/2014/10/19/android-tips/"/>
    <updated>2014-10-19T13:00:00+08:00</updated>
    <id>http://Solarex.github.io/blog/2014/10/19/android-tips</id>
    <content type="html"><![CDATA[<p><center><img src="http://Solarex.github.io/images/android_training.jpg"/></center></p>


<ul>
<li><a href="#overview">Android Tips and Tricks</a>

<ul>
<li><a href="#part1">Part I</a></li>
<li><a href="#part2">Part II</a></li>
<li><a href="#part3">Part III</a></li>
<li><a href="#part4">Part IV</a></li>
<li><a href="#part5">Part V</a></li>
</ul>
</li>
</ul>


<h2 id="overview">Android Tips and Tricks</h2>




<h3 id="part1">Part I</h3>


<ul>
<li><p><code>Activity.startActivities()</code> &ndash; Nice for launching to the middle of an app flow.</p></li>
<li><p><code>TextUtils.isEmpty()</code> &ndash; Simple utility I use everywhere.</p></li>
<li><p><code>Html.fromHtml()</code> &ndash; Quick method for formatting Html. It&rsquo;s not particularly fast so I wouldn&rsquo;t use it constantly (e.g., don&rsquo;t use it just to bold part of a string &ndash; construct the Spannable manually instead), but it&rsquo;s fine for rendering text obtained from the web.</p></li>
<li><p><code>TextView.setError()</code> &ndash; Nice UI when validating user input.</p></li>
<li><p><code>Build.VERSION_CODES</code> &ndash; Not only is it handy for routing code, it&rsquo;s also summarizes behavioral differences between each version of Android.</p></li>
</ul>


<!-- more -->


<ul>
<li><p><code>Log.getStackTraceString()</code> &ndash; Convenience utility for logging.</p></li>
<li><p><code>LayoutInflater.from()</code> &ndash; Wraps the long-winded getSystemService() call in a simple utility.</p></li>
<li><p><code>ViewConfiguration.getScaledTouchSlop()</code> &ndash; Using the values provided in ViewConfiguration ensures all touch interaction feels consistent across the OS.</p></li>
<li><p><code>PhoneNumberUtils.convertKeypadLettersToDigits</code> &ndash; Makes handling phone number data a snap, as some companies provide them as letters.</p></li>
<li><p><code>Context.getCacheDir()</code> &ndash; Use the cache dir for caching data. Simple enough but some don&rsquo;t know it exists.</p></li>
<li><p><code>ArgbEvaluator</code> &ndash; Transition from one color to another. As was pointed out by Chris Banes, this class creates a lot of autoboxing churn so it&rsquo;d be better to just rip out the logic and run it yourself.</p></li>
<li><p><code>ContextThemeWrapper</code> &ndash; Nice class for changing the theme of a Context on the fly.</p></li>
<li><p><code>Space</code> &ndash; Lightweight View which skips drawing. Great for any situation that might require a placeholder.</p></li>
<li><p><code>ValueAnimator.reverse()</code> &ndash; I love this for canceling animations smoothly.</p></li>
</ul>


<h3 id="part2">Part II</h3>


<ul>
<li><p><code>DateUtils.formatDateTime()</code> &ndash; One-stop shop for localized date/time strings.</p></li>
<li><p><code>AlarmManager.setInexactRepeating</code> &ndash; Saves on battery life by grouping multiple alarms together. Even if you&rsquo;re only calling a single alarm this is better (just make sure to call AlarmManager.cancel() when done).</p></li>
<li><p><code>Formatter.formatFileSize()</code> &ndash; A localized file size formatter.</p></li>
<li><p><code>ActionBar.hide()/.show()</code> &ndash; Animates the action bar hiding/showing. Lets you switch to full-screen gracefully.</p></li>
<li><p><code>Linkify.addLinks()</code> &ndash; If you need to control how links are added to text.</p></li>
<li><p><code>StaticLayout</code> &ndash; Useful for measuring text that you&rsquo;re about to render into a custom View.</p></li>
<li><p><code>Activity.onBackPressed()</code> &ndash; Easy way to manage the back button. While I wouldn&rsquo;t normally hijack back, sometimes it&rsquo;s necessary to make a flow work.</p></li>
<li><p><code>GestureDetector</code> &ndash; Listens to motion events and fires listener events for common actions (like clicks, scrolls and flings). So much easier than implementing your own motion event system.</p></li>
<li><p><code>DrawFilter</code> &ndash; Lets you manipulate a Canvas even if you&rsquo;re not calling the draw commands. For example, you could create a custom View which sets a DrawFilter which anti-aliases the draws of the parent View.</p></li>
<li><p><code>ActivityManager.getMemoryClass()</code> &ndash; Gives you an idea of how much memory the device has. Great for figuring out how large to make your caches.</p></li>
<li><p><code>SystemClock.sleep()</code> &ndash; Convenience method which guarantees sleeping the amount of time entered. I use it for debugging and simulating network delays.</p></li>
<li><p><code>ViewStub</code> &ndash; A View that initially does nothing, but can later inflate a layout. This is a great placeholder for lazy-loading Views. Its only drawback is that it doesn&rsquo;t support <merge> tags, so it can create unnecessary nesting in the hierarchy if you&rsquo;re not careful.</p></li>
<li><p><code>DisplayMetrics.density</code> &ndash; You can get the density of the screen this way. Most of the time you&rsquo;ll be better off letting the system scale dimensions automatically, but occasionally it&rsquo;s useful to have more control (especially with custom Views).</p></li>
<li><p><code>Pair.create()</code> &ndash; Handy class, handy creator method.</p></li>
</ul>


<h3 id="part3">Part III</h3>


<ul>
<li><p><code>UrlQuerySanitizer</code> &ndash; Sanitize URLs with this handy utility.</p></li>
<li><p><code>Fragment.setArguments</code> &ndash; Since you can&rsquo;t use a Fragment constructor w/ parameters this is the second best thing. Arguments set before creation last throughout the entire Fragment&rsquo;s lifecycle (even if it&rsquo;s destroyed/recreated due to a configuration change).</p></li>
<li><p><code>DialogFragment.setShowsDialog()</code> &ndash; Neat trick &ndash; DialogFragments can act like normal Fragments! That way you can have the same Fragment do double-duty. I usually create a third View generation method that both onCreateView() and onCreateDialog() call into when creating a dual-purpose Fragment.</p></li>
<li><p><code>FragmentManager.enableDebugLogging()</code> &ndash; Help when you need it when figuring out Fragments.</p></li>
<li><p><code>LocalBroadcastManager</code> &ndash; Safer than global broadcasts. Simple and quick. Event buses like otto may make more sense for your use case though.</p></li>
<li><p><code>PhoneNumberUtils.formatNumber()</code> &ndash; Let someone else figure out this problem for you.</p></li>
<li><p><code>Region.op()</code> &ndash; I found this useful for comparing two generic areas before rendering. If I&rsquo;ve got two Paths, do they overlap? I can figure that out with this method.</p></li>
<li><p><code>Application.registerActivityLifecycleCallbacks</code> &ndash; Though lacking documentation I feel this is self-evident. Just a handy tool.</p></li>
<li><p><code>versionNameSuffix</code> &ndash; This gradle setting lets you modify the versionName field in your manifest based on different build types. For example, I would setup my debug build type to end in &ldquo;-SNAPSHOT&rdquo;; that way you can easily tell if you&rsquo;re on a debug build or release build.</p></li>
<li><p><code>CursorJoiner</code> &ndash; If you&rsquo;re using a single database then a join in SQL is the natural solution, but what if you&rsquo;ve received data from two separate ContentProviders? In that case CursorJoiner can be helpful.</p></li>
<li><p><code>Genymotion</code> &ndash; A much faster Android emulator. I use it all day.</p></li>
<li><p><code>-nodpi</code> &ndash; Most qualifiers (-mdpi, -hdpi, -xhdpi, etc.) automatically scale assets/dimensions if you&rsquo;re on a device that isn&rsquo;t explicitly defined. Sometimes you just want something consistent though; in that case use -nodpi.</p></li>
<li><p><code>BroadcastRecevier.setDebugUnregister()</code> &ndash; Another handy debugging tool.</p></li>
<li><p><code>Activity.recreate()</code> &ndash; Forces an Activity to recreate itself for whatever reason.</p></li>
<li><p><code>PackageManager.checkSignatures()</code> &ndash; You can use this to find out if two apps (presumably your own) are installed at the same time. Without checking signatures someone could imitate your app easily by just using the same package name.</p></li>
</ul>


<h3 id="part4">Part IV</h3>


<ul>
<li><p><code>Activity.isChangingConfigurations()</code> &ndash; Often times you don&rsquo;t need to do quite as much saving of state if all that&rsquo;s happening is the configuration is changing.</p></li>
<li><p><code>SearchRecentSuggestionsProvider</code> &ndash; A quick and easy way to create a recents suggestion provider.</p></li>
<li><p><code>ViewTreeObserver</code> &ndash; This is an amazing utility; it can be grabbed from any View and used to monitor the state of the View hierarchy. My most often use for it is to determine when Views have been measured (usually for animation purposes).</p></li>
<li><p><code>org.gradle.daemon=true</code> &ndash; Helps reduce the startup time of of Gradle builds. Only really applies to command-line builds as Android Studio already tries to use the daemon.</p></li>
<li><p><code>DatabaseUtils</code> &ndash; A variety of useful tools for database operations.</p></li>
<li><p><code>android:weightSum</code> (LinearLayout) &ndash; Want to use layout weights, but don&rsquo;t want them to fill the entire LinearLayout? That&rsquo;s what weightSum can do by defining the total weight.</p></li>
<li><p><code>android:duplicateParentState</code> (View) &ndash; Makes the child duplicate the state of the parent &ndash; for example, if you&rsquo;ve got a ViewGroup that is clickable, then you can use this to make its children change state when it is clicked.</p></li>
<li><p><code>android:clipChildren</code> (ViewGroup) &ndash; If disabled, this lets the children of a ViewGroup draw outside their parent&rsquo;s bounds. Great for animations.</p></li>
<li><p><code>android:fillViewport</code> (ScrollView) &ndash; Best explained in this post, this helps solve a problem with ScrollViews that may not always have enough content to actually fill the height of the screen.</p></li>
<li><p><code>android:tileMode</code> (BitmapDrawable) &ndash; Lets you create repeated patterns with images.</p></li>
<li><p><code>android:enterFadeDuration/android:exitFadeDuration</code> (Drawables) &ndash; For Drawables that have multiple states, this lets you define a fade before/after the drawable shows.</p></li>
<li><p><code>android:scaleType</code> (ImageView) &ndash; Defines how to scale/crop a drawable within an ImageView. &ldquo;centerCrop&rdquo; and &ldquo;centerInside&rdquo; are regular settings for me.</p></li>
<li><p><code>&lt;merge&gt;</code> &ndash; Lets you include a layout in another without creating a duplicate ViewGroup (more info). Also good for custom ViewGroups; you can inflate a layout with <merge> inside the constructor to define its children automatically.</p></li>
<li><p><code>AtomicFile</code> &ndash; Manipulates a file atomically by using a backup file. I&rsquo;ve written this myself before, it&rsquo;s good to have an official (and better-written) version of it.</p></li>
</ul>


<h3 id="part5">Part V</h3>


<ul>
<li><p><code>ViewDragHelper</code> &ndash; Dragging Views is a complex problem and this class helps a lot. If you want an example, DrawerLayout uses it for swiping. Flavient Laurent also wrote an excellent article about it.</p></li>
<li><p><code>PopupWindow</code> &ndash; Used all around Android without you even realizing it (action bars, autocomplete, edittext errors), this class is the primary method for creating floating content.</p></li>
<li><p><code>ActionBar.getThemedContext()</code> &ndash; ActionBar theming is surprisingly complex (and can be different from the theming of the rest of the Activity). This gets you a Context so if you create your own Views they will be properly themed.</p></li>
<li><p><code>ThumbnailUtils</code> &ndash; Helps create thumbnails; in general I&rsquo;d just use whatever image library was already in place (e.g. Picasso or Volley), but it can also create video thumbnails!</p></li>
<li><p><code>Context.getExternalFilesDir()</code> &ndash; While you do have permission to write anywhere on the SD card if you ask for it, it&rsquo;s much more polite to write your data in the correct designated folder. That way it gets cleaned up and users get a common experience. Additionally, as of Kit Kat you can write to this folder without permission, and each user has their own external files dir.</p></li>
<li><p><code>SparseArray</code> &ndash; A more efficient version of Map&lt;Integer, Object>. Be sure to check out sister classes SparseBooleanArray, SparseIntArray and SparseLongArray as well.</p></li>
<li><p><code>PackageManager.setComponentEnabledSetting()</code> &ndash; Lets you enable/disable components in your app&rsquo;s manifest. What&rsquo;s nice here is being able to shut off unnecessary functionality &ndash; for example, a BroadcastReceiver that is unnecessary due to the current app configuration.</p></li>
<li><p><code>SQLiteDatabase.yieldIfContendedSafely()</code> &ndash; Lets you temporarily stop a db transaction so you don&rsquo;t tie up too much of the system.</p></li>
<li><p><code>Environment.getExternalStoragePublicDirectory()</code> &ndash; Again, users like a consistent experience with their SD card; using this method will grab the correct directory for placing typed files (music, pictures, etc.) on their drive.</p></li>
<li><p><code>View.generateViewId()</code> &ndash; Every once in a while I&rsquo;ve wanted to dynamically generate view IDs. The problem is ensuring you aren&rsquo;t clobbering existing IDs (or other generated ones).</p></li>
<li><p><code>ActivityManager.clearApplicationUserData()</code> &ndash; A reset button for your app. Perhaps the easiest way to log out a user, ever.</p></li>
<li><p><code>Context.createConfigurationContext()</code> &ndash; Customize your configuration context. Common problem I&rsquo;ve run into: forcing part of an app to render in a particular locale (not that I normally condone this sort of behavior, but you never know). This would make it a lot easier to do so.</p></li>
<li><p><code>ActivityOptions</code> &ndash; Nice custom animations when moving between Activities. ActivityOptionsCompat is good for backwards compatible functionality.</p></li>
<li><p><code>AdapterViewFlipper.fyiWillBeAdvancedByHostKThx()</code> &ndash; Because it&rsquo;s funny and for no other reason. There are other amusing tidbits in AOSP (like GRAVITY_DEATH_STAR_I) but unlike those this one is actually useful.</p></li>
<li><p><code>ViewParent.requestDisallowInterceptTouchEvent()</code> &ndash; The Android touch event system defaults handle what you want most of the time, but sometimes you need this method to wrest event control from parents. (By the way, if you want to know about the touch system, this talk is amazing.)</p></li>
</ul>

]]></content>
  </entry>
  
</feed>
