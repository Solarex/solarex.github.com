<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: android | Solarex's Blog]]></title>
  <link href="http://Solarex.github.io/blog/categories/android/atom.xml" rel="self"/>
  <link href="http://Solarex.github.io/"/>
  <updated>2019-04-15T16:18:10+08:00</updated>
  <id>http://Solarex.github.io/</id>
  <author>
    <name><![CDATA[Solarex]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[自定义View总结三]]></title>
    <link href="http://Solarex.github.io/blog/2019/03/12/summary-of-custom-views-part-iii/"/>
    <updated>2019-03-12T00:34:00+08:00</updated>
    <id>http://Solarex.github.io/blog/2019/03/12/summary-of-custom-views-part-iii</id>
    <content type="html"><![CDATA[
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[自定义View总结二]]></title>
    <link href="http://Solarex.github.io/blog/2019/02/12/summary-of-custom-views-part-ii/"/>
    <updated>2019-02-12T00:34:00+08:00</updated>
    <id>http://Solarex.github.io/blog/2019/02/12/summary-of-custom-views-part-ii</id>
    <content type="html"><![CDATA[
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[自定义View总结一]]></title>
    <link href="http://Solarex.github.io/blog/2019/01/12/summary-of-custom-views-part-i/"/>
    <updated>2019-01-12T00:33:00+08:00</updated>
    <id>http://Solarex.github.io/blog/2019/01/12/summary-of-custom-views-part-i</id>
    <content type="html"><![CDATA[<h2>自定义View总结 &ndash; 绘制</h2>

<h3>绘制基础</h3>

<ul>
<li><code>Canvas.drawColor(@ColorInt int color)</code> 颜色填充</li>
<li><code>drawCircle(float centerX, float centerY, float radius, Paint paint)</code> 画圆</li>
<li><code>Paint.setColor(int color)</code>,<code>Paint.setStyle(Paint.Style style)</code>,<code>Paint.setStrokeWidth(float width)</code>,<code>Paint.setAntiAlias(boolean aa)</code></li>
<li><code>drawRect(float left, float top, float right, float bottom, Paint paint)</code> 画矩形</li>
<li><code>drawPoint(float x, float y, Paint paint)</code> 画点</li>
<li><code>drawPoints(float[] pts, int offset, int count, Paint paint) / drawPoints(float[] pts, Paint paint)</code> 画点（批量）</li>
<li><code>drawOval(float left, float top, float right, float bottom, Paint paint)</code>画椭圆</li>
<li><code>drawLine(float startX, float startY, float stopX, float stopY, Paint paint)</code> 画线</li>
<li><code>drawLines(float[] pts, int offset, int count, Paint paint) / drawLines(float[] pts, Paint paint)</code> 画线（批量）</li>
<li><code>drawRoundRect(float left, float top, float right, float bottom, float rx, float ry, Paint paint)</code> 画圆角矩形</li>
<li><code>drawArc(float left, float top, float right, float bottom, float startAngle, float sweepAngle, boolean useCenter, Paint paint)</code> 绘制弧形或扇形</li>
<li><code>drawPath(Path path, Paint paint)</code> 画自定义图形</li>
<li><code>drawBitmap(Bitmap bitmap, float left, float top, Paint paint)</code> 画 Bitmap</li>
<li><code>drawText(String text, float x, float y, Paint paint)</code>绘制文字</li>
</ul>


<!-- more -->


<h4>Path</h4>

<ul>
<li><code>addCircle(float x, float y, float radius, Direction dir)</code> 添加圆</li>
<li><code>addOval(float left, float top, float right, float bottom, Direction dir) / addOval(RectF oval, Direction dir)</code>添加椭圆</li>
<li><code>addRect(float left, float top, float right, float bottom, Direction dir) / addRect(RectF rect, Direction dir)</code>添加矩形</li>
<li><code>addRoundRect(RectF rect, float rx, float ry, Direction dir) / addRoundRect(float left, float top, float right, float bottom, float rx, float ry, Direction dir) / addRoundRect(RectF rect, float[] radii, Direction dir) / addRoundRect(float left, float top, float right, float bottom, float[] radii, Direction dir)</code>添加圆角矩形</li>
<li><code>addPath(Path path)</code> 添加另一个 Path</li>
<li><code>lineTo(float x, float y) / rLineTo(float x, float y)</code>画直线</li>
<li><code>quadTo(float x1, float y1, float x2, float y2) / rQuadTo(float dx1, float dy1, float dx2, float dy2)</code>画二次贝塞尔曲线</li>
<li><code>cubicTo(float x1, float y1, float x2, float y2, float x3, float y3) / rCubicTo(float x1, float y1, float x2, float y2, float x3, float y3)</code> 画三次贝塞尔曲线</li>
<li><code>moveTo(float x, float y) / rMoveTo(float x, float y)</code>移动到目标位置</li>
<li><code>arcTo(RectF oval, float startAngle, float sweepAngle, boolean forceMoveTo) / arcTo(float left, float top, float right, float bottom, float startAngle, float sweepAngle, boolean forceMoveTo) / arcTo(RectF oval, float startAngle, float sweepAngle)</code> 画弧形</li>
<li><code>addArc(float left, float top, float right, float bottom, float startAngle, float sweepAngle) / addArc(RectF oval, float startAngle, float sweepAngle)</code>,<code>addArc()</code> 只是一个直接使用了 <code>forceMoveTo = true</code> 的简化版 <code>arcTo()</code></li>
<li><code>close()</code>封闭当前子图形</li>
<li><code>Path.setFillType(Path.FillType ft)</code> 设置填充方式</li>
</ul>


<h3>Paint详解</h3>

<center><p><img src="http://Solarex.github.io/images/canvas-color.jpg" alt="Canvas绘制的内容，有三层对颜色的处理"></p></center>


<h4>颜色</h4>

<table>
<thead>
<tr>
<th></th>
<th align="center">     canvas 方法      </th>
<th> 像素颜色的设置方式 </th>
</tr>
</thead>
<tbody>
<tr>
<td></td>
<td align="center"> drawColor/RGB/ARGB() </td>
<td> 直接作为参数传入   |</td>
</tr>
<tr>
<td></td>
<td align="center"> drawBitmap() </td>
<td> 与<code>bitmap</code>参数的像素颜色相同 |</td>
</tr>
<tr>
<td></td>
<td align="center"> 图形和文字(drawCircle()/drawPath()/drawText()&hellip;) </td>
<td> 在<code>paint</code>参数中设置 |</td>
</tr>
</tbody>
</table>


<h5>直接设置颜色<code>Paint.setColor(int color)</code>,<code>Paint.setARGB(int a,int r,int g,int b)</code></h5>

<h5>setShader(Shader shader) 设置shader</h5>

<ul>
<li><p>shader着色器，它和直接设置颜色的区别是，着色器设置的是一个颜色方案，或者说是一套着色规则。</p></li>
<li><p>LinearGradient 线性渐变</p></li>
<li><p>RadialGradient 辐射渐变，辐射渐变很好理解，就是从中心向周围辐射状的渐变。</p></li>
<li><p>SweepGradient 扫描渐变</p></li>
<li><p>BitmapShader 用 Bitmap 来着色，其实也就是用 Bitmap 的像素来作为图形或文字的填充。</p></li>
<li><p>ComposeShader 混合着色器 所谓混合，就是把两个 Shader 一起使用。</p></li>
</ul>


<h5>setColorFilter(ColorFilter colorFilter)</h5>

<p>为绘制设置颜色过滤。颜色过滤的意思，就是为绘制的内容设置一个统一的过滤策略，然后 Canvas.drawXXX() 方法会对每个像素都进行过滤后再绘制出来。</p>

<ul>
<li><code>LightingColorFilter(int mul, int add)</code></li>
</ul>


<p><code>java
R' = R * mul.R / 0xff + add.R  
G' = G * mul.G / 0xff + add.G  
B' = B * mul.B / 0xff + add.B  
</code></p>

<ul>
<li><code>PorterDuffColorFilter(int color, PorterDuff.Mode mode)</code></li>
<li><code>ColorMatrixColorFilter</code></li>
</ul>


<p><code>ColorMatrixColorFilter</code> 使用一个 <code>ColorMatrix</code> 来对颜色进行处理。 <code>ColorMatrix</code> 这个类，内部是一个 4x5 的矩阵：</p>

<p>```java
[ a, b, c, d, e,
  f, g, h, i, j,
  k, l, m, n, o,
  p, q, r, s, t ]</p>

<p>R’ = a<em>R + b</em>G + c<em>B + d</em>A + e;<br/>
G’ = f<em>R + g</em>G + h<em>B + i</em>A + j;<br/>
B’ = k<em>R + l</em>G + m<em>B + n</em>A + o;<br/>
A’ = p<em>R + q</em>G + r<em>B + s</em>A + t;
```</p>

<p><a href="https://github.com/chengdazhi/StyleImageView">StyleImageView</a></p>

<h5>setXfermode(Xfermode xfermode)</h5>

<ul>
<li><p>使用离屏缓冲（Off-screen Buffer）</p></li>
<li><p>控制好透明区域</p></li>
</ul>


<h4>效果</h4>

<h5>setAntiAlias (boolean aa) 设置抗锯齿</h5>

<h5>setStyle(Paint.Style style)</h5>

<h5>线条形状</h5>

<ul>
<li><p><code>setStrokeWidth(float width)</code></p></li>
<li><p><code>setStrokeCap(Paint.Cap cap)</code></p></li>
<li><p><code>setStrokeJoin(Paint.Join join)</code></p></li>
<li><p><code>setStrokeMiter(float miter)</code></p></li>
</ul>


<h5>色彩优化</h5>

<ul>
<li><p><code>setDither(boolean dither)</code> 设置图像的抖动</p></li>
<li><p><code>setFilterBitmap(boolean filter)</code> 设置是否使用双线性过滤来绘制 Bitmap</p></li>
</ul>


<h5>setPathEffect(PathEffect effect)</h5>

<p>使用 <code>PathEffect</code> 来给图形的轮廓设置效果。对 Canvas 所有的图形绘制有效，也就是  <code>drawLine() drawCircle() drawPath()</code> 这些方法。</p>

<ul>
<li><p><code>CornerPathEffect</code> 把所有拐角变成圆角</p></li>
<li><p><code>DiscretePathEffect</code> 把线条进行随机的偏离，让轮廓变得乱七八糟。</p></li>
<li><p><code>DashPathEffect</code> 使用虚线来绘制线条</p></li>
<li><p><code>PathDashPathEffect</code> 这个方法比 DashPathEffect 多一个前缀 Path ，所以顾名思义，它是使用一个 Path 来绘制「虚线」。</p></li>
<li><p><code>SumPathEffect</code> 这是一个组合效果类的 PathEffect 。它的行为特别简单，就是分别按照两种 PathEffect 分别对目标进行绘制。</p></li>
<li><p><code>ComposePathEffect</code> 这也是一个组合效果类的 PathEffect 。不过它是先对目标 Path 使用一个 PathEffect，然后再对这个改变后的 Path 使用另一个 PathEffect。它的构造方法 <code>ComposePathEffect(PathEffect outerpe, PathEffect innerpe)</code> 中的两个  PathEffect 参数， innerpe 是先应用的， outerpe 是后应用的。</p></li>
</ul>


<h5>setShadowLayer(float radius, float dx, float dy, int shadowColor)</h5>

<p>在之后的绘制内容下面加一层阴影。如果要清除阴影层，使用 clearShadowLayer() 。</p>

<ul>
<li><p>在硬件加速开启的情况下， setShadowLayer() 只支持文字的绘制，文字之外的绘制必须关闭硬件加速才能正常绘制阴影。</p></li>
<li><p>如果 shadowColor 是半透明的，阴影的透明度就使用 shadowColor 自己的透明度；而如果 shadowColor 是不透明的，阴影的透明度就使用 paint 的透明度。</p></li>
</ul>


<h5>setMaskFilter(MaskFilter maskfilter)</h5>

<p>为之后的绘制设置 <code>MaskFilter</code>。上一个方法 <code>setShadowLayer()</code> 是设置的在绘制层下方的附加效果；而这个 <code>MaskFilter</code> 和它相反，设置的是在绘制层上方的附加效果。</p>

<ul>
<li><p><code>BlurMaskFilter</code> 模糊效果的 MaskFilter。<code>BlurMaskFilter(float radius, BlurMaskFilter.Blur style)</code> 中， radius 参数是模糊的范围， style 是模糊的类型。NORMAL: 内外都模糊绘制，SOLID: 内部正常绘制，外部模糊，INNER: 内部模糊，外部不绘制，OUTER: 内部不绘制，外部模糊。</p></li>
<li><p><code>EmbossMaskFilter</code> 浮雕效果的 MaskFilter。</p></li>
</ul>


<h5>获取绘制的 Path</h5>

<p>根据 paint 的设置，计算出绘制 Path 或文字时的实际 Path。所谓实际 Path ，指的就是 drawPath() 的绘制内容的轮廓，要算上线条宽度和设置的 PathEffect。</p>

<ul>
<li><p><code>getFillPath(Path src, Path dst)</code>，<code>getFillPath(src, dst)</code> 方法就能获取这个实际 Path。方法的参数里，src 是原 Path ，而 dst 就是实际 Path 的保存位置。 <code>getFillPath(src, dst)</code> 会计算出实际 Path，然后把结果保存在 dst 里。</p></li>
<li><p><code>getTextPath(String text, int start, int end, float x, float y, Path path) / getTextPath(char[] text, int index, int count, float x, float y, Path path)</code> 文字的绘制，虽然是使用 Canvas.drawText() 方法，但其实在下层，文字信息全是被转化成图形，对图形进行绘制的。  getTextPath() 方法，获取的就是目标文字所对应的 Path</p></li>
</ul>


<h4>Paint初始化类</h4>

<ul>
<li><p><code>reset()</code></p></li>
<li><p><code>set(Paint src)</code></p></li>
<li><p><code>setFlags(int flags)</code></p></li>
</ul>


<h3>文字的绘制</h3>

<h5>Canvas 绘制文字的方式</h5>

<ul>
<li><p><code>drawText(String text, float x, float y, Paint paint)</code></p></li>
<li><p><code>drawTextRun()</code></p></li>
<li><p><code>drawTextOnPath()</code></p></li>
<li><p><code>StaticLayout</code></p></li>
</ul>


<h5>Paint 对文字绘制的辅助</h5>

<ul>
<li><p><code>setTextSize(float textSize)</code></p></li>
<li><p><code>setTypeface(Typeface typeface)</code></p></li>
<li><p><code>setFakeBoldText(boolean fakeBoldText)</code> 伪粗体（ fake bold ），因为它并不是通过选用更高 weight 的字体让文字变粗，而是通过程序在运行时把文字给「描粗」了</p></li>
<li><p><code>setStrikeThruText(boolean strikeThruText)</code> 是否加删除线</p></li>
<li><p><code>setUnderlineText(boolean underlineText)</code> 是否加下划线</p></li>
<li><p><code>setTextSkewX(float skewX)</code> 设置文字横向错切角度。其实就是文字倾斜度的啦。</p></li>
<li><p><code>setTextScaleX(float scaleX)</code> 设置文字横向放缩。也就是文字变胖变瘦。</p></li>
<li><p><code>setLetterSpacing(float letterSpacing)</code> 设置字符间距。默认值是 0。</p></li>
<li><p><code>setFontFeatureSettings(String settings)</code></p></li>
<li><p><code>setTextAlign(Paint.Align align)</code> 设置文字的对齐方式。一共有三个值：LEFT CETNER 和 RIGHT。默认值为 LEFT。</p></li>
<li><p><code>setTextLocale(Locale locale) / setTextLocales(LocaleList locales)</code> 设置绘制所使用的 Locale。</p></li>
<li><p><code>setHinting(int mode)</code> 设置是否启用字体的 hinting （字体微调）。</p></li>
<li><p><code>setElegantTextHeight(boolean elegant)</code> 设置是否开启文字的 elegant height 。开启之后，文字的高度就变优雅了</p></li>
<li><p><code>setSubpixelText(boolean subpixelText)</code> 是否开启次像素级的抗锯齿（ sub-pixel anti-aliasing ）。</p></li>
<li><p><code>setLinearText(boolean linearText)</code></p></li>
<li><p><code>hasGlyph(String string)</code> 检查指定的字符串中是否是一个单独的字形 (glyph）。</p></li>
</ul>


<h5>测量文字尺寸类</h5>

<ul>
<li><p><code>float getFontSpacing()</code> 获取推荐的行距。</p></li>
<li><p><code>FontMetircs getFontMetrics()</code> 获取 Paint 的 FontMetrics。<code>FontMetrics</code> 是个相对专业的工具类，它提供了几个文字排印方面的数值：<code>ascent</code>,  <code>descent</code>, <code>top</code>, <code>bottom</code>, <code>leading</code>。<code>ascent</code> 和 <code>descent</code> 这两个值还可以通过 <code>Paint.ascent()</code> 和 <code>Paint.descent()</code> 来快捷获取。</p></li>
<li><p><code>getTextBounds(String text, int start, int end, Rect bounds)</code> 获取文字的显示范围。</p></li>
<li><p><code>float measureText(String text)</code> 测量文字的宽度并返回。</p></li>
</ul>


<p>如果你用代码分别使用 getTextBounds() 和 measureText() 来测量文字的宽度，你会发现  measureText() 测出来的宽度总是比 getTextBounds() 大一点点。这是因为这两个方法其实测量的是两个不一样的东西。getTextBounds: 它测量的是文字的显示范围（关键词：显示）。形象点来说，你这段文字外放置一个可变的矩形，然后把矩形尽可能地缩小，一直小到这个矩形恰好紧紧包裹住文字，那么这个矩形的范围，就是这段文字的 bounds。measureText(): 它测量的是文字绘制时所占用的宽度（关键词：占用）。前面已经讲过，一个文字在界面中，往往需要占用比他的实际显示宽度更多一点的宽度，以此来让文字和文字之间保留一些间距，不会显得过于拥挤。</p>

<ul>
<li><p><code>getTextWidths(String text, float[] widths)</code> 获取字符串中每个字符的宽度，并把结果填入参数 widths。</p></li>
<li><p><code>int breakText(String text, boolean measureForwards, float maxWidth, float[] measuredWidth)</code> 这个方法也是用来测量文字宽度的。但和 measureText() 的区别是， breakText() 是在给出宽度上限的前提下测量文字的宽度。如果文字的宽度超出了上限，那么在临近超限的位置截断文字。</p></li>
</ul>


<h5>光标相关</h5>

<ul>
<li><p><code>getRunAdvance(CharSequence text, int start, int end, int contextStart, int contextEnd, boolean isRtl, int offset)</code> 对于一段文字，计算出某个字符处光标的 x 坐标。</p></li>
<li><p><code>getOffsetForAdvance(CharSequence text, int start, int end, int contextStart, int contextEnd, boolean isRtl, float advance)</code> 给出一个位置的像素值，计算出文字中最接近这个位置的字符偏移量</p></li>
</ul>


<h3>Canvas 对绘制的辅助 clipXXX() 和 Matrix</h3>

<h5>范围裁切</h5>

<p>范围裁切有两个方法： <code>clipRect()</code> 和 <code>clipPath()</code>。裁切方法之后的绘制代码，都会被限制在裁切范围内。</p>

<ul>
<li><p><code>clipRect()</code></p></li>
<li><p><code>clipPath()</code></p></li>
</ul>


<h5>几何变换</h5>

<p>几何变换的使用大概分为三类：</p>

<ul>
<li>使用 Canvas 来做常见的二维变换；</li>
<li>使用 Matrix 来做常见和不常见的二维变换；</li>
<li>使用 Camera 来做三维变换。</li>
</ul>


<h6>使用 Canvas 来做常见的二维变换</h6>

<ul>
<li><p><code>Canvas.translate(float dx, float dy)</code> 平移</p></li>
<li><p><code>Canvas.rotate(float degrees, float px, float py)</code> 旋转</p></li>
<li><p><code>Canvas.scale(float sx, float sy, float px, float py)</code> 放缩</p></li>
<li><p><code>skew(float sx, float sy)</code> 错切</p></li>
</ul>


<h6>使用 Matrix 来做变换</h6>

<p>Matrix 做常见变换的方式：</p>

<ul>
<li>创建 Matrix 对象；</li>
<li>调用 Matrix 的 <code>pre/postTranslate/Rotate/Scale/Skew()</code> 方法来设置几何变换；</li>
<li>使用 <code>Canvas.setMatrix(matrix)</code> 或 <code>Canvas.concat(matrix)</code> 来把几何变换应用到 Canvas。</li>
</ul>


<p>把 Matrix 应用到 Canvas 有两个方法： <code>Canvas.setMatrix(matrix)</code> 和 <code>Canvas.concat(matrix)</code>。</p>

<ul>
<li><code>Canvas.setMatrix(matrix)</code>：用 Matrix 直接替换 Canvas 当前的变换矩阵，即抛弃 Canvas 当前的变换，改用 Matrix 的变换（注：根据下面评论里以及我在微信公众号中收到的反馈，不同的系统中 setMatrix(matrix) 的行为可能不一致，所以还是尽量用  concat(matrix) 吧）；</li>
<li><code>Canvas.concat(matrix)</code>：用 Canvas 当前的变换矩阵和 Matrix 相乘，即基于 Canvas 当前的变换，叠加上 Matrix 中的变换。</li>
</ul>


<p>使用 Matrix 来做自定义变换</p>

<ul>
<li><code>Matrix.setPolyToPoly(float[] src, int srcIndex, float[] dst, int dstIndex, int pointCount)</code> 用点对点映射的方式设置变换。poly 就是「多」的意思。setPolyToPoly() 的作用是通过多点的映射的方式来直接设置变换。「多点映射」的意思就是把指定的点移动到给出的位置，从而发生形变。例如：(0, 0) &ndash;> (100, 100) 表示把 (0, 0) 位置的像素移动到 (100, 100) 的位置，这个是单点的映射，单点映射可以实现平移。而多点的映射，就可以让绘制内容任意地扭曲。</li>
</ul>


<h6>使用 Camera 来做三维变换</h6>

<p>Camera 的三维变换有三类：旋转、平移、移动相机。</p>

<ul>
<li><p><code>Camera.rotate*()</code> 三维旋转 <code>Camera.rotate*()</code> 一共有四个方法： <code>rotateX(deg) rotateY(deg) rotateZ(deg) rotate(x, y, z)</code>。</p></li>
<li><p><code>Camera.translate(float x, float y, float z)</code> 移动</p></li>
<li><p><code>Camera.setLocation(x, y, z)</code> 设置虚拟相机的位置。在 Camera 中，相机的默认位置是 (0, 0, -8)（英寸）。8 x 72 = 576，所以它的默认位置是 (0, 0, -576)（像素）。</p></li>
</ul>


<h3>绘制顺序</h3>

<h5>super.onDraw() 前 or 后？</h5>

<h5><code>dispatchDraw()</code>：绘制子 View 的方法</h5>

<h5>绘制过程简述</h5>

<p>绘制过程中最典型的两个部分是上面讲到的主体和子 View，但它们并不是绘制过程的全部。除此之外，绘制过程还包含一些其他内容的绘制。具体来讲，一个完整的绘制过程会依次绘制以下几个内容：</p>

<ul>
<li>背景</li>
<li>主体（onDraw()）</li>
<li>子 View（dispatchDraw()）</li>
<li>滑动边缘渐变和滑动条</li>
<li>前景</li>
</ul>


<center><p><img src="http://Solarex.github.io/images/canvas-draw-process.jpg"/></p></center>


<h5>onDrawForeground()</h5>

<p>在 onDrawForeground() 中，会依次绘制滑动边缘渐变、滑动条和前景。</p>

<h5>draw() 总调度方法</h5>

<center><p><img src="http://Solarex.github.io/images/canvas-draw.jpg"/></p></center>


<p>关于绘制方法，有两点需要注意一下：</p>

<ul>
<li><p>出于效率的考虑，ViewGroup 默认会绕过 <code>draw()</code> 方法，换而直接执行  <code>dispatchDraw()</code>，以此来简化绘制流程。所以如果你自定义了某个 ViewGroup 的子类（比如 LinearLayout）并且需要在它的除 <code>dispatchDraw()</code> 以外的任何一个绘制方法内绘制内容，你可能会需要调用 <code>View.setWillNotDraw(false)</code> 这行代码来切换到完整的绘制流程（是「可能」而不是「必须」的原因是，有些 ViewGroup 是已经调用过  setWillNotDraw(false) 了的，例如 ScrollView）。</p></li>
<li><p>有的时候，一段绘制代码写在不同的绘制方法中效果是一样的，这时你可以选一个自己喜欢或者习惯的绘制方法来重写。但有一个例外：如果绘制代码既可以写在  <code>onDraw()</code> 里，也可以写在其他绘制方法里，那么优先写在 <code>onDraw()</code> ，因为 Android 有相关的优化，可以在不需要重绘的时候自动跳过 <code>onDraw()</code> 的重复执行，以提升开发效率。享受这种优化的只有 <code>onDraw()</code> 一个方法。</p></li>
</ul>


<h3>属性动画 Property Animation</h3>

<p> Android 里动画是有一些分类的：动画可以分为两类：Animation 和 Transition；其中 Animation 又可以再分为 View Animation 和 Property Animation 两类： View Animation 是纯粹基于 framework 的绘制转变，Property Animation，属性动画，这是在 Android 3.0 开始引入的新的动画形式。</p>

<p> ##### ViewPropertyAnimator</p>

<p> <center><p><img src="http://Solarex.github.io/images/view-animate.jpg"/></p></center></p>

<p> ##### ObjectAnimator</p>

<p>使用方式：</p>

<ul>
<li>如果是自定义控件，需要添加 setter / getter 方法；</li>
<li>用 ObjectAnimator.ofXXX() 创建 ObjectAnimator 对象；</li>
<li>用 start() 方法执行动画。</li>
</ul>


<h5>通用方法</h5>

<ul>
<li><p><code>setDuration(int duration)</code> 设置动画时长</p></li>
<li><p><code>setInterpolator(Interpolator interpolator)</code> 设置 Interpolator,<code>AccelerateDecelerateInterpolator</code>,<code>LinearInterpolator</code>,<code>AccelerateInterpolator</code>,<code>DecelerateInterpolator</code>,<code>AnticipateInterpolator</code>,<code>OvershootInterpolator</code>,<code>AnticipateOvershootInterpolator</code>,<code>BounceInterpolator</code>,<code>CycleInterpolator</code>,<code>PathInterpolator</code>,<code>FastOutLinearInInterpolator</code>,<code>FastOutSlowInInterpolator</code>,<code>LinearOutSlowInInterpolator</code></p></li>
</ul>


<h5>设置监听器</h5>

<p>设置监听器的方法， ViewPropertyAnimator 和 ObjectAnimator 略微不一样：  ViewPropertyAnimator 用的是 setListener() 和 setUpdateListener() 方法，可以设置一个监听器，要移除监听器时通过 set[Update]Listener(null) 填 null 值来移除；而  ObjectAnimator 则是用 addListener() 和 addUpdateListener() 来添加一个或多个监听器，移除监听器则是通过 remove[Update]Listener() 来指定移除对象。另外，由于 ObjectAnimator 支持使用 pause() 方法暂停，所以它还多了一个  addPauseListener() / removePauseListener() 的支持；而 ViewPropertyAnimator 则独有  withStartAction() 和 withEndAction() 方法，可以设置一次性的动画开始或结束的监听。</p>

<p>AnimatorListener 共有 4 个回调方法：</p>

<ul>
<li><p><code>onAnimationStart(Animator animation)</code></p></li>
<li><p><code>onAnimationEnd(Animator animation)</code></p></li>
<li><p><code>onAnimationCancel(Animator animation)</code></p></li>
<li><p><code>onAnimationRepeat(Animator animation)</code></p></li>
</ul>


<p><code>AnimatorUpdateListener</code>它只有一个回调方法：<code>onAnimationUpdate(ValueAnimator animation)</code></p>

<p><code>ViewPropertyAnimator.withStartAction/EndAction()</code>，<code>withStartAction() / withEndAction()</code> 是一次性的，在动画执行结束后就自动弃掉了，就算之后再重用 <code>ViewPropertyAnimator</code> 来做别的动画，用它们设置的回调也不会再被调用。而 <code>set/addListener()</code> 所设置的 <code>AnimatorListener</code> 是持续有效的，当动画重复执行时，回调总会被调用。<code>withEndAction()</code> 设置的回调只有在动画正常结束时才会被调用，而在动画被取消时不会被执行。这点和 <code>AnimatorListener.onAnimationEnd()</code> 的行为是不一致的。</p>

<h5>TypeEvaluator</h5>

<ul>
<li><p><code>ArgbEvaluator</code></p></li>
<li><p>自定义 Evaluator</p></li>
</ul>


<p>借助于 TypeEvaluator，属性动画就可以通过 ofObject() 来对不限定类型的属性做动画了。方式很简单：</p>

<ul>
<li><p>为目标属性写一个自定义的 TypeEvaluator</p></li>
<li><p>使用 ofObject() 来创建 Animator，并把自定义的 TypeEvaluator 作为参数填入</p></li>
</ul>


<h5>PropertyValuesHolder 同一个动画中改变多个属性</h5>

<h5>AnimatorSet 多个动画配合执行</h5>

<h5>PropertyValuesHolders.ofKeyframe() 把同一个属性拆分</h5>

<h3>硬件加速</h3>

<ul>
<li><p><a href="https://developer.android.google.cn/guide/topics/graphics/hardware-accel.html">Hardware Acceleration | Android Developers</a></p></li>
<li><p><a href="https://www.youtube.com/watch?v=v9S5EO7CLjo">Google I/O 2011: Accelerated Android Rendering</a></p></li>
</ul>


<p>所谓硬件加速，指的是把某些计算工作交给专门的硬件来做，而不是和普通的计算工作一样交给 CPU 来处理。这样不仅减轻了 CPU 的压力，而且由于有了「专人」的处理，这份计算工作的速度也被加快了。这就是「硬件加速」。</p>

<p>而对于 Android 来说，硬件加速有它专属的意思：在 Android 里，硬件加速专指把 View 中绘制的计算工作交给 GPU 来处理。进一步地再明确一下，这个「绘制的计算工作」指的就是把绘制方法中的那些 Canvas.drawXXX() 变成实际的像素这件事。</p>

<p>在硬件加速关闭的时候，Canvas 绘制的工作方式是：把要绘制的内容写进一个  Bitmap，然后在之后的渲染过程中，这个 Bitmap 的像素内容被直接用于渲染到屏幕。这种绘制方式的主要计算工作在于把绘制操作转换为像素的过程（例如由一句  Canvas.drawCircle() 来获得一个具体的圆的像素信息），这个过程的计算是由 CPU 来完成的。而在硬件加速开启时，Canvas 的工作方式改变了：它只是把绘制的内容转换为 GPU 的操作保存了下来，然后就把它交给 GPU，最终由 GPU 来完成实际的显示工作。</p>

<p>硬件加速不只是好处，也有它的限制：受到 GPU 绘制方式的限制，Canvas 的有些方法在硬件加速开启式会失效或无法正常工作。比如，在硬件加速开启时， clipPath() 在 API 18 及以上的系统中才有效。具体的 API 限制和 API 版本的关系如下图：</p>

<center><p><img src="http://Solarex.github.io/images/hardware-acceleration.jpg"></p></center>


<h5>View Layer</h5>

<p>setLayerType() 这个方法，它的作用其实就是名字里的意思：设置 View Layer 的类型。所谓 View Layer，又称为离屏缓冲（Off-screen Buffer），它的作用是单独启用一块地方来绘制这个 View ，而不是使用软件绘制的 Bitmap 或者通过硬件加速的 GPU。这块「地方」可能是一块单独的 Bitmap，也可能是一块 OpenGL 的纹理（texture，OpenGL 的纹理可以简单理解为图像的意思），具体取决于硬件加速是否开启。采用什么来绘制 View 不是关键，关键在于当设置了 View Layer 的时候，它的绘制会被缓存下来，而且缓存的是最终的绘制结果，而不是像硬件加速那样只是把 GPU 的操作保存下来再交给 GPU 去计算。通过这样更进一步的缓存方式，View 的重绘效率进一步提高了：只要绘制的内容没有变，那么不论是 CPU 绘制还是 GPU 绘制，它们都不用重新计算，而只要只用之前缓存的绘制结果就可以了。</p>

<p>基于这样的原理，在进行移动、旋转等（无需调用 invalidate()）的属性动画的时候开启 Hardware Layer 将会极大地提升动画的效率，因为在动画过程中 View 本身并没有发生改变，只是它的位置或角度改变了，而这种改变是可以由 GPU 通过简单计算就完成的，并不需要重绘整个 View。所以在这种动画的过程中开启 Hardware Layer，可以让本来就依靠硬件加速而变流畅了的动画变得更加流畅。</p>

<p>不过一定要注意，只有你在对 translationX translationY rotation alpha 等无需调用  invalidate() 的属性做动画的时候，这种方法才适用，因为这种方法本身利用的就是当界面不发生时，缓存未更新所带来的时间的节省。所以简单地说——这种方式不适用于基于自定义属性绘制的动画。</p>

<p>另外，由于设置了 View Layer 后，View 在初次绘制时以及每次 invalidate() 后重绘时，需要进行两次的绘制工作（一次绘制到 Layer，一次从 Layer 绘制到显示屏），所以其实它的每次绘制的效率是被降低了的。所以一定要慎重使用 View Layer，在需要用到它的时候再去使用。</p>

<h3>reference</h3>

<ul>
<li><a href="https://github.com/xinghongfei/awesome-view">awesome-view</a></li>
<li><a href="https://github.com/GcsSloop/AndroidNote/tree/master/CustomView">GcsSloop CustomView</a></li>
<li><a href="https://blog.csdn.net/aigestudio/column/info/androidcustomview">Android自定义控件其实很简单</a></li>
<li><a href="https://hencoder.com/tag/hui-zhi/">自定义View-绘制</a></li>
</ul>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[RecyclerView平滑滑动到指定位置]]></title>
    <link href="http://Solarex.github.io/blog/2018/05/30/recyclerview-smooth-scoll-to-position/"/>
    <updated>2018-05-30T14:33:00+08:00</updated>
    <id>http://Solarex.github.io/blog/2018/05/30/recyclerview-smooth-scoll-to-position</id>
    <content type="html"><![CDATA[<p>最近在做一个周日历的新需求，其中有个要求是要RecyclerView平滑的滑动到指定位置，刚开始的时候我以为只要调用<code>smoothScrollToPosition</code>这个方法就可以了，测试的时候发现，<code>smoothScrollToPosition</code>只会对不可见的item有效，对于已经可见的item滑动没有效果，于是翻看了一下<code>smoothScrollToPosition</code>的源码，发现是调用了<code>LayoutManger</code>的<code>smoothScrollToPosition</code>方法。</p>

<!-- more -->


<p>```java
// LinearLayoutManager</p>

<pre><code>@Override
public void smoothScrollToPosition(RecyclerView recyclerView, RecyclerView.State state,
        int position) {
    LinearSmoothScroller linearSmoothScroller =
            new LinearSmoothScroller(recyclerView.getContext());
    linearSmoothScroller.setTargetPosition(position);
    startSmoothScroll(linearSmoothScroller);
}
</code></pre>

<p>```</p>

<p>发现其实是实例化了一个<code>LinearSmoothScroller</code>，然后调用<code>startSmoothScroll</code>将<code>LinearSmoothScroller</code>传入进去。在<a href="https://stackoverflow.com/questions/31235183/recyclerview-how-to-smooth-scroll-to-top-of-item-on-a-certain-position/32819067">StackOverflow</a>上看到一个回答，复写了<code>getVerticalSnapPreference</code>方法，返回<code>SNAP_START</code>，由于我的<code>RecyclerView</code>是水平滑动的，于是复写了<code>getHorizontalSnapPreference</code>返回<code>SNAP_START</code>，测试发现对可见的item也有滑动效果了，可是会有闪烁的现象。</p>

<p>继续看<code>LinearSmoothScroller</code>源码，发现有<code>calculateSpeedPerPixel</code>方法，默认是用<code>25</code>去计算，复写这个方法，换一个大点的数去计算，发现滑动的速度慢下来了，闪烁的现象消失了。具体的代码可以参考<a href="https://github.com/flyfire/WeeklyCalendarViewDemo/blob/master/weeklycalendarview/src/main/java/com/solarexsoft/weeklycalendarview/WeeklyCalendarView.java">WeeklyCalendarView</a>。</p>

<p>问题虽然解决了，但是<code>RecyclerView</code>与各个插件的协同工作机制，<code>LayoutManager</code>,<code>SmoothScroller</code>原理没来的及分析，这个留待以后分析。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Java代理]]></title>
    <link href="http://Solarex.github.io/blog/2018/04/26/java-proxy/"/>
    <updated>2018-04-26T10:07:00+08:00</updated>
    <id>http://Solarex.github.io/blog/2018/04/26/java-proxy</id>
    <content type="html"><![CDATA[<p>Java代理有静态代理和动态代理之分。</p>

<h4>静态代理</h4>

<p>静态代理类图如下：</p>

<p><center><img src="http://Solarex.github.io/images/java-proxy-static.png" width=225 height=225/></center></p>


<p><code>ProxyObject</code>持有<code>RealObject</code>的引用，在<code>someOperation</code>方法中可以代理<code>RealObject</code>做操作。</p>

<!-- more -->


<h4>动态代理</h4>

<p>动态代理有Java的InvocationHandler实现方式和CGLib实现方式，我没用过CGLib，这里只讨论<code>InvocationHandler</code>实现方式。主要有三个步骤，代码示例可以在<a href="https://github.com/flyfire/YouDontKnowJava/tree/master/src/com/solarexsoft/test/proxy">github</a>上面看</p>

<ul>
<li>定义一个interface</li>
<li>定义一个InvocationHandler实现类，将要代理的对象传入InvocationHandler中，也即让InvocationHandler实现类代理传入的对象</li>
<li>调用Proxy.newProxyInstance</li>
</ul>


<p>动态代理的秘密主要是藏在<code>Proxy.newProxyInstance</code>当中</p>

<p>```java
public static Object newProxyInstance(ClassLoader loader,Class&lt;?>[] interfaces,InvocationHandler h) throws IllegalArgumentException
{</p>

<pre><code>...
    /*
     * Look up or generate the designated proxy class.
     */
    Class&lt;?&gt; cl = getProxyClass0(loader, intfs);
    final Constructor&lt;?&gt; cons = cl.getConstructor(constructorParams);
    final InvocationHandler ih = h;
    return cons.newInstance(new Object[]{h});
</code></pre>

<p>}
```</p>

<p>可以看出它先调用<code>getProxyClass(loader, interfaces)</code>得到动态代理类，然后将<code>InvocationHandler</code>作为代理类构造函数入参新建代理类对象。</p>

<p>```java</p>

<pre><code>/**
 * Returns the {@code java.lang.Class} object for a proxy class
 * given a class loader and an array of interfaces.  The proxy class
 * will be defined by the specified class loader and will implement
 * all of the supplied interfaces.  If any of the given interfaces
 * is non-public, the proxy class will be non-public. If a proxy class
 * for the same permutation of interfaces has already been defined by the
 * class loader, then the existing proxy class will be returned; otherwise,
 * a proxy class for those interfaces will be generated dynamically
 * and defined by the class loader.
 *
 * &lt;p&gt;There are several restrictions on the parameters that may be
 * passed to {@code Proxy.getProxyClass}:
 *
 * &lt;ul&gt;
 * &lt;li&gt;All of the {@code Class} objects in the
 * {@code interfaces} array must represent interfaces, not
 * classes or primitive types.
 *
 * &lt;li&gt;No two elements in the {@code interfaces} array may
 * refer to identical {@code Class} objects.
 *
 * &lt;li&gt;All of the interface types must be visible by name through the
 * specified class loader.  In other words, for class loader
 * {@code cl} and every interface {@code i}, the following
 * expression must be true:
 * &lt;pre&gt;
 *     Class.forName(i.getName(), false, cl) == i
 * &lt;/pre&gt;
 *
 * &lt;li&gt;All non-public interfaces must be in the same package;
 * otherwise, it would not be possible for the proxy class to
 * implement all of the interfaces, regardless of what package it is
 * defined in.
 *
 * &lt;li&gt;For any set of member methods of the specified interfaces
 * that have the same signature:
 * &lt;ul&gt;
 * &lt;li&gt;If the return type of any of the methods is a primitive
 * type or void, then all of the methods must have that same
 * return type.
 * &lt;li&gt;Otherwise, one of the methods must have a return type that
 * is assignable to all of the return types of the rest of the
 * methods.
 * &lt;/ul&gt;
 *
 * &lt;li&gt;The resulting proxy class must not exceed any limits imposed
 * on classes by the virtual machine.  For example, the VM may limit
 * the number of interfaces that a class may implement to 65535; in
 * that case, the size of the {@code interfaces} array must not
 * exceed 65535.
 * &lt;/ul&gt;
 *
 * &lt;p&gt;If any of these restrictions are violated,
 * {@code Proxy.getProxyClass} will throw an
 * {@code IllegalArgumentException}.  If the {@code interfaces}
 * array argument or any of its elements are {@code null}, a
 * {@code NullPointerException} will be thrown.
 *
 * &lt;p&gt;Note that the order of the specified proxy interfaces is
 * significant: two requests for a proxy class with the same combination
 * of interfaces but in a different order will result in two distinct
 * proxy classes.
 *
 */
</code></pre>

<p>/<em>*
 * 得到代理类，不存在则动态生成
 * @param loader 代理类所属 ClassLoader
 * @param interfaces 代理类需要实现的接口
 * @return
 </em>/
public static Class&lt;?> getProxyClass(ClassLoader loader,</p>

<pre><code>                                 Class&lt;?&gt;... interfaces)
throws IllegalArgumentException
</code></pre>

<p>{</p>

<pre><code>if (interfaces.length &gt; 65535) {
    throw new IllegalArgumentException("interface limit exceeded");
}
// 代理类类对象
Class proxyClass = null;

/* collect interface names to use as key for proxy class cache */
String[] interfaceNames = new String[interfaces.length];

Set interfaceSet = new HashSet();       // for detecting duplicates

/**
 * 入参 interfaces 检验，包含三部分
 * （1）是否在入参指定的 ClassLoader 内
 * （2）是否是 Interface
 * （3）interfaces 中是否有重复
 */
for (int i = 0; i &lt; interfaces.length; i++) {
    String interfaceName = interfaces[i].getName();
    Class interfaceClass = null;
    try {
        interfaceClass = Class.forName(interfaceName, false, loader);
    } catch (ClassNotFoundException e) {
    }
    if (interfaceClass != interfaces[i]) {
        throw new IllegalArgumentException(
            interfaces[i] + " is not visible from class loader");
    }

    if (!interfaceClass.isInterface()) {
        throw new IllegalArgumentException(
            interfaceClass.getName() + " is not an interface");
    }

    if (interfaceSet.contains(interfaceClass)) {
        throw new IllegalArgumentException(
            "repeated interface: " + interfaceClass.getName());
    }
    interfaceSet.add(interfaceClass);

    interfaceNames[i] = interfaceName;
}

// 以接口名对应的 List 作为缓存的 key
Object key = Arrays.asList(interfaceNames);

/*
 * loaderToCache 是个双层的 Map
 * 第一层 key 为 ClassLoader，第二层 key 为 上面的 List，value 为代理类的弱引用
 */
Map cache;
synchronized (loaderToCache) {
    cache = (Map) loaderToCache.get(loader);
    if (cache == null) {
        cache = new HashMap();
        loaderToCache.put(loader, cache);
    }
}

/*
 * 以上面的接口名对应的 List 为 key 查找代理类，如果结果为：
 * (1) 弱引用，表示代理类已经在缓存中
 * (2) pendingGenerationMarker 对象，表示代理类正在生成中，等待生成完成通知。
 * (3) null 表示不在缓存中且没有开始生成，添加标记到缓存中，继续生成代理类
 */
synchronized (cache) {
    do {
        Object value = cache.get(key);
        if (value instanceof Reference) {
            proxyClass = (Class) ((Reference) value).get();
        }
        if (proxyClass != null) {
            // proxy class already generated: return it
            return proxyClass;
        } else if (value == pendingGenerationMarker) {
            // proxy class being generated: wait for it
            try {
                cache.wait();
            } catch (InterruptedException e) {
            }
            continue;
        } else {
            cache.put(key, pendingGenerationMarker);
            break;
        }
    } while (true);
}

try {
    String proxyPkg = null;     // package to define proxy class in

    /*
     * 如果 interfaces 中存在非 public 的接口，则所有非 public 接口必须在同一包下面，后续生成的代理类也会在该包下面
     */
    for (int i = 0; i &lt; interfaces.length; i++) {
        int flags = interfaces[i].getModifiers();
        if (!Modifier.isPublic(flags)) {
            String name = interfaces[i].getName();
            int n = name.lastIndexOf('.');
            String pkg = ((n == -1) ? "" : name.substring(0, n + 1));
            if (proxyPkg == null) {
                proxyPkg = pkg;
            } else if (!pkg.equals(proxyPkg)) {
                throw new IllegalArgumentException(
                    "non-public interfaces from different packages");
            }
        }
    }

    if (proxyPkg == null) {     // if no non-public proxy interfaces,
        proxyPkg = "";          // use the unnamed package
    }

    {
        // 得到代理类的类名，jdk 1.6 版本中缺少对这个生成类已经存在的处理。
        long num;
        synchronized (nextUniqueNumberLock) {
            num = nextUniqueNumber++;
        }
        String proxyName = proxyPkg + proxyClassNamePrefix + num;

        // 动态生成代理类的字节码
        // 最终调用 sun.misc.ProxyGenerator.generateClassFile() 得到代理类相关信息写入 DataOutputStream 实现
        byte[] proxyClassFile = ProxyGenerator.generateProxyClass(
            proxyName, interfaces);
        try {
            // native 层实现，虚拟机加载代理类并返回其类对象
            proxyClass = defineClass0(loader, proxyName,
                proxyClassFile, 0, proxyClassFile.length);
        } catch (ClassFormatError e) {
            throw new IllegalArgumentException(e.toString());
        }
    }
    // add to set of all generated proxy classes, for isProxyClass
    proxyClasses.put(proxyClass, null);

} finally {
    // 代理类生成成功则保存到缓存，否则从缓存中删除，然后通知等待的调用
    synchronized (cache) {
        if (proxyClass != null) {
            cache.put(key, new WeakReference(proxyClass));
        } else {
            cache.remove(key);
        }
        cache.notifyAll();
    }
}
return proxyClass;
</code></pre>

<p>}</p>

<p>```</p>

<p>函数主要包括三部分：</p>

<ul>
<li>入参 interfaces 检验，包含是否在入参指定的 ClassLoader 内、是否是 Interface、interfaces 中是否有重复
以接口名对应的 List 为 key 查找代理类，如果结果为：

<ul>
<li>弱引用，表示代理类已经在缓存中；</li>
<li>pendingGenerationMarker 对象，表示代理类正在生成中，等待生成完成返回；</li>
<li>null 表示不在缓存中且没有开始生成，添加标记到缓存中，继续生成代理类。</li>
</ul>
</li>
<li>如果代理类不存在调用ProxyGenerator.generateProxyClass(…)生成代理类并存入缓存，通知在等待的缓存。</li>
</ul>


<p>函数中几个注意的地方：</p>

<ul>
<li>代理类的缓存 key 为接口名对应的 List，接口顺序不同表示不同的 key 即不同的代理类。</li>
<li>如果 interfaces 中存在非 public 的接口，则所有非 public 接口必须在同一包下面，后续生成的代理类也会在该包下面。</li>
<li>代理类如果在 ClassLoader 中已经存在的情况没有做处理。</li>
</ul>


<p>可以开启 System Properties 的<code>sun.misc.ProxyGenerator.saveGeneratedFiles</code>开关，保存动态类到目的地址。</p>

<p>Java 1.7 的实现略有不同，通过<code>getProxyClass0(…)</code>函数实现，实现中调用代理类的缓存，判断代理类在缓存中是否已经存在，存在直接返回，不存在则调用proxyClassCache的valueFactory属性进行动态生成，valueFactory的apply函数与上面的<code>getProxyClass(…)</code>函数逻辑类似。</p>

<p>```
import java.lang.reflect.InvocationHandler;
import java.lang.reflect.Method;
import java.lang.reflect.Proxy;
import java.lang.reflect.UndeclaredThrowableException;</p>

<p>public final class $Proxy0 extends Proxy
  implements Operate
{
  private static Method m4;
  private static Method m1;
  private static Method m5;
  private static Method m0;
  private static Method m3;
  private static Method m2;</p>

<p>  public $Proxy0(InvocationHandler paramInvocationHandler)</p>

<pre><code>throws 
</code></pre>

<p>  {</p>

<pre><code>super(paramInvocationHandler);
</code></pre>

<p>  }</p>

<p>  public final void operateMethod1()</p>

<pre><code>throws 
</code></pre>

<p>  {</p>

<pre><code>try
{
  h.invoke(this, m4, null);
  return;
}
catch (Error|RuntimeException localError)
{
  throw localError;
}
catch (Throwable localThrowable)
{
  throw new UndeclaredThrowableException(localThrowable);
}
</code></pre>

<p>  }</p>

<p>  public final boolean equals(Object paramObject)</p>

<pre><code>throws 
</code></pre>

<p>  {</p>

<pre><code>try
{
  return ((Boolean)h.invoke(this, m1, new Object[] { paramObject })).booleanValue();
}
catch (Error|RuntimeException localError)
{
  throw localError;
}
catch (Throwable localThrowable)
{
  throw new UndeclaredThrowableException(localThrowable);
}
</code></pre>

<p>  }</p>

<p>  public final void operateMethod2()</p>

<pre><code>throws 
</code></pre>

<p>  {</p>

<pre><code>try
{
  h.invoke(this, m5, null);
  return;
}
catch (Error|RuntimeException localError)
{
  throw localError;
}
catch (Throwable localThrowable)
{
  throw new UndeclaredThrowableException(localThrowable);
}
</code></pre>

<p>  }</p>

<p>  public final int hashCode()</p>

<pre><code>throws 
</code></pre>

<p>  {</p>

<pre><code>try
{
  return ((Integer)h.invoke(this, m0, null)).intValue();
}
catch (Error|RuntimeException localError)
{
  throw localError;
}
catch (Throwable localThrowable)
{
  throw new UndeclaredThrowableException(localThrowable);
}
</code></pre>

<p>  }</p>

<p>  public final void operateMethod3()</p>

<pre><code>throws 
</code></pre>

<p>  {</p>

<pre><code>try
{
  h.invoke(this, m3, null);
  return;
}
catch (Error|RuntimeException localError)
{
  throw localError;
}
catch (Throwable localThrowable)
{
  throw new UndeclaredThrowableException(localThrowable);
}
</code></pre>

<p>  }</p>

<p>  public final String toString()</p>

<pre><code>throws 
</code></pre>

<p>  {</p>

<pre><code>try
{
  return (String)h.invoke(this, m2, null);
}
catch (Error|RuntimeException localError)
{
  throw localError;
}
catch (Throwable localThrowable)
{
  throw new UndeclaredThrowableException(localThrowable);
}
</code></pre>

<p>  }</p>

<p>  static
  {</p>

<pre><code>try
{
  m4 = Class.forName("com.codekk.java.test.dynamicproxy.Operate").getMethod("operateMethod1", new Class[0]);
  m1 = Class.forName("java.lang.Object").getMethod("equals", new Class[] { Class.forName("java.lang.Object") });
  m5 = Class.forName("com.codekk.java.test.dynamicproxy.Operate").getMethod("operateMethod2", new Class[0]);
  m0 = Class.forName("java.lang.Object").getMethod("hashCode", new Class[0]);
  m3 = Class.forName("com.codekk.java.test.dynamicproxy.Operate").getMethod("operateMethod3", new Class[0]);
  m2 = Class.forName("java.lang.Object").getMethod("toString", new Class[0]);
  return;
}
catch (NoSuchMethodException localNoSuchMethodException)
{
  throw new NoSuchMethodError(localNoSuchMethodException.getMessage());
}
catch (ClassNotFoundException localClassNotFoundException)
{
  throw new NoClassDefFoundError(localClassNotFoundException.getMessage());
}
</code></pre>

<p>  }
}
```</p>

<p>可以看到实际上在底层生成了一个class的字节流，并且被ClassLoader加载了，生成了一个继承<code>Proxy</code>实现了接口的类，这个类以<code>InvocationHandler</code>为构造函数参数，所以实际上是在调用方法时，生成的<code>$Proxy0</code>对象代理了<code>InvocationHandler</code>实现对象，<code>InvocationHandler</code>对象代理了实际的对象。</p>
]]></content>
  </entry>
  
</feed>
