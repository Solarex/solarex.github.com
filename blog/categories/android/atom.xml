<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: android | Solarex's Blog]]></title>
  <link href="http://Solarex.github.io/blog/categories/android/atom.xml" rel="self"/>
  <link href="http://Solarex.github.io/"/>
  <updated>2019-03-29T20:52:21+08:00</updated>
  <id>http://Solarex.github.io/</id>
  <author>
    <name><![CDATA[Solarex]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[RecyclerView平滑滑动到指定位置]]></title>
    <link href="http://Solarex.github.io/blog/2018/05/30/recyclerview-smooth-scoll-to-position/"/>
    <updated>2018-05-30T14:33:00+08:00</updated>
    <id>http://Solarex.github.io/blog/2018/05/30/recyclerview-smooth-scoll-to-position</id>
    <content type="html"><![CDATA[<p>最近在做一个周日历的新需求，其中有个要求是要RecyclerView平滑的滑动到指定位置，刚开始的时候我以为只要调用<code>smoothScrollToPosition</code>这个方法就可以了，测试的时候发现，<code>smoothScrollToPosition</code>只会对不可见的item有效，对于已经可见的item滑动没有效果，于是翻看了一下<code>smoothScrollToPosition</code>的源码，发现是调用了<code>LayoutManger</code>的<code>smoothScrollToPosition</code>方法。</p>

<!-- more -->


<p>```java
// LinearLayoutManager</p>

<pre><code>@Override
public void smoothScrollToPosition(RecyclerView recyclerView, RecyclerView.State state,
        int position) {
    LinearSmoothScroller linearSmoothScroller =
            new LinearSmoothScroller(recyclerView.getContext());
    linearSmoothScroller.setTargetPosition(position);
    startSmoothScroll(linearSmoothScroller);
}
</code></pre>

<p>```</p>

<p>发现其实是实例化了一个<code>LinearSmoothScroller</code>，然后调用<code>startSmoothScroll</code>将<code>LinearSmoothScroller</code>传入进去。在<a href="https://stackoverflow.com/questions/31235183/recyclerview-how-to-smooth-scroll-to-top-of-item-on-a-certain-position/32819067">StackOverflow</a>上看到一个回答，复写了<code>getVerticalSnapPreference</code>方法，返回<code>SNAP_START</code>，由于我的<code>RecyclerView</code>是水平滑动的，于是复写了<code>getHorizontalSnapPreference</code>返回<code>SNAP_START</code>，测试发现对可见的item也有滑动效果了，可是会有闪烁的现象。</p>

<p>继续看<code>LinearSmoothScroller</code>源码，发现有<code>calculateSpeedPerPixel</code>方法，默认是用<code>25</code>去计算，复写这个方法，换一个大点的数去计算，发现滑动的速度慢下来了，闪烁的现象消失了。具体的代码可以参考<a href="https://github.com/flyfire/WeeklyCalendarViewDemo/blob/master/weeklycalendarview/src/main/java/com/solarexsoft/weeklycalendarview/WeeklyCalendarView.java">WeeklyCalendarView</a>。</p>

<p>问题虽然解决了，但是<code>RecyclerView</code>与各个插件的协同工作机制，<code>LayoutManager</code>,<code>SmoothScroller</code>原理没来的及分析，这个留待以后分析。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Java代理]]></title>
    <link href="http://Solarex.github.io/blog/2018/04/26/java-proxy/"/>
    <updated>2018-04-26T10:07:00+08:00</updated>
    <id>http://Solarex.github.io/blog/2018/04/26/java-proxy</id>
    <content type="html"><![CDATA[<p>Java代理有静态代理和动态代理之分。</p>

<h4>静态代理</h4>

<p>静态代理类图如下：</p>

<p><center><img src="http://Solarex.github.io/images/java-proxy-static.png" width=225 height=225/></center></p>


<p><code>ProxyObject</code>持有<code>RealObject</code>的引用，在<code>someOperation</code>方法中可以代理<code>RealObject</code>做操作。</p>

<!-- more -->


<h4>动态代理</h4>

<p>动态代理有Java的InvocationHandler实现方式和CGLib实现方式，我没用过CGLib，这里只讨论<code>InvocationHandler</code>实现方式。主要有三个步骤，代码示例可以在<a href="https://github.com/flyfire/YouDontKnowJava/tree/master/src/com/solarexsoft/test/proxy">github</a>上面看</p>

<ul>
<li>定义一个interface</li>
<li>定义一个InvocationHandler实现类，将要代理的对象传入InvocationHandler中，也即让InvocationHandler实现类代理传入的对象</li>
<li>调用Proxy.newProxyInstance</li>
</ul>


<p>动态代理的秘密主要是藏在<code>Proxy.newProxyInstance</code>当中</p>

<p>```java
public static Object newProxyInstance(ClassLoader loader,Class&lt;?>[] interfaces,InvocationHandler h) throws IllegalArgumentException
{</p>

<pre><code>...
    /*
     * Look up or generate the designated proxy class.
     */
    Class&lt;?&gt; cl = getProxyClass0(loader, intfs);
    final Constructor&lt;?&gt; cons = cl.getConstructor(constructorParams);
    final InvocationHandler ih = h;
    return cons.newInstance(new Object[]{h});
</code></pre>

<p>}
```</p>

<p>可以看出它先调用<code>getProxyClass(loader, interfaces)</code>得到动态代理类，然后将<code>InvocationHandler</code>作为代理类构造函数入参新建代理类对象。</p>

<p>```java</p>

<pre><code>/**
 * Returns the {@code java.lang.Class} object for a proxy class
 * given a class loader and an array of interfaces.  The proxy class
 * will be defined by the specified class loader and will implement
 * all of the supplied interfaces.  If any of the given interfaces
 * is non-public, the proxy class will be non-public. If a proxy class
 * for the same permutation of interfaces has already been defined by the
 * class loader, then the existing proxy class will be returned; otherwise,
 * a proxy class for those interfaces will be generated dynamically
 * and defined by the class loader.
 *
 * &lt;p&gt;There are several restrictions on the parameters that may be
 * passed to {@code Proxy.getProxyClass}:
 *
 * &lt;ul&gt;
 * &lt;li&gt;All of the {@code Class} objects in the
 * {@code interfaces} array must represent interfaces, not
 * classes or primitive types.
 *
 * &lt;li&gt;No two elements in the {@code interfaces} array may
 * refer to identical {@code Class} objects.
 *
 * &lt;li&gt;All of the interface types must be visible by name through the
 * specified class loader.  In other words, for class loader
 * {@code cl} and every interface {@code i}, the following
 * expression must be true:
 * &lt;pre&gt;
 *     Class.forName(i.getName(), false, cl) == i
 * &lt;/pre&gt;
 *
 * &lt;li&gt;All non-public interfaces must be in the same package;
 * otherwise, it would not be possible for the proxy class to
 * implement all of the interfaces, regardless of what package it is
 * defined in.
 *
 * &lt;li&gt;For any set of member methods of the specified interfaces
 * that have the same signature:
 * &lt;ul&gt;
 * &lt;li&gt;If the return type of any of the methods is a primitive
 * type or void, then all of the methods must have that same
 * return type.
 * &lt;li&gt;Otherwise, one of the methods must have a return type that
 * is assignable to all of the return types of the rest of the
 * methods.
 * &lt;/ul&gt;
 *
 * &lt;li&gt;The resulting proxy class must not exceed any limits imposed
 * on classes by the virtual machine.  For example, the VM may limit
 * the number of interfaces that a class may implement to 65535; in
 * that case, the size of the {@code interfaces} array must not
 * exceed 65535.
 * &lt;/ul&gt;
 *
 * &lt;p&gt;If any of these restrictions are violated,
 * {@code Proxy.getProxyClass} will throw an
 * {@code IllegalArgumentException}.  If the {@code interfaces}
 * array argument or any of its elements are {@code null}, a
 * {@code NullPointerException} will be thrown.
 *
 * &lt;p&gt;Note that the order of the specified proxy interfaces is
 * significant: two requests for a proxy class with the same combination
 * of interfaces but in a different order will result in two distinct
 * proxy classes.
 *
 */
</code></pre>

<p>/<em>*
 * 得到代理类，不存在则动态生成
 * @param loader 代理类所属 ClassLoader
 * @param interfaces 代理类需要实现的接口
 * @return
 </em>/
public static Class&lt;?> getProxyClass(ClassLoader loader,</p>

<pre><code>                                 Class&lt;?&gt;... interfaces)
throws IllegalArgumentException
</code></pre>

<p>{</p>

<pre><code>if (interfaces.length &gt; 65535) {
    throw new IllegalArgumentException("interface limit exceeded");
}
// 代理类类对象
Class proxyClass = null;

/* collect interface names to use as key for proxy class cache */
String[] interfaceNames = new String[interfaces.length];

Set interfaceSet = new HashSet();       // for detecting duplicates

/**
 * 入参 interfaces 检验，包含三部分
 * （1）是否在入参指定的 ClassLoader 内
 * （2）是否是 Interface
 * （3）interfaces 中是否有重复
 */
for (int i = 0; i &lt; interfaces.length; i++) {
    String interfaceName = interfaces[i].getName();
    Class interfaceClass = null;
    try {
        interfaceClass = Class.forName(interfaceName, false, loader);
    } catch (ClassNotFoundException e) {
    }
    if (interfaceClass != interfaces[i]) {
        throw new IllegalArgumentException(
            interfaces[i] + " is not visible from class loader");
    }

    if (!interfaceClass.isInterface()) {
        throw new IllegalArgumentException(
            interfaceClass.getName() + " is not an interface");
    }

    if (interfaceSet.contains(interfaceClass)) {
        throw new IllegalArgumentException(
            "repeated interface: " + interfaceClass.getName());
    }
    interfaceSet.add(interfaceClass);

    interfaceNames[i] = interfaceName;
}

// 以接口名对应的 List 作为缓存的 key
Object key = Arrays.asList(interfaceNames);

/*
 * loaderToCache 是个双层的 Map
 * 第一层 key 为 ClassLoader，第二层 key 为 上面的 List，value 为代理类的弱引用
 */
Map cache;
synchronized (loaderToCache) {
    cache = (Map) loaderToCache.get(loader);
    if (cache == null) {
        cache = new HashMap();
        loaderToCache.put(loader, cache);
    }
}

/*
 * 以上面的接口名对应的 List 为 key 查找代理类，如果结果为：
 * (1) 弱引用，表示代理类已经在缓存中
 * (2) pendingGenerationMarker 对象，表示代理类正在生成中，等待生成完成通知。
 * (3) null 表示不在缓存中且没有开始生成，添加标记到缓存中，继续生成代理类
 */
synchronized (cache) {
    do {
        Object value = cache.get(key);
        if (value instanceof Reference) {
            proxyClass = (Class) ((Reference) value).get();
        }
        if (proxyClass != null) {
            // proxy class already generated: return it
            return proxyClass;
        } else if (value == pendingGenerationMarker) {
            // proxy class being generated: wait for it
            try {
                cache.wait();
            } catch (InterruptedException e) {
            }
            continue;
        } else {
            cache.put(key, pendingGenerationMarker);
            break;
        }
    } while (true);
}

try {
    String proxyPkg = null;     // package to define proxy class in

    /*
     * 如果 interfaces 中存在非 public 的接口，则所有非 public 接口必须在同一包下面，后续生成的代理类也会在该包下面
     */
    for (int i = 0; i &lt; interfaces.length; i++) {
        int flags = interfaces[i].getModifiers();
        if (!Modifier.isPublic(flags)) {
            String name = interfaces[i].getName();
            int n = name.lastIndexOf('.');
            String pkg = ((n == -1) ? "" : name.substring(0, n + 1));
            if (proxyPkg == null) {
                proxyPkg = pkg;
            } else if (!pkg.equals(proxyPkg)) {
                throw new IllegalArgumentException(
                    "non-public interfaces from different packages");
            }
        }
    }

    if (proxyPkg == null) {     // if no non-public proxy interfaces,
        proxyPkg = "";          // use the unnamed package
    }

    {
        // 得到代理类的类名，jdk 1.6 版本中缺少对这个生成类已经存在的处理。
        long num;
        synchronized (nextUniqueNumberLock) {
            num = nextUniqueNumber++;
        }
        String proxyName = proxyPkg + proxyClassNamePrefix + num;

        // 动态生成代理类的字节码
        // 最终调用 sun.misc.ProxyGenerator.generateClassFile() 得到代理类相关信息写入 DataOutputStream 实现
        byte[] proxyClassFile = ProxyGenerator.generateProxyClass(
            proxyName, interfaces);
        try {
            // native 层实现，虚拟机加载代理类并返回其类对象
            proxyClass = defineClass0(loader, proxyName,
                proxyClassFile, 0, proxyClassFile.length);
        } catch (ClassFormatError e) {
            throw new IllegalArgumentException(e.toString());
        }
    }
    // add to set of all generated proxy classes, for isProxyClass
    proxyClasses.put(proxyClass, null);

} finally {
    // 代理类生成成功则保存到缓存，否则从缓存中删除，然后通知等待的调用
    synchronized (cache) {
        if (proxyClass != null) {
            cache.put(key, new WeakReference(proxyClass));
        } else {
            cache.remove(key);
        }
        cache.notifyAll();
    }
}
return proxyClass;
</code></pre>

<p>}</p>

<p>```</p>

<p>函数主要包括三部分：</p>

<ul>
<li>入参 interfaces 检验，包含是否在入参指定的 ClassLoader 内、是否是 Interface、interfaces 中是否有重复
以接口名对应的 List 为 key 查找代理类，如果结果为：

<ul>
<li>弱引用，表示代理类已经在缓存中；</li>
<li>pendingGenerationMarker 对象，表示代理类正在生成中，等待生成完成返回；</li>
<li>null 表示不在缓存中且没有开始生成，添加标记到缓存中，继续生成代理类。</li>
</ul>
</li>
<li>如果代理类不存在调用ProxyGenerator.generateProxyClass(…)生成代理类并存入缓存，通知在等待的缓存。</li>
</ul>


<p>函数中几个注意的地方：</p>

<ul>
<li>代理类的缓存 key 为接口名对应的 List，接口顺序不同表示不同的 key 即不同的代理类。</li>
<li>如果 interfaces 中存在非 public 的接口，则所有非 public 接口必须在同一包下面，后续生成的代理类也会在该包下面。</li>
<li>代理类如果在 ClassLoader 中已经存在的情况没有做处理。</li>
</ul>


<p>可以开启 System Properties 的<code>sun.misc.ProxyGenerator.saveGeneratedFiles</code>开关，保存动态类到目的地址。</p>

<p>Java 1.7 的实现略有不同，通过<code>getProxyClass0(…)</code>函数实现，实现中调用代理类的缓存，判断代理类在缓存中是否已经存在，存在直接返回，不存在则调用proxyClassCache的valueFactory属性进行动态生成，valueFactory的apply函数与上面的<code>getProxyClass(…)</code>函数逻辑类似。</p>

<p>```
import java.lang.reflect.InvocationHandler;
import java.lang.reflect.Method;
import java.lang.reflect.Proxy;
import java.lang.reflect.UndeclaredThrowableException;</p>

<p>public final class $Proxy0 extends Proxy
  implements Operate
{
  private static Method m4;
  private static Method m1;
  private static Method m5;
  private static Method m0;
  private static Method m3;
  private static Method m2;</p>

<p>  public $Proxy0(InvocationHandler paramInvocationHandler)</p>

<pre><code>throws 
</code></pre>

<p>  {</p>

<pre><code>super(paramInvocationHandler);
</code></pre>

<p>  }</p>

<p>  public final void operateMethod1()</p>

<pre><code>throws 
</code></pre>

<p>  {</p>

<pre><code>try
{
  h.invoke(this, m4, null);
  return;
}
catch (Error|RuntimeException localError)
{
  throw localError;
}
catch (Throwable localThrowable)
{
  throw new UndeclaredThrowableException(localThrowable);
}
</code></pre>

<p>  }</p>

<p>  public final boolean equals(Object paramObject)</p>

<pre><code>throws 
</code></pre>

<p>  {</p>

<pre><code>try
{
  return ((Boolean)h.invoke(this, m1, new Object[] { paramObject })).booleanValue();
}
catch (Error|RuntimeException localError)
{
  throw localError;
}
catch (Throwable localThrowable)
{
  throw new UndeclaredThrowableException(localThrowable);
}
</code></pre>

<p>  }</p>

<p>  public final void operateMethod2()</p>

<pre><code>throws 
</code></pre>

<p>  {</p>

<pre><code>try
{
  h.invoke(this, m5, null);
  return;
}
catch (Error|RuntimeException localError)
{
  throw localError;
}
catch (Throwable localThrowable)
{
  throw new UndeclaredThrowableException(localThrowable);
}
</code></pre>

<p>  }</p>

<p>  public final int hashCode()</p>

<pre><code>throws 
</code></pre>

<p>  {</p>

<pre><code>try
{
  return ((Integer)h.invoke(this, m0, null)).intValue();
}
catch (Error|RuntimeException localError)
{
  throw localError;
}
catch (Throwable localThrowable)
{
  throw new UndeclaredThrowableException(localThrowable);
}
</code></pre>

<p>  }</p>

<p>  public final void operateMethod3()</p>

<pre><code>throws 
</code></pre>

<p>  {</p>

<pre><code>try
{
  h.invoke(this, m3, null);
  return;
}
catch (Error|RuntimeException localError)
{
  throw localError;
}
catch (Throwable localThrowable)
{
  throw new UndeclaredThrowableException(localThrowable);
}
</code></pre>

<p>  }</p>

<p>  public final String toString()</p>

<pre><code>throws 
</code></pre>

<p>  {</p>

<pre><code>try
{
  return (String)h.invoke(this, m2, null);
}
catch (Error|RuntimeException localError)
{
  throw localError;
}
catch (Throwable localThrowable)
{
  throw new UndeclaredThrowableException(localThrowable);
}
</code></pre>

<p>  }</p>

<p>  static
  {</p>

<pre><code>try
{
  m4 = Class.forName("com.codekk.java.test.dynamicproxy.Operate").getMethod("operateMethod1", new Class[0]);
  m1 = Class.forName("java.lang.Object").getMethod("equals", new Class[] { Class.forName("java.lang.Object") });
  m5 = Class.forName("com.codekk.java.test.dynamicproxy.Operate").getMethod("operateMethod2", new Class[0]);
  m0 = Class.forName("java.lang.Object").getMethod("hashCode", new Class[0]);
  m3 = Class.forName("com.codekk.java.test.dynamicproxy.Operate").getMethod("operateMethod3", new Class[0]);
  m2 = Class.forName("java.lang.Object").getMethod("toString", new Class[0]);
  return;
}
catch (NoSuchMethodException localNoSuchMethodException)
{
  throw new NoSuchMethodError(localNoSuchMethodException.getMessage());
}
catch (ClassNotFoundException localClassNotFoundException)
{
  throw new NoClassDefFoundError(localClassNotFoundException.getMessage());
}
</code></pre>

<p>  }
}
```</p>

<p>可以看到实际上在底层生成了一个class的字节流，并且被ClassLoader加载了，生成了一个继承<code>Proxy</code>实现了接口的类，这个类以<code>InvocationHandler</code>为构造函数参数，所以实际上是在调用方法时，生成的<code>$Proxy0</code>对象代理了<code>InvocationHandler</code>实现对象，<code>InvocationHandler</code>对象代理了实际的对象。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[okhttp3源码分析]]></title>
    <link href="http://Solarex.github.io/blog/2018/04/23/okhttp3-source-analysis/"/>
    <updated>2018-04-23T16:43:00+08:00</updated>
    <id>http://Solarex.github.io/blog/2018/04/23/okhttp3-source-analysis</id>
    <content type="html"><![CDATA[<p>周末在家断点调试了一下okhttp的执行流程，翻看了一下okhttp的源码，对okhttp有了一个大致的了解，在这记录一下。okhttp的精髓是<code>Dispatcher</code>和<code>Interceptor</code>，这里主要分析这两个。</p>

<h1>Dispatcher</h1>

<p><code>Dispatcher</code>是在<code>OkHttpClient.Builder</code>中实例化的，主要维护了<code>runningSyncCalls</code>，<code>runningAsyncCalls</code>,<code>readyAsyncCalls</code>三个队列。</p>

<p>同步的请求在执行<code>execute</code>方法时会将<code>RealCall</code>对象添加到<code>runningSyncCalls</code>队列中去，然后调用<code>getResponseWithInterceptorChain</code>去获取<code>Response</code>，不管成功失败，在<code>finally</code>块中都会执行<code>runningSyncCalls.remove(realcall)</code>将<code>RealCall</code>对象移除出队列。类似于一个生产者消费者系统。</p>

<p>异步的请求会将请求包装成一个<code>AsyncCall</code>，实际上就是一个Runnable，然后看<code>runningAsyncCalls</code>队列的长度是否小于<code>maxRequests</code>也即64并且同一个host的请求是否小于<code>maxRequestsPerHost</code>,如果满足则添加到<code>runningAsyncCalls</code>队列中去，并且调用线程池执行，否则添加到<code>readyAsyncCalls</code>队列中去。在<code>AsyncCall</code>这个<code>Runnable</code>的<code>run</code>方法中又会去调用<code>getResponseWithInterceptorChain</code>去获取<code>Response</code>，值得注意的是在<code>finally</code>块中，将<code>AsyncCall</code>移除出队列的时候会调用<code>promoteCalls</code>方法。</p>

<!-- more -->


<p>```java
synchronized void enqueue(AsyncCall call) {</p>

<pre><code>if (runningAsyncCalls.size() &lt; maxRequests &amp;&amp; runningCallsForHost(call) &lt; maxRequestsPerHost) {
  runningAsyncCalls.add(call);
  executorService().execute(call);
} else {
  readyAsyncCalls.add(call);
}
</code></pre>

<p>}</p>

<p>private <T> void finished(Deque<T> calls, T call, boolean promoteCalls) {</p>

<pre><code>int runningCallsCount;
Runnable idleCallback;
synchronized (this) {
  if (!calls.remove(call)) throw new AssertionError("Call wasn't in-flight!");
  if (promoteCalls) promoteCalls();
  runningCallsCount = runningCallsCount();
  idleCallback = this.idleCallback;
}

if (runningCallsCount == 0 &amp;&amp; idleCallback != null) {
  idleCallback.run();
}
</code></pre>

<p>}</p>

<p>private void promoteCalls() {</p>

<pre><code>if (runningAsyncCalls.size() &gt;= maxRequests) return; // Already running max capacity.
if (readyAsyncCalls.isEmpty()) return; // No ready calls to promote.

for (Iterator&lt;AsyncCall&gt; i = readyAsyncCalls.iterator(); i.hasNext(); ) {
  AsyncCall call = i.next();

  if (runningCallsForHost(call) &lt; maxRequestsPerHost) {
    i.remove();
    runningAsyncCalls.add(call);
    executorService().execute(call);
  }

  if (runningAsyncCalls.size() &gt;= maxRequests) return; // Reached max capacity.
}
</code></pre>

<p>}
```</p>

<p>在<code>promoteCalls</code>方法中会将<code>AsyncCall</code>从<code>readyAsyncCalls</code>队列中移除，添加到<code>runningAsyncCalls</code>中并调用线程池执行。</p>

<p>下面就开始<code>getResponseWithInterceptorChain</code>的分析了。</p>

<h1>Interceptor</h1>

<p>```java
Response getResponseWithInterceptorChain() throws IOException {</p>

<pre><code>// Build a full stack of interceptors.
List&lt;Interceptor&gt; interceptors = new ArrayList&lt;&gt;();
interceptors.addAll(client.interceptors());
interceptors.add(retryAndFollowUpInterceptor);
interceptors.add(new BridgeInterceptor(client.cookieJar()));
interceptors.add(new CacheInterceptor(client.internalCache()));
interceptors.add(new ConnectInterceptor(client));
if (!forWebSocket) {
  interceptors.addAll(client.networkInterceptors());
}
interceptors.add(new CallServerInterceptor(forWebSocket));

Interceptor.Chain chain = new RealInterceptorChain(interceptors, null, null, null, 0,
    originalRequest, this, eventListener, client.connectTimeoutMillis(),
    client.readTimeoutMillis(), client.writeTimeoutMillis());

return chain.proceed(originalRequest);
</code></pre>

<p>}
```</p>

<p>可以看到在<code>getResponseWithInterceptorChain</code>方法中只是把各种<code>Interceptor</code>添加到集合中去，并且实例化了一个<code>RealInterceptorChain</code>,调用了一下<code>chain.proceed</code>方法。</p>

<h2>RealInterceptorChain</h2>

<p>```java</p>

<pre><code>// Call the next interceptor in the chain.
RealInterceptorChain next = new RealInterceptorChain(interceptors, streamAllocation, httpCodec,
    connection, index + 1, request, call, eventListener, connectTimeout, readTimeout,
    writeTimeout);
Interceptor interceptor = interceptors.get(index);
Response response = interceptor.intercept(next);
</code></pre>

<p>```</p>

<p>在<code>proceed</code>方法中实例化一个新的<code>RealInterceptorChain</code>对象<code>next</code>,注意参数中<code>index+1</code>，取出<code>index</code>对应的<code>Interceptor</code>，调用<code>Interceptor</code>的<code>intercept</code>方法将<code>next</code>对象传入。实际上就是按照<code>Interceptor</code>添加的顺序去掉用各个<code>Interceptor</code>的<code>intercept</code>方法了。</p>

<p>先不管<code>OkHttpClient</code>Build的时候配置的<code>interceptors</code>和<code>networkInterceptors</code>，着重看看内置的几个<code>Interceptor</code>。</p>

<h2>RetryAndFollowUpInterceptor</h2>

<p>```java</p>

<pre><code>StreamAllocation streamAllocation = new StreamAllocation(client.connectionPool(),
    createAddress(request.url()), call, eventListener, callStackTrace);
this.streamAllocation = streamAllocation;

int followUpCount = 0;
Response priorResponse = null;
while (true) {
  if (canceled) {
    streamAllocation.release();
    throw new IOException("Canceled");
  }

  Response response;
  boolean releaseConnection = true;
  try {
    response = realChain.proceed(request, streamAllocation, null, null);
    releaseConnection = false;
  } catch (RouteException e) {
    // The attempt to connect via a route failed. The request will not have been sent.
    if (!recover(e.getLastConnectException(), streamAllocation, false, request)) {
      throw e.getLastConnectException();
    }
    releaseConnection = false;
    continue;
  } catch (IOException e) {
    // An attempt to communicate with a server failed. The request may have been sent.
    boolean requestSendStarted = !(e instanceof ConnectionShutdownException);
    if (!recover(e, streamAllocation, requestSendStarted, request)) throw e;
    releaseConnection = false;
    continue;
  } finally {
    // We're throwing an unchecked exception. Release any resources.
    if (releaseConnection) {
      streamAllocation.streamFailed(null);
      streamAllocation.release();
    }
  }

  // Attach the prior response if it exists. Such responses never have a body.
  if (priorResponse != null) {
    response = response.newBuilder()
        .priorResponse(priorResponse.newBuilder()
                .body(null)
                .build())
        .build();
  }

  Request followUp = followUpRequest(response, streamAllocation.route());

  if (followUp == null) {
    if (!forWebSocket) {
      streamAllocation.release();
    }
    return response;
  }

  closeQuietly(response.body());

  if (++followUpCount &gt; MAX_FOLLOW_UPS) {
    streamAllocation.release();
    throw new ProtocolException("Too many follow-up requests: " + followUpCount);
  }

  if (followUp.body() instanceof UnrepeatableRequestBody) {
    streamAllocation.release();
    throw new HttpRetryException("Cannot retry streamed HTTP body", response.code());
  }

  if (!sameConnection(response, followUp.url())) {
    streamAllocation.release();
    streamAllocation = new StreamAllocation(client.connectionPool(),
        createAddress(followUp.url()), call, eventListener, callStackTrace);
    this.streamAllocation = streamAllocation;
  } else if (streamAllocation.codec() != null) {
    throw new IllegalStateException("Closing the body of " + response
        + " didn't close its backing stream. Bad interceptor?");
  }

  request = followUp;
  priorResponse = response;
}
</code></pre>

<p>```</p>

<p>主要实例化了一个<code>StreamAllocation</code>对象，并调用了<code>chain.proceed</code>方法。对连接的重定向也做了处理。<code>chain.proceed</code>方法会接着调用下一个<code>Interceptor</code>的<code>intercept</code>方法。</p>

<h2>BridgeIntercepto</h2>

<p>```java</p>

<pre><code>@Override public Response intercept(Chain chain) throws IOException {
Request userRequest = chain.request();
Request.Builder requestBuilder = userRequest.newBuilder();

RequestBody body = userRequest.body();
if (body != null) {
  MediaType contentType = body.contentType();
  if (contentType != null) {
    requestBuilder.header("Content-Type", contentType.toString());
  }

  long contentLength = body.contentLength();
  if (contentLength != -1) {
    requestBuilder.header("Content-Length", Long.toString(contentLength));
    requestBuilder.removeHeader("Transfer-Encoding");
  } else {
    requestBuilder.header("Transfer-Encoding", "chunked");
    requestBuilder.removeHeader("Content-Length");
  }
}

if (userRequest.header("Host") == null) {
  requestBuilder.header("Host", hostHeader(userRequest.url(), false));
}

if (userRequest.header("Connection") == null) {
  requestBuilder.header("Connection", "Keep-Alive");
}

// If we add an "Accept-Encoding: gzip" header field we're responsible for also decompressing
// the transfer stream.
boolean transparentGzip = false;
if (userRequest.header("Accept-Encoding") == null &amp;&amp; userRequest.header("Range") == null) {
  transparentGzip = true;
  requestBuilder.header("Accept-Encoding", "gzip");
}

List&lt;Cookie&gt; cookies = cookieJar.loadForRequest(userRequest.url());
if (!cookies.isEmpty()) {
  requestBuilder.header("Cookie", cookieHeader(cookies));
}

if (userRequest.header("User-Agent") == null) {
  requestBuilder.header("User-Agent", Version.userAgent());
}

Response networkResponse = chain.proceed(requestBuilder.build());

HttpHeaders.receiveHeaders(cookieJar, userRequest.url(), networkResponse.headers());

Response.Builder responseBuilder = networkResponse.newBuilder()
    .request(userRequest);

if (transparentGzip
    &amp;&amp; "gzip".equalsIgnoreCase(networkResponse.header("Content-Encoding"))
    &amp;&amp; HttpHeaders.hasBody(networkResponse)) {
  GzipSource responseBody = new GzipSource(networkResponse.body().source());
  Headers strippedHeaders = networkResponse.headers().newBuilder()
      .removeAll("Content-Encoding")
      .removeAll("Content-Length")
      .build();
  responseBuilder.headers(strippedHeaders);
  String contentType = networkResponse.header("Content-Type");
  responseBuilder.body(new RealResponseBody(contentType, -1L, Okio.buffer(responseBody)));
}

return responseBuilder.build();
</code></pre>

<p>  }
```</p>

<p><code>BridgeIntercepto</code>主要是给<code>Request</code>添加一些头部信息，如<code>connection:keep-alive</code>,<code>accept-encoding:gzip</code>等等，对返回回来的<code>Response</code>如果是经过<code>gzip</code>压缩的，会进行一个解压缩。</p>

<h2>CacheInterceptor</h2>

<p><code>CacheInterceptor</code>new的时候将<code>client.internalCache()</code>作为参数传递了过来。</p>

<p>```java
  InternalCache internalCache() {</p>

<pre><code>return cache != null ? cache.internalCache : internalCache;
</code></pre>

<p>  }
```</p>

<p>下面主要看下<code>Cache</code>类</p>

<h3>Cache</h3>

<p>```java
  Cache(File directory, long maxSize, FileSystem fileSystem) {</p>

<pre><code>this.cache = DiskLruCache.create(fileSystem, directory, VERSION, ENTRY_COUNT, maxSize);
</code></pre>

<p>  }
```</p>

<p>可以看到<code>Cache</code>底层实际上是使用了<code>DiskLruCache</code>。</p>

<p>主要看下<code>get</code>和<code>put</code>方法</p>

<p>```java</p>

<pre><code>@Nullable Response get(Request request) {
String key = key(request.url());
DiskLruCache.Snapshot snapshot;
Entry entry;
try {
  snapshot = cache.get(key);
  if (snapshot == null) {
    return null;
  }
} catch (IOException e) {
  // Give up because the cache cannot be read.
  return null;
}

try {
  entry = new Entry(snapshot.getSource(ENTRY_METADATA));
} catch (IOException e) {
  Util.closeQuietly(snapshot);
  return null;
}

Response response = entry.response(snapshot);

if (!entry.matches(request, response)) {
  Util.closeQuietly(response.body());
  return null;
}

return response;
</code></pre>

<p>  }
```</p>

<p>```java</p>

<pre><code>@Nullable CacheRequest put(Response response) {
String requestMethod = response.request().method();

if (HttpMethod.invalidatesCache(response.request().method())) {
  try {
    remove(response.request());
  } catch (IOException ignored) {
    // The cache cannot be written.
  }
  return null;
}
if (!requestMethod.equals("GET")) {
  // Don't cache non-GET responses. We're technically allowed to cache
  // HEAD requests and some POST requests, but the complexity of doing
  // so is high and the benefit is low.
  return null;
}

if (HttpHeaders.hasVaryAll(response)) {
  return null;
}
// 注意这里
Entry entry = new Entry(response);
DiskLruCache.Editor editor = null;
try {
  editor = cache.edit(key(response.request().url()));
  if (editor == null) {
    return null;
  }
  entry.writeTo(editor);
  //注意这里
  return new CacheRequestImpl(editor);
} catch (IOException e) {
  abortQuietly(editor);
  return null;
}
</code></pre>

<p>  }
```</p>

<p>```java</p>

<pre><code>Entry(Response response) {
  this.url = response.request().url().toString();
  this.varyHeaders = HttpHeaders.varyHeaders(response);
  this.requestMethod = response.request().method();
  this.protocol = response.protocol();
  this.code = response.code();
  this.message = response.message();
  this.responseHeaders = response.headers();
  this.handshake = response.handshake();
  this.sentRequestMillis = response.sentRequestAtMillis();
  this.receivedResponseMillis = response.receivedResponseAtMillis();
}

public void writeTo(DiskLruCache.Editor editor) throws IOException {
  BufferedSink sink = Okio.buffer(editor.newSink(ENTRY_METADATA));

  sink.writeUtf8(url)
      .writeByte('\n');
  sink.writeUtf8(requestMethod)
      .writeByte('\n');
  sink.writeDecimalLong(varyHeaders.size())
      .writeByte('\n');
  for (int i = 0, size = varyHeaders.size(); i &lt; size; i++) {
    sink.writeUtf8(varyHeaders.name(i))
        .writeUtf8(": ")
        .writeUtf8(varyHeaders.value(i))
        .writeByte('\n');
  }

  sink.writeUtf8(new StatusLine(protocol, code, message).toString())
      .writeByte('\n');
  sink.writeDecimalLong(responseHeaders.size() + 2)
      .writeByte('\n');
  for (int i = 0, size = responseHeaders.size(); i &lt; size; i++) {
    sink.writeUtf8(responseHeaders.name(i))
        .writeUtf8(": ")
        .writeUtf8(responseHeaders.value(i))
        .writeByte('\n');
  }
  sink.writeUtf8(SENT_MILLIS)
      .writeUtf8(": ")
      .writeDecimalLong(sentRequestMillis)
      .writeByte('\n');
  sink.writeUtf8(RECEIVED_MILLIS)
      .writeUtf8(": ")
      .writeDecimalLong(receivedResponseMillis)
      .writeByte('\n');

  if (isHttps()) {
    sink.writeByte('\n');
    sink.writeUtf8(handshake.cipherSuite().javaName())
        .writeByte('\n');
    writeCertList(sink, handshake.peerCertificates());
    writeCertList(sink, handshake.localCertificates());
    sink.writeUtf8(handshake.tlsVersion().javaName()).writeByte('\n');
  }
  sink.close();
}
</code></pre>

<p>```</p>

<p>在<code>Cache</code>的<code>put</code>方法中<code>Entry</code>写入到<code>DiskLruCache</code>的只是请求头，url，响应头之类的信息，同时返回了一个<code>CacheRequestImpl(editor)</code>对象，Find Usage之后发现是在<code>CacheInterceptor</code>的<code>intercept</code>中被调用的。</p>

<p>```java</p>

<pre><code>@Override public Response intercept(Chain chain) throws IOException {
Response cacheCandidate = cache != null
    ? cache.get(chain.request())
    : null;

long now = System.currentTimeMillis();

CacheStrategy strategy = new CacheStrategy.Factory(now, chain.request(), cacheCandidate).get();
Request networkRequest = strategy.networkRequest;
Response cacheResponse = strategy.cacheResponse;

if (cache != null) {
  cache.trackResponse(strategy);
}

if (cacheCandidate != null &amp;&amp; cacheResponse == null) {
  closeQuietly(cacheCandidate.body()); // The cache candidate wasn't applicable. Close it.
}

// If we're forbidden from using the network and the cache is insufficient, fail.
if (networkRequest == null &amp;&amp; cacheResponse == null) {
  return new Response.Builder()
      .request(chain.request())
      .protocol(Protocol.HTTP_1_1)
      .code(504)
      .message("Unsatisfiable Request (only-if-cached)")
      .body(Util.EMPTY_RESPONSE)
      .sentRequestAtMillis(-1L)
      .receivedResponseAtMillis(System.currentTimeMillis())
      .build();
}

// If we don't need the network, we're done.
if (networkRequest == null) {
  return cacheResponse.newBuilder()
      .cacheResponse(stripBody(cacheResponse))
      .build();
}

Response networkResponse = null;
try {
  networkResponse = chain.proceed(networkRequest);
} finally {
  // If we're crashing on I/O or otherwise, don't leak the cache body.
  if (networkResponse == null &amp;&amp; cacheCandidate != null) {
    closeQuietly(cacheCandidate.body());
  }
}

// If we have a cache response too, then we're doing a conditional get.
if (cacheResponse != null) {
  if (networkResponse.code() == HTTP_NOT_MODIFIED) {
    Response response = cacheResponse.newBuilder()
        .headers(combine(cacheResponse.headers(), networkResponse.headers()))
        .sentRequestAtMillis(networkResponse.sentRequestAtMillis())
        .receivedResponseAtMillis(networkResponse.receivedResponseAtMillis())
        .cacheResponse(stripBody(cacheResponse))
        .networkResponse(stripBody(networkResponse))
        .build();
    networkResponse.body().close();

    // Update the cache after combining headers but before stripping the
    // Content-Encoding header (as performed by initContentStream()).
    cache.trackConditionalCacheHit();
    cache.update(cacheResponse, response);
    return response;
  } else {
    closeQuietly(cacheResponse.body());
  }
}

Response response = networkResponse.newBuilder()
    .cacheResponse(stripBody(cacheResponse))
    .networkResponse(stripBody(networkResponse))
    .build();

if (cache != null) {
  if (HttpHeaders.hasBody(response) &amp;&amp; CacheStrategy.isCacheable(response, networkRequest)) {
    // Offer this request to the cache.
    // *****注意这里*****
    CacheRequest cacheRequest = cache.put(response);
    return cacheWritingResponse(cacheRequest, response);
  }

  if (HttpMethod.invalidatesCache(networkRequest.method())) {
    try {
      cache.remove(networkRequest);
    } catch (IOException ignored) {
      // The cache cannot be written.
    }
  }
}

return response;
</code></pre>

<p>  }
```</p>

<p>可以看到主要是对<code>cacheResponse</code>和<code>networkResponse</code>进行的一些处理，比如返回304 not modified之类的处理结果。然后将<code>Response</code>写入缓存中。</p>

<p>```java</p>

<pre><code>/**
</code></pre>

<ul>
<li> Returns a new source that writes bytes to {@code cacheRequest} as they are read by the source</li>
<li> consumer. This is careful to discard bytes left over when the stream is closed; otherwise we</li>
<li><p> may never exhaust the source stream and therefore not complete the cached response.
*/
private Response cacheWritingResponse(final CacheRequest cacheRequest, Response response)
  throws IOException {
// Some apps return a null body; for compatibility we treat that like a null cache request.
if (cacheRequest == null) return response;
Sink cacheBodyUnbuffered = cacheRequest.body();
if (cacheBodyUnbuffered == null) return response;</p>

<p>final BufferedSource source = response.body().source();
final BufferedSink cacheBody = Okio.buffer(cacheBodyUnbuffered);</p>

<p>Source cacheWritingSource = new Source() {
  boolean cacheRequestClosed;</p>

<p>  @Override public long read(Buffer sink, long byteCount) throws IOException {
    long bytesRead;
    try {
      bytesRead = source.read(sink, byteCount);
    } catch (IOException e) {
      if (!cacheRequestClosed) {
        cacheRequestClosed = true;
        cacheRequest.abort(); // Failed to write a complete cache response.
      }
      throw e;
    }</p>

<pre><code>if (bytesRead == -1) {
  if (!cacheRequestClosed) {
    cacheRequestClosed = true;
    cacheBody.close(); // The cache response is complete!
  }
  return -1;
}

sink.copyTo(cacheBody.buffer(), sink.size() - bytesRead, bytesRead);
cacheBody.emitCompleteSegments();
return bytesRead;
</code></pre>

<p>  }</p>

<p>  @Override public Timeout timeout() {
    return source.timeout();
  }</p>

<p>  @Override public void close() throws IOException {
    if (!cacheRequestClosed
        &amp;&amp; !discard(this, HttpCodec.DISCARD_STREAM_TIMEOUT_MILLIS, MILLISECONDS)) {
      cacheRequestClosed = true;
      cacheRequest.abort();
    }
    source.close();
  }
};</p>

<p>String contentType = response.header(&ldquo;Content-Type&rdquo;);
long contentLength = response.body().contentLength();
return response.newBuilder()
    .body(new RealResponseBody(contentType, contentLength, Okio.buffer(cacheWritingSource)))
    .build();
}
```</p></li>
</ul>


<p>```java</p>

<pre><code>private final class CacheRequestImpl implements CacheRequest {
private final DiskLruCache.Editor editor;
private Sink cacheOut;
private Sink body;
boolean done;

CacheRequestImpl(final DiskLruCache.Editor editor) {
  this.editor = editor;
  this.cacheOut = editor.newSink(ENTRY_BODY);
  this.body = new ForwardingSink(cacheOut) {
    @Override public void close() throws IOException {
      synchronized (Cache.this) {
        if (done) {
          return;
        }
        done = true;
        writeSuccessCount++;
      }
      super.close();
      editor.commit();
    }
  };
}

@Override public void abort() {
  synchronized (Cache.this) {
    if (done) {
      return;
    }
    done = true;
    writeAbortCount++;
  }
  Util.closeQuietly(cacheOut);
  try {
    editor.abort();
  } catch (IOException ignored) {
  }
}

@Override public Sink body() {
  return body;
}
</code></pre>

<p>  }
```</p>

<p>可以看到调用了okio的<code>Sink</code>和<code>Source</code>进行了copy。</p>

<h2>ConnectInterceptor</h2>

<p>```java</p>

<pre><code>// We need the network to satisfy this request. Possibly for validating a conditional GET.
boolean doExtensiveHealthChecks = !request.method().equals("GET");
HttpCodec httpCodec = streamAllocation.newStream(client, chain, doExtensiveHealthChecks);
RealConnection connection = streamAllocation.connection();
</code></pre>

<p>```</p>

<p><code>ConnectInterceptor</code>主要就是调用了<code>streamAllocation</code>的<code>newStream</code>方法。</p>

<p>```java</p>

<pre><code>public HttpCodec newStream(
  OkHttpClient client, Interceptor.Chain chain, boolean doExtensiveHealthChecks) {
int connectTimeout = chain.connectTimeoutMillis();
int readTimeout = chain.readTimeoutMillis();
int writeTimeout = chain.writeTimeoutMillis();
int pingIntervalMillis = client.pingIntervalMillis();
boolean connectionRetryEnabled = client.retryOnConnectionFailure();

try {
  RealConnection resultConnection = findHealthyConnection(connectTimeout, readTimeout,
      writeTimeout, pingIntervalMillis, connectionRetryEnabled, doExtensiveHealthChecks);
  HttpCodec resultCodec = resultConnection.newCodec(client, chain, this);

  synchronized (connectionPool) {
    codec = resultCodec;
    return resultCodec;
  }
} catch (IOException e) {
  throw new RouteException(e);
}
</code></pre>

<p>  }</p>

<p>  /<em>*
   * Finds a connection and returns it if it is healthy. If it is unhealthy the process is repeated
   * until a healthy connection is found.
   </em>/
  private RealConnection findHealthyConnection(int connectTimeout, int readTimeout,</p>

<pre><code>  int writeTimeout, int pingIntervalMillis, boolean connectionRetryEnabled,
  boolean doExtensiveHealthChecks) throws IOException {
while (true) {
  RealConnection candidate = findConnection(connectTimeout, readTimeout, writeTimeout,
      pingIntervalMillis, connectionRetryEnabled);

  // If this is a brand new connection, we can skip the extensive health checks.
  synchronized (connectionPool) {
    if (candidate.successCount == 0) {
      return candidate;
    }
  }

  // Do a (potentially slow) check to confirm that the pooled connection is still good. If it
  // isn't, take it out of the pool and start again.
  if (!candidate.isHealthy(doExtensiveHealthChecks)) {
    noNewStreams();
    continue;
  }

  return candidate;
}
</code></pre>

<p>  }</p>

<p>  /<em>*
   * Returns a connection to host a new stream. This prefers the existing connection if it exists,
   * then the pool, finally building a new connection.
   </em>/
  private RealConnection findConnection(int connectTimeout, int readTimeout, int writeTimeout,</p>

<pre><code>  int pingIntervalMillis, boolean connectionRetryEnabled) throws IOException {
boolean foundPooledConnection = false;
RealConnection result = null;
Route selectedRoute = null;
Connection releasedConnection;
Socket toClose;
synchronized (connectionPool) {
  if (released) throw new IllegalStateException("released");
  if (codec != null) throw new IllegalStateException("codec != null");
  if (canceled) throw new IOException("Canceled");

  // Attempt to use an already-allocated connection. We need to be careful here because our
  // already-allocated connection may have been restricted from creating new streams.
  releasedConnection = this.connection;
  toClose = releaseIfNoNewStreams();
  if (this.connection != null) {
    // We had an already-allocated connection and it's good.
    result = this.connection;
    releasedConnection = null;
  }
  if (!reportedAcquired) {
    // If the connection was never reported acquired, don't report it as released!
    releasedConnection = null;
  }

  if (result == null) {
    // Attempt to get a connection from the pool.
    // 注意这里，从ConnectionPool中找Connection
    Internal.instance.get(connectionPool, address, this, null);
    if (connection != null) {
      foundPooledConnection = true;
      result = connection;
    } else {
      selectedRoute = route;
    }
  }
}
closeQuietly(toClose);

if (releasedConnection != null) {
  eventListener.connectionReleased(call, releasedConnection);
}
if (foundPooledConnection) {
  eventListener.connectionAcquired(call, result);
}
if (result != null) {
  // If we found an already-allocated or pooled connection, we're done.
  return result;
}

// If we need a route selection, make one. This is a blocking operation.
boolean newRouteSelection = false;
if (selectedRoute == null &amp;&amp; (routeSelection == null || !routeSelection.hasNext())) {
  newRouteSelection = true;
  routeSelection = routeSelector.next();
}

synchronized (connectionPool) {
  if (canceled) throw new IOException("Canceled");

  if (newRouteSelection) {
    // Now that we have a set of IP addresses, make another attempt at getting a connection from
    // the pool. This could match due to connection coalescing.
    List&lt;Route&gt; routes = routeSelection.getAll();
    for (int i = 0, size = routes.size(); i &lt; size; i++) {
      Route route = routes.get(i);
      Internal.instance.get(connectionPool, address, this, route);
      if (connection != null) {
        foundPooledConnection = true;
        result = connection;
        this.route = route;
        break;
      }
    }
  }

  if (!foundPooledConnection) {
    if (selectedRoute == null) {
      selectedRoute = routeSelection.next();
    }

    // Create a connection and assign it to this allocation immediately. This makes it possible
    // for an asynchronous cancel() to interrupt the handshake we're about to do.
    route = selectedRoute;
    refusedStreamCount = 0;
    result = new RealConnection(connectionPool, selectedRoute);
    acquire(result, false);
  }
}

// If we found a pooled connection on the 2nd time around, we're done.
if (foundPooledConnection) {
  eventListener.connectionAcquired(call, result);
  return result;
}

// Do TCP + TLS handshakes. This is a blocking operation.
// 进行tcp握手
result.connect(connectTimeout, readTimeout, writeTimeout, pingIntervalMillis,
    connectionRetryEnabled, call, eventListener);
routeDatabase().connected(result.route());

Socket socket = null;
synchronized (connectionPool) {
  reportedAcquired = true;

  // Pool the connection.
  // 把connection放到ConnectionPool中
  Internal.instance.put(connectionPool, result);

  // If another multiplexed connection to the same address was created concurrently, then
  // release this connection and acquire that one.
  if (result.isMultiplexed()) {
    socket = Internal.instance.deduplicate(connectionPool, address, this);
    result = connection;
  }
}
closeQuietly(socket);

eventListener.connectionAcquired(call, result);
return result;
</code></pre>

<p>  }
```</p>

<p>```java</p>

<pre><code>@Override public RealConnection get(ConnectionPool pool, Address address,
      StreamAllocation streamAllocation, Route route) {
    return pool.get(address, streamAllocation, route);
  }
</code></pre>

<p>```</p>

<p>```java</p>

<pre><code>/**
</code></pre>

<ul>
<li> Returns a recycled connection to {@code address}, or null if no such connection exists. The</li>
<li> route is null if the address has not yet been routed.
*/
@Nullable RealConnection get(Address address, StreamAllocation streamAllocation, Route route) {
assert (Thread.holdsLock(this));
for (RealConnection connection : connections) {
  if (connection.isEligible(address, route)) {
    streamAllocation.acquire(connection, true);
    return connection;
  }
}
return null;
}
```</li>
</ul>


<p>```java</p>

<pre><code>/**
</code></pre>

<ul>
<li> Returns true if this connection can carry a stream allocation to {@code address}. If non-null</li>
<li><p> {@code route} is the resolved route for a connection.
*/
public boolean isEligible(Address address, @Nullable Route route) {
// If this connection is not accepting new streams, we&rsquo;re done.
if (allocations.size() >= allocationLimit || noNewStreams) return false;</p>

<p>// If the non-host fields of the address don&rsquo;t overlap, we&rsquo;re done.
if (!Internal.instance.equalsNonHost(this.route.address(), address)) return false;</p>

<p>// If the host exactly matches, we&rsquo;re done: this connection can carry the address.
if (address.url().host().equals(this.route().address().url().host())) {
  return true; // This connection is a perfect match.
}</p>

<p>// At this point we don&rsquo;t have a hostname match. But we still be able to carry the request if
// our connection coalescing requirements are met. See also:
// <a href="https://hpbn.co/optimizing-application-delivery/#eliminate-domain-sharding">https://hpbn.co/optimizing-application-delivery/#eliminate-domain-sharding</a>
// <a href="https://daniel.haxx.se/blog/2016/08/18/http2-connection-coalescing/">https://daniel.haxx.se/blog/2016/08/18/http2-connection-coalescing/</a></p>

<p>// 1. This connection must be HTTP/2.
if (http2Connection == null) return false;</p>

<p>// 2. The routes must share an IP address. This requires us to have a DNS address for both
// hosts, which only happens after route planning. We can&rsquo;t coalesce connections that use a
// proxy, since proxies don&rsquo;t tell us the origin server&rsquo;s IP address.
if (route == null) return false;
if (route.proxy().type() != Proxy.Type.DIRECT) return false;
if (this.route.proxy().type() != Proxy.Type.DIRECT) return false;
if (!this.route.socketAddress().equals(route.socketAddress())) return false;</p>

<p>// 3. This connection&rsquo;s server certificate&rsquo;s must cover the new host.
if (route.address().hostnameVerifier() != OkHostnameVerifier.INSTANCE) return false;
if (!supportsUrl(address.url())) return false;</p>

<p>// 4. Certificate pinning must match the host.
try {
  address.certificatePinner().check(address.url().host(), handshake().peerCertificates());
} catch (SSLPeerUnverifiedException e) {
  return false;
}</p>

<p>return true; // The caller&rsquo;s address can be carried by this connection.
}
```</p></li>
</ul>


<p>```java
/<em>*
   * Use this allocation to hold {@code connection}. Each call to this must be paired with a call to
   * {@link #release} on the same connection.
   </em>/
  public void acquire(RealConnection connection, boolean reportedAcquired) {</p>

<pre><code>assert (Thread.holdsLock(connectionPool));
if (this.connection != null) throw new IllegalStateException();

this.connection = connection;
this.reportedAcquired = reportedAcquired;
connection.allocations.add(new StreamAllocationReference(this, callStackTrace));
</code></pre>

<p>  }
```</p>

<p><code>StreamAllocation.acquire(connection, true)</code>的时候将<code>StreamAllocaion</code>的弱引用加入到<code>connection.allocations</code>集合中，这将在释放<code>Connection</code>的时候用到。</p>

<p>在将<code>Connection</code>放入<code>ConnectionPool</code>中时，调用了<code>ConnectionPool</code>的<code>put</code>方法。</p>

<p>```java
void put(RealConnection connection) {</p>

<pre><code>assert (Thread.holdsLock(this));
if (!cleanupRunning) {
  cleanupRunning = true;
  executor.execute(cleanupRunnable);
}
connections.add(connection);
</code></pre>

<p>  }
```</p>

<p>线程池执行<code>cleanupRunnable</code></p>

<p>```java</p>

<pre><code>private final Runnable cleanupRunnable = new Runnable() {
@Override public void run() {
  while (true) {
    long waitNanos = cleanup(System.nanoTime());
    if (waitNanos == -1) return;
    if (waitNanos &gt; 0) {
      long waitMillis = waitNanos / 1000000L;
      waitNanos -= (waitMillis * 1000000L);
      synchronized (ConnectionPool.this) {
        try {
          ConnectionPool.this.wait(waitMillis, (int) waitNanos);
        } catch (InterruptedException ignored) {
        }
      }
    }
  }
}
</code></pre>

<p>  };</p>

<p>  long cleanup(long now) {</p>

<pre><code>int inUseConnectionCount = 0;
int idleConnectionCount = 0;
RealConnection longestIdleConnection = null;
long longestIdleDurationNs = Long.MIN_VALUE;

// Find either a connection to evict, or the time that the next eviction is due.
synchronized (this) {
  for (Iterator&lt;RealConnection&gt; i = connections.iterator(); i.hasNext(); ) {
    RealConnection connection = i.next();

    // If the connection is in use, keep searching.
    if (pruneAndGetAllocationCount(connection, now) &gt; 0) {
      inUseConnectionCount++;
      continue;
    }

    idleConnectionCount++;

    // If the connection is ready to be evicted, we're done.
    long idleDurationNs = now - connection.idleAtNanos;
    if (idleDurationNs &gt; longestIdleDurationNs) {
      longestIdleDurationNs = idleDurationNs;
      longestIdleConnection = connection;
    }
  }

  if (longestIdleDurationNs &gt;= this.keepAliveDurationNs
      || idleConnectionCount &gt; this.maxIdleConnections) {
    // We've found a connection to evict. Remove it from the list, then close it below (outside
    // of the synchronized block).
    connections.remove(longestIdleConnection);
  } else if (idleConnectionCount &gt; 0) {
    // A connection will be ready to evict soon.
    return keepAliveDurationNs - longestIdleDurationNs;
  } else if (inUseConnectionCount &gt; 0) {
    // All connections are in use. It'll be at least the keep alive duration 'til we run again.
    return keepAliveDurationNs;
  } else {
    // No connections, idle or in use.
    cleanupRunning = false;
    return -1;
  }
}

closeQuietly(longestIdleConnection.socket());

// Cleanup again immediately.
return 0;
</code></pre>

<p>  }</p>

<p>  /<em>*
   * Prunes any leaked allocations and then returns the number of remaining live allocations on
   * {@code connection}. Allocations are leaked if the connection is tracking them but the
   * application code has abandoned them. Leak detection is imprecise and relies on garbage
   * collection.
   </em>/
  private int pruneAndGetAllocationCount(RealConnection connection, long now) {</p>

<pre><code>List&lt;Reference&lt;StreamAllocation&gt;&gt; references = connection.allocations;
for (int i = 0; i &lt; references.size(); ) {
  Reference&lt;StreamAllocation&gt; reference = references.get(i);

  if (reference.get() != null) {
    i++;
    continue;
  }

  // We've discovered a leaked allocation. This is an application bug.
  StreamAllocation.StreamAllocationReference streamAllocRef =
      (StreamAllocation.StreamAllocationReference) reference;
  String message = "A connection to " + connection.route().address().url()
      + " was leaked. Did you forget to close a response body?";
  Platform.get().logCloseableLeak(message, streamAllocRef.callStackTrace);

  references.remove(i);
  connection.noNewStreams = true;

  // If this was the last allocation, the connection is eligible for immediate eviction.
  if (references.isEmpty()) {
    connection.idleAtNanos = now - keepAliveDurationNs;
    return 0;
  }
}

return references.size();
</code></pre>

<p>  }</p>

<p>  public static final class StreamAllocationReference extends WeakReference<StreamAllocation> {</p>

<pre><code>/**
 * Captures the stack trace at the time the Call is executed or enqueued. This is helpful for
 * identifying the origin of connection leaks.
 */
public final Object callStackTrace;

StreamAllocationReference(StreamAllocation referent, Object callStackTrace) {
  super(referent);
  this.callStackTrace = callStackTrace;
}
</code></pre>

<p>  }
```</p>

<p>通过判断<code>connection.allocations</code>的集合元素的弱引用指向是否为空来判断<code>connection</code>是否应该被释放。</p>

<h2>CallServerInterceptor</h2>

<p>```java</p>

<pre><code>@Override public Response intercept(Chain chain) throws IOException {
RealInterceptorChain realChain = (RealInterceptorChain) chain;
HttpCodec httpCodec = realChain.httpStream();
StreamAllocation streamAllocation = realChain.streamAllocation();
RealConnection connection = (RealConnection) realChain.connection();
Request request = realChain.request();

long sentRequestMillis = System.currentTimeMillis();

realChain.eventListener().requestHeadersStart(realChain.call());
httpCodec.writeRequestHeaders(request);
realChain.eventListener().requestHeadersEnd(realChain.call(), request);

Response.Builder responseBuilder = null;
if (HttpMethod.permitsRequestBody(request.method()) &amp;&amp; request.body() != null) {
  // If there's a "Expect: 100-continue" header on the request, wait for a "HTTP/1.1 100
  // Continue" response before transmitting the request body. If we don't get that, return
  // what we did get (such as a 4xx response) without ever transmitting the request body.
  if ("100-continue".equalsIgnoreCase(request.header("Expect"))) {
    httpCodec.flushRequest();
    realChain.eventListener().responseHeadersStart(realChain.call());
    responseBuilder = httpCodec.readResponseHeaders(true);
  }

  if (responseBuilder == null) {
    // Write the request body if the "Expect: 100-continue" expectation was met.
    realChain.eventListener().requestBodyStart(realChain.call());
    long contentLength = request.body().contentLength();
    CountingSink requestBodyOut =
        new CountingSink(httpCodec.createRequestBody(request, contentLength));
    BufferedSink bufferedRequestBody = Okio.buffer(requestBodyOut);

    request.body().writeTo(bufferedRequestBody);
    bufferedRequestBody.close();
    realChain.eventListener()
        .requestBodyEnd(realChain.call(), requestBodyOut.successfulCount);
  } else if (!connection.isMultiplexed()) {
    // If the "Expect: 100-continue" expectation wasn't met, prevent the HTTP/1 connection
    // from being reused. Otherwise we're still obligated to transmit the request body to
    // leave the connection in a consistent state.
    streamAllocation.noNewStreams();
  }
}

httpCodec.finishRequest();

if (responseBuilder == null) {
  realChain.eventListener().responseHeadersStart(realChain.call());
  responseBuilder = httpCodec.readResponseHeaders(false);
}

Response response = responseBuilder
    .request(request)
    .handshake(streamAllocation.connection().handshake())
    .sentRequestAtMillis(sentRequestMillis)
    .receivedResponseAtMillis(System.currentTimeMillis())
    .build();

int code = response.code();
if (code == 100) {
  // server sent a 100-continue even though we did not request one.
  // try again to read the actual response
  responseBuilder = httpCodec.readResponseHeaders(false);

  response = responseBuilder
          .request(request)
          .handshake(streamAllocation.connection().handshake())
          .sentRequestAtMillis(sentRequestMillis)
          .receivedResponseAtMillis(System.currentTimeMillis())
          .build();

  code = response.code();
}

realChain.eventListener()
        .responseHeadersEnd(realChain.call(), response);

if (forWebSocket &amp;&amp; code == 101) {
  // Connection is upgrading, but we need to ensure interceptors see a non-null response body.
  response = response.newBuilder()
      .body(Util.EMPTY_RESPONSE)
      .build();
} else {
  response = response.newBuilder()
      .body(httpCodec.openResponseBody(response))
      .build();
}

if ("close".equalsIgnoreCase(response.request().header("Connection"))
    || "close".equalsIgnoreCase(response.header("Connection"))) {
  streamAllocation.noNewStreams();
}

if ((code == 204 || code == 205) &amp;&amp; response.body().contentLength() &gt; 0) {
  throw new ProtocolException(
      "HTTP " + code + " had non-zero Content-Length: " + response.body().contentLength());
}

return response;
</code></pre>

<p>  }
```</p>

<p>分别调用<code>httpCodec.writeRequestHeaders(request);</code>写请求头部，<code>request.body().writeTo(bufferedRequestBody);</code>写请求body，<code>httpCodec.readResponseHeaders(false);</code>读响应头部，<code>httpCodec.openResponseBody(response)</code>读响应body。</p>

<p>至此，所有<code>interceptor</code>分析完毕。</p>

<p>接下来会写一下关于okhttp的扩展，比如如何监听下载进度，appliation interceptor与network interceptor的区别，如何设置断网情况下的缓存等等。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[NestedScrolling分析]]></title>
    <link href="http://Solarex.github.io/blog/2018/04/08/nestedscrolling-analysis/"/>
    <updated>2018-04-08T16:32:00+08:00</updated>
    <id>http://Solarex.github.io/blog/2018/04/08/nestedscrolling-analysis</id>
    <content type="html"><![CDATA[<h2>reference</h2>

<ul>
<li><a href="https://mp.weixin.qq.com/s/jD2zuLth197tBiVbYfjP8w"></a></li>
</ul>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Writing Better Adapters]]></title>
    <link href="http://Solarex.github.io/blog/2016/12/26/writing-better-adapters/"/>
    <updated>2016-12-26T16:11:00+08:00</updated>
    <id>http://Solarex.github.io/blog/2016/12/26/writing-better-adapters</id>
    <content type="html"><![CDATA[<p>Implementing adapters is one of the most frequent tasks for an Android developer. It’s the base for every list. Looking at apps, lists are the base of most apps.</p>

<p>The schema we follow to implement list views is often the same: a View with an adapter that holds the data. Doing this all the time can make us blind to what we are writing, even to ugly code. Even worse, we end up repeating that ugly code.</p>

<p>It’s time to take a close look into adapters.</p>

<h2>RecyclerView Basics</h2>

<p>The basic operations for RecyclerViews (but also applicable for ListView) are:</p>

<ul>
<li>Creating the view and the ViewHolder that holds the view information.</li>
<li>Binding the ViewHolder to the data that the adapter holds, probably a list of model classes.</li>
</ul>


<p>Implementing this is pretty straightforward and not much can be done wrong here.</p>

<!-- more -->


<h2>RecyclerView With Different Types</h2>

<p>It gets trickier when you need to have different kind of items in your views. It might be different kind of cards in case you use CardViews or could be ads stitched in between your elements. You might even have a list of completely different kind of objects (this article uses Kotlin but it can be easily applied to Java as no language specific feature are used)</p>

<p><code>
interface Animal
class Mouse: Animal
class Duck: Animal
class Dog: Animal
class Car
</code></p>

<p>You have various animals and then suddenly something like a car that is totally unrelated.</p>

<p>In those use cases you have probably different view types you need to show. Means you need to create different ViewHolders and probably inflate different layouts in each. The API defines type identifier as integers, that’s where the ugliness starts!</p>

<p>But let’s look at some code. When you have more than one item type you announce this by overriding:</p>

<p><code>
override fun getItemViewType(position: Int) : Int
</code></p>

<p>as the default implementation always returns zero. The implementer needs to translate the types into Integer values.</p>

<p>Next step: create the ViewHolders. So you have to implement:</p>

<p><code>
override fun onCreateViewHolder(parent: ViewGroup, viewType: Int): RecyclerView.ViewHolder
</code></p>

<p>In this method the API tells the Integer type you passed earlier as parameter.
The implementation is pretty trivial: a switch statement, or something similar, can be used to create ViewHolders for every given type.</p>

<p>The difference comes when binding the newly created (or recycled) ViewHolder:</p>

<p><code>
override fun onBindViewHolder(holder: ViewHolder, position: Int): Any
</code></p>

<p>Notice that here there is no type parameter. You could use getItemViewType if needed but normally it’s not needed. You could have some bind() method in a base class of all our different ViewHolders that you can call.</p>

<h2>The Uglyness</h2>

<p>So what is the problem now? Looks straightforward to implement, isn’t it?</p>

<p>Let’s look once again into getItemViewType().</p>

<p>The system needs the type for every position. So you have to translate an item in your backing model list to a view type.</p>

<p>You might want to write something like:</p>

<p>```
if (things.get(position) is Duck) {</p>

<pre><code>return TYPE_DUCK
</code></pre>

<p>} else if (things.get(position) is Mouse) {</p>

<pre><code>return TYPE_MOUSE
</code></pre>

<p>}
```</p>

<p>Can we agree on how ugly this is?</p>

<p>It might get even worse if your ViewHolders don’t share a common base class. If they are totally different types, in your lists you have the same ugly code when binding the ViewHolder:</p>

<p>```
override fun onBindViewHolder(holder: RecyclerView.ViewHolder, position: Int) {</p>

<pre><code>val thing = things.get(position)
if (thing is Animal) {
    (holder as AnimalViewHolder).bind(thing as Animal)
} else if (thing is Car) {
    (holder as CarViewHolder).bind(thing as Car)
}
</code></pre>

<p>&hellip;
}
```</p>

<p>This is a mess. instance-of checks and dozens of casting. Both are code smells and should be even considered anti-patterns.</p>

<p>Many years ago I had a couple of quotes attached to my monitor. One of them was from Effective C++ by Scott Meyers (one of the best IT books ever written) and goes like this:</p>

<p><code>
Anytime you find yourself writing code of the form “if the object is of type T1, then do something, but if it’s of type T2, then do something else,” slap yourself.
</code></p>

<p>If you look at those adapter implementation, there is a lot of slapping to be done.</p>

<ul>
<li>We have type checks and we have lots of ugly casts!</li>
<li>This is simply not object orientated code! OO just celebrated its 50th birthday so we should try to use more of its strengths.</li>
<li>In addition, the way we implemented those adapters is a violation of the “Open-Closed” rule from the SOLID principles. It says: “open for extension but closed for modifications”.</li>
</ul>


<p>But when we would add another type to our classes, another Model, let’s say Rabbit and therefore RabbitViewHolder, we have to change lots of methods in the adapter. A clear violation of the principle. A new kind of object should not lead to modifications in existing methods.</p>

<p>So let’s try to solve this.</p>

<h2>Let’s Fix It</h2>

<p>One alternative would be to put something in the middle to do the translation for us. It could be as simple as putting your Class types in some Map and retrieve the type with one call. It would be something like:</p>

<p><code>
override fun getItemViewType(position: Int) : Int
   = types.get(things.javaClass)
</code></p>

<p>It’s much better now isn’t it?
The sad answer is: not really! In the end this just hides instance-of.</p>

<p>How would you implement the onBindViewholder() we’ve seen above? It would be something like: if object is of type T1 then do.. else… so still slapping to be done here.</p>

<p>The goal should be to be able to <strong>add new view types without even touching the adapter</strong>.</p>

<p>Therefore: don’t create your own type mapping in the adapter between the models and the views in the first place. Google suggests using layout ids. With this trick you don’t need the artificial type mappings by simply using the layout id you’re inflating. And of course you probably save another enum as #perfmatters.</p>

<p>But still you need to map those to each other? How?</p>

<p>In the end end you need to map models to views. Could this knowledge move to the model?</p>

<p>It would be tempting to put the type into your model, something like.</p>

<p><code>
fun getType() : Int = R.layout.item_duck
</code></p>

<p>This way the adapter implementation for type could be totally generic:</p>

<p><code>
override fun getItemViewType(pos: Int) = things[pos].getType()
</code></p>

<p>Open-Closed principle is applied, no changes needed when adding new models.</p>

<p>But now you totally mixed our layers and indeed broke the complete architecture. Entities know about presentation, arrows pointing into the wrong direction. This must be unacceptable for us.</p>

<p>And again: adding a method into an object to asks for it’s type is not object orientated. You again would just hide the instance-of check.</p>

<h2>The ViewModel</h2>

<p>One way to approach this, is to have separat ViewModels instead of using our Model directly. In the end our problem was that our models are disjoint, they don’t share a common base: a car is not an animal. And this is correct. Only for the presentation layer you need to show them in on list. So when you introduce models for this layer you don’t have this problem, they can have a common base.</p>

<p>```
abstract class ViewModel {</p>

<pre><code>abstract fun type(): Int
</code></pre>

<p>}
class DuckViewModel(val duck: Duck): ViewModel() {</p>

<pre><code>override fun type() = R.layout.duck
</code></pre>

<p>}
class CarViewModel(val car: Car): ViewModel() {</p>

<pre><code>override fun type() = R.layout.car
</code></pre>

<p>}
```</p>

<p>So you simply wrapped the models. You don’t need to modify them at all and keep view specific code in those new ViewModels.</p>

<p>This way you can also add all formatting logic into there and use Android’s new Data Binding Library.</p>

<p>The idea of using list of ViewModels in the adapter instead of the Models helps especially when you need artificial items like dividers, section headers or simply advertisement items.</p>

<p>This is one approach to solve the problem. But not the only one.</p>

<h2>The Visitor</h2>

<p>Let’s go back to our initial idea of only using the Model. If you would have lots of model classes, maybe you don’t want to create lots of ViewModel one each.</p>

<p>Thinking of the type() method that you added in the first place into the model, you missed some decoupling. You need to avoid having the presentation code in there directly. You need to indirect it, move the actual type knowledge to somewhere else. How about adding an interface into this type() method:</p>

<p>```
interface Visitable {</p>

<pre><code>fun type(typeFactory: TypeFactory) : Int
</code></pre>

<p>}
```</p>

<p>Now you might ask what have you won here as the factory would still need to branch between types like the adapter did in the first place, right?</p>

<p>No it does not! This approach will be based on the Visitor pattern, one of the classic Gang-of-Four pattern. All the model will do, is forwarding this type call:</p>

<p>```
interface Animal : Visitable
interface Car : Visitable
class Mouse: Animal {</p>

<pre><code>override fun type(typeFactory: TypeFactory) 
    = typeFactory.type(this)
</code></pre>

<p>}
```</p>

<p>The factory has variations you need:</p>

<p>```
interface TypeFactory {</p>

<pre><code>fun type(duck: Duck): Int
fun type(mouse: Mouse): Int
fun type(dog: Dog): Int
fun type(car: Car): Int
</code></pre>

<p>}
```</p>

<p>This way it’s totally type safe, no instance-of, no casts needed at all.</p>

<p>And the responsibility of the factory is clear: it knows about the view types:</p>

<p>```
class TypeFactoryForList : TypeFactory {</p>

<pre><code>override fun type(duck: Duck) = R.layout.duck
override fun type(mouse: Mouse) = R.layout.mouse
override fun type(dog: Dog) = R.layout.dog
override fun type(car: Car) = R.layout.car
</code></pre>

<p>```</p>

<p>I could even also create ViewHolders to keep the knowledge about the ids in one place. So when adding a new view, this is the place to add. This should be pretty SOLID. You might need another method for new types but not modify any existing method: Open for Extension, Closed for Modification.</p>

<p>Now you might ask: why not use the factory directly from adapter instead using the indirection of the model?</p>

<p>Only with this path you get the type safety without need of casts and type checks. Take a moment to realize this here, there is not a single cast needed!This indirection is the magic behind Visitor Pattern.</p>

<p>Following this approach leaves the adapter with a very generic implementation that hardly ever needs to be changed.</p>

<h2>Conclusion</h2>

<ul>
<li>Try to keep your presentation code clean.</li>
<li>Instance-of checks should be a red flag!</li>
<li>Look out for down casting as it’s a code smell.</li>
<li>Try to replace those two with correct OO usage. Think about interfaces and inheritance.</li>
<li>Try to use generics to prevent castings.</li>
<li>Use ViewModels.</li>
<li>Check out for usages for the Visitor pattern.</li>
</ul>


<p>I would be happy to learn other ideas to make our Adapters cleaner.</p>

<p>PS: thanks to Jan M and Dmitri Kudrenko who crated examples on Github for Java and Kotlin:
<a href="https://github.com/dmitrikudrenko/BetterAdapters">https://github.com/dmitrikudrenko/BetterAdapters</a>
<a href="https://github.com/meierjan/BetterAdapters">https://github.com/meierjan/BetterAdapters</a></p>

<h2>reference</h2>

<ul>
<li><a href="https://medium.com/@dpreussler/writing-better-adapters-1b09758407d2#.vc2pos5tm">Writing Better Adapters</a></li>
<li><a href="https://juejin.im/entry/57fda1fe5bbb50005b3fef76?utm_source=gold-miner&amp;utm_medium=readme&amp;utm_campaign=github">关于 Android Adapter，你的实现方式可能一直都有问题</a></li>
<li><a href="http://github.com/flyfire/MultitypeBaseAdapter">MultitypeBaseAdapter</a></li>
</ul>

]]></content>
  </entry>
  
</feed>
