<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: android | Solarex's Blog]]></title>
  <link href="http://Solarex.github.io/blog/categories/android/atom.xml" rel="self"/>
  <link href="http://Solarex.github.io/"/>
  <updated>2017-10-18T22:21:39+08:00</updated>
  <id>http://Solarex.github.io/</id>
  <author>
    <name><![CDATA[Solarex]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[Writing Better Adapters]]></title>
    <link href="http://Solarex.github.io/blog/2016/12/26/writing-better-adapters/"/>
    <updated>2016-12-26T16:11:00+08:00</updated>
    <id>http://Solarex.github.io/blog/2016/12/26/writing-better-adapters</id>
    <content type="html"><![CDATA[<p>Implementing adapters is one of the most frequent tasks for an Android developer. It’s the base for every list. Looking at apps, lists are the base of most apps.</p>

<p>The schema we follow to implement list views is often the same: a View with an adapter that holds the data. Doing this all the time can make us blind to what we are writing, even to ugly code. Even worse, we end up repeating that ugly code.</p>

<p>It’s time to take a close look into adapters.</p>

<h2>RecyclerView Basics</h2>

<p>The basic operations for RecyclerViews (but also applicable for ListView) are:</p>

<ul>
<li>Creating the view and the ViewHolder that holds the view information.</li>
<li>Binding the ViewHolder to the data that the adapter holds, probably a list of model classes.</li>
</ul>


<p>Implementing this is pretty straightforward and not much can be done wrong here.</p>

<!-- more -->


<h2>RecyclerView With Different Types</h2>

<p>It gets trickier when you need to have different kind of items in your views. It might be different kind of cards in case you use CardViews or could be ads stitched in between your elements. You might even have a list of completely different kind of objects (this article uses Kotlin but it can be easily applied to Java as no language specific feature are used)</p>

<p><code>
interface Animal
class Mouse: Animal
class Duck: Animal
class Dog: Animal
class Car
</code></p>

<p>You have various animals and then suddenly something like a car that is totally unrelated.</p>

<p>In those use cases you have probably different view types you need to show. Means you need to create different ViewHolders and probably inflate different layouts in each. The API defines type identifier as integers, that’s where the ugliness starts!</p>

<p>But let’s look at some code. When you have more than one item type you announce this by overriding:</p>

<p><code>
override fun getItemViewType(position: Int) : Int
</code></p>

<p>as the default implementation always returns zero. The implementer needs to translate the types into Integer values.</p>

<p>Next step: create the ViewHolders. So you have to implement:</p>

<p><code>
override fun onCreateViewHolder(parent: ViewGroup, viewType: Int): RecyclerView.ViewHolder
</code></p>

<p>In this method the API tells the Integer type you passed earlier as parameter.
The implementation is pretty trivial: a switch statement, or something similar, can be used to create ViewHolders for every given type.</p>

<p>The difference comes when binding the newly created (or recycled) ViewHolder:</p>

<p><code>
override fun onBindViewHolder(holder: ViewHolder, position: Int): Any
</code></p>

<p>Notice that here there is no type parameter. You could use getItemViewType if needed but normally it’s not needed. You could have some bind() method in a base class of all our different ViewHolders that you can call.</p>

<h2>The Uglyness</h2>

<p>So what is the problem now? Looks straightforward to implement, isn’t it?</p>

<p>Let’s look once again into getItemViewType().</p>

<p>The system needs the type for every position. So you have to translate an item in your backing model list to a view type.</p>

<p>You might want to write something like:</p>

<p>```
if (things.get(position) is Duck) {</p>

<pre><code>return TYPE_DUCK
</code></pre>

<p>} else if (things.get(position) is Mouse) {</p>

<pre><code>return TYPE_MOUSE
</code></pre>

<p>}
```</p>

<p>Can we agree on how ugly this is?</p>

<p>It might get even worse if your ViewHolders don’t share a common base class. If they are totally different types, in your lists you have the same ugly code when binding the ViewHolder:</p>

<p>```
override fun onBindViewHolder(holder: RecyclerView.ViewHolder, position: Int) {</p>

<pre><code>val thing = things.get(position)
if (thing is Animal) {
    (holder as AnimalViewHolder).bind(thing as Animal)
} else if (thing is Car) {
    (holder as CarViewHolder).bind(thing as Car)
}
</code></pre>

<p>&hellip;
}
```</p>

<p>This is a mess. instance-of checks and dozens of casting. Both are code smells and should be even considered anti-patterns.</p>

<p>Many years ago I had a couple of quotes attached to my monitor. One of them was from Effective C++ by Scott Meyers (one of the best IT books ever written) and goes like this:</p>

<p><code>
Anytime you find yourself writing code of the form “if the object is of type T1, then do something, but if it’s of type T2, then do something else,” slap yourself.
</code></p>

<p>If you look at those adapter implementation, there is a lot of slapping to be done.</p>

<ul>
<li>We have type checks and we have lots of ugly casts!</li>
<li>This is simply not object orientated code! OO just celebrated its 50th birthday so we should try to use more of its strengths.</li>
<li>In addition, the way we implemented those adapters is a violation of the “Open-Closed” rule from the SOLID principles. It says: “open for extension but closed for modifications”.</li>
</ul>


<p>But when we would add another type to our classes, another Model, let’s say Rabbit and therefore RabbitViewHolder, we have to change lots of methods in the adapter. A clear violation of the principle. A new kind of object should not lead to modifications in existing methods.</p>

<p>So let’s try to solve this.</p>

<h2>Let’s Fix It</h2>

<p>One alternative would be to put something in the middle to do the translation for us. It could be as simple as putting your Class types in some Map and retrieve the type with one call. It would be something like:</p>

<p><code>
override fun getItemViewType(position: Int) : Int
   = types.get(things.javaClass)
</code></p>

<p>It’s much better now isn’t it?
The sad answer is: not really! In the end this just hides instance-of.</p>

<p>How would you implement the onBindViewholder() we’ve seen above? It would be something like: if object is of type T1 then do.. else… so still slapping to be done here.</p>

<p>The goal should be to be able to <strong>add new view types without even touching the adapter</strong>.</p>

<p>Therefore: don’t create your own type mapping in the adapter between the models and the views in the first place. Google suggests using layout ids. With this trick you don’t need the artificial type mappings by simply using the layout id you’re inflating. And of course you probably save another enum as #perfmatters.</p>

<p>But still you need to map those to each other? How?</p>

<p>In the end end you need to map models to views. Could this knowledge move to the model?</p>

<p>It would be tempting to put the type into your model, something like.</p>

<p><code>
fun getType() : Int = R.layout.item_duck
</code></p>

<p>This way the adapter implementation for type could be totally generic:</p>

<p><code>
override fun getItemViewType(pos: Int) = things[pos].getType()
</code></p>

<p>Open-Closed principle is applied, no changes needed when adding new models.</p>

<p>But now you totally mixed our layers and indeed broke the complete architecture. Entities know about presentation, arrows pointing into the wrong direction. This must be unacceptable for us.</p>

<p>And again: adding a method into an object to asks for it’s type is not object orientated. You again would just hide the instance-of check.</p>

<h2>The ViewModel</h2>

<p>One way to approach this, is to have separat ViewModels instead of using our Model directly. In the end our problem was that our models are disjoint, they don’t share a common base: a car is not an animal. And this is correct. Only for the presentation layer you need to show them in on list. So when you introduce models for this layer you don’t have this problem, they can have a common base.</p>

<p>```
abstract class ViewModel {</p>

<pre><code>abstract fun type(): Int
</code></pre>

<p>}
class DuckViewModel(val duck: Duck): ViewModel() {</p>

<pre><code>override fun type() = R.layout.duck
</code></pre>

<p>}
class CarViewModel(val car: Car): ViewModel() {</p>

<pre><code>override fun type() = R.layout.car
</code></pre>

<p>}
```</p>

<p>So you simply wrapped the models. You don’t need to modify them at all and keep view specific code in those new ViewModels.</p>

<p>This way you can also add all formatting logic into there and use Android’s new Data Binding Library.</p>

<p>The idea of using list of ViewModels in the adapter instead of the Models helps especially when you need artificial items like dividers, section headers or simply advertisement items.</p>

<p>This is one approach to solve the problem. But not the only one.</p>

<h2>The Visitor</h2>

<p>Let’s go back to our initial idea of only using the Model. If you would have lots of model classes, maybe you don’t want to create lots of ViewModel one each.</p>

<p>Thinking of the type() method that you added in the first place into the model, you missed some decoupling. You need to avoid having the presentation code in there directly. You need to indirect it, move the actual type knowledge to somewhere else. How about adding an interface into this type() method:</p>

<p>```
interface Visitable {</p>

<pre><code>fun type(typeFactory: TypeFactory) : Int
</code></pre>

<p>}
```</p>

<p>Now you might ask what have you won here as the factory would still need to branch between types like the adapter did in the first place, right?</p>

<p>No it does not! This approach will be based on the Visitor pattern, one of the classic Gang-of-Four pattern. All the model will do, is forwarding this type call:</p>

<p>```
interface Animal : Visitable
interface Car : Visitable
class Mouse: Animal {</p>

<pre><code>override fun type(typeFactory: TypeFactory) 
    = typeFactory.type(this)
</code></pre>

<p>}
```</p>

<p>The factory has variations you need:</p>

<p>```
interface TypeFactory {</p>

<pre><code>fun type(duck: Duck): Int
fun type(mouse: Mouse): Int
fun type(dog: Dog): Int
fun type(car: Car): Int
</code></pre>

<p>}
```</p>

<p>This way it’s totally type safe, no instance-of, no casts needed at all.</p>

<p>And the responsibility of the factory is clear: it knows about the view types:</p>

<p>```
class TypeFactoryForList : TypeFactory {</p>

<pre><code>override fun type(duck: Duck) = R.layout.duck
override fun type(mouse: Mouse) = R.layout.mouse
override fun type(dog: Dog) = R.layout.dog
override fun type(car: Car) = R.layout.car
</code></pre>

<p>```</p>

<p>I could even also create ViewHolders to keep the knowledge about the ids in one place. So when adding a new view, this is the place to add. This should be pretty SOLID. You might need another method for new types but not modify any existing method: Open for Extension, Closed for Modification.</p>

<p>Now you might ask: why not use the factory directly from adapter instead using the indirection of the model?</p>

<p>Only with this path you get the type safety without need of casts and type checks. Take a moment to realize this here, there is not a single cast needed!This indirection is the magic behind Visitor Pattern.</p>

<p>Following this approach leaves the adapter with a very generic implementation that hardly ever needs to be changed.</p>

<h2>Conclusion</h2>

<ul>
<li>Try to keep your presentation code clean.</li>
<li>Instance-of checks should be a red flag!</li>
<li>Look out for down casting as it’s a code smell.</li>
<li>Try to replace those two with correct OO usage. Think about interfaces and inheritance.</li>
<li>Try to use generics to prevent castings.</li>
<li>Use ViewModels.</li>
<li>Check out for usages for the Visitor pattern.</li>
</ul>


<p>I would be happy to learn other ideas to make our Adapters cleaner.</p>

<p>PS: thanks to Jan M and Dmitri Kudrenko who crated examples on Github for Java and Kotlin:
<a href="https://github.com/dmitrikudrenko/BetterAdapters">https://github.com/dmitrikudrenko/BetterAdapters</a>
<a href="https://github.com/meierjan/BetterAdapters">https://github.com/meierjan/BetterAdapters</a></p>

<h2>reference</h2>

<ul>
<li><a href="https://medium.com/@dpreussler/writing-better-adapters-1b09758407d2#.vc2pos5tm">Writing Better Adapters</a></li>
<li><a href="https://juejin.im/entry/57fda1fe5bbb50005b3fef76?utm_source=gold-miner&amp;utm_medium=readme&amp;utm_campaign=github">关于 Android Adapter，你的实现方式可能一直都有问题</a></li>
<li><a href="http://github.com/flyfire/MultitypeBaseAdapter">MultitypeBaseAdapter</a></li>
</ul>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Choreographer in Android]]></title>
    <link href="http://Solarex.github.io/blog/2016/10/10/choreographer-in-android/"/>
    <updated>2016-10-10T20:38:00+08:00</updated>
    <id>http://Solarex.github.io/blog/2016/10/10/choreographer-in-android</id>
    <content type="html"><![CDATA[<p>Choreographer is the one which acts like a interface between application view system and lower layer display system for rendering the views.</p>

<p>ViewRootImpl is the ViewParent or root below which only Activity window DecorView will be attached. All the view layouts set by the activity through <code>setContentView()</code> will attached the DecorView whose parent is ViewRootImpl. Actually ViewRootImpl is not a View its just a ViewParent which handled and manages the View Hierarchies for displaying, handling input events etc.</p>

<p>The number of root views that are active in your process. Each root view is associated with a window, so this can help you identify memory leaks involving dialogs or other windows.</p>

<!-- more -->


<p>ViewRootImpl will get the requests for refresh or view update from its child and interact with Choreographer for drawing the view hierarchy to the display system.</p>

<p>Choreographer instance will be created for each thread wise. Each application thread will have separate instance of Choreographer. When this instance is created then it itself register to for VSYNC event to the lower layer and now it ready to handle the ViewRootImpl/Application refresh request and interaction with the lower layer.</p>

<p>When ever ViewRootImpl got request from View hierarchy to refresh or update or invalidate then it request Choreographer for refresh by registering a callback. When Choreographer got any request then it request for next VSYNC event from the lower layer and when it got he VSYNC event then it asks ViewRootImpl by calling the registered Callback to handle the drawing accordingly. Also when ever ViewRootImpl wants to redraw the view then this thing will repeat.</p>

<p>When Choreographer receives VSYNC event then it handled the below event handling in order to handle the drawing or display.</p>

<ul>
<li><p>Input  handling : All received input event received and maintained in the query and all these input event will be processed now only.</p></li>
<li><p>Animation : Handle all the registered animations from ViewRootImpl or from Application or Activity.</p></li>
<li><p>View Traversal (Drawing/Rendering of Views) : Handles the View drawing if ViewRootImpl has registered for refresh.</p></li>
</ul>


<p>Choreographer is the main component which registers application main thread to display system and coordinate between the application view drawing component to the display system for synchronizing VSYNC with the application event, animation and draw handling.</p>

<h2>reference</h2>

<ul>
<li><a href="https://nayaneshguptetechstuff.wordpress.com/2014/07/01/what-is-choreographeri-in-android/">WHAT IS CHOREOGRAPHER IN ANDROID?</a></li>
</ul>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[VSYNC in Android]]></title>
    <link href="http://Solarex.github.io/blog/2016/10/09/vsync-in-android/"/>
    <updated>2016-10-09T20:43:00+08:00</updated>
    <id>http://Solarex.github.io/blog/2016/10/09/vsync-in-android</id>
    <content type="html"><![CDATA[<h2>In Android What is VSYNC and its usage?</h2>

<p>VSYNC is the event posted periodically by the kernal at fixed interval where the input handling, Animation and Window drawing happening synchroniiously at the same VSYNC interval. Below have given the detail explanation about the VSYNC event before VSYNC is introduced and after VSYNC is introduced.</p>

<!-- more -->


<h3>Before VSYNC is introduced:</h3>

<p>Before VSYNC is introduced then there was no synchronization happening for Input, animation and draw. As when there is an input it will be handled, also as when there is an animation or change in view then it will be drawn which results in too many CPU operations and some complex animations where some time operations or drawing happens exceeds human identifcatrion of view change. Suppose human eye can see clearly and differentiate 60FPS / seconds. In this case it might happen more then 60FPS some time.</p>

<p>As there is no sync happens between these 3 handling so input handling might redraw the view, animation also might redraw the view and some changes in view is also redraw. So too many redraw will happen.</p>

<h3>After VSYNC is introduced:</h3>

<p>Not this VSYNC is been delivered at an interval of 16.67 MS which is around 60 FPS/second. In this VSYNC event only handling of input will be happend, if input arrived before that then it will be queued and handled at VSYNC event only. After handling this VSYNC event, will handle the animation and followed by draw. Now all these 3 handling is synchronized and handling will be initiated on VSYNC event. VSYNC event make sure handling and drawing of the window happen at fixed interval and thus by avoid unnecessary drawing and handling.</p>

<p>Lets check below Google butter document for VSYNC handling.<a href="https://docs.google.com/viewer?url=http%3A%2F%2Fcommondatastorage.googleapis.com%2Fio2012%2Fpresentations%2Flive%2520to%2520website%2F109.pdf">For Butter or Worse : Smoothing out performance in Android UIs</a></p>

<h2>reference</h2>

<ul>
<li><a href="https://nayaneshguptetechstuff.wordpress.com/2014/07/01/what-is-vsyc-in-android/">WHAT IS VSYNC IN ANDROID?</a></li>
</ul>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Aspect Oriented Programming in Android]]></title>
    <link href="http://Solarex.github.io/blog/2016/09/20/aspect-oriented-programming-in-android/"/>
    <updated>2016-09-20T18:24:00+08:00</updated>
    <id>http://Solarex.github.io/blog/2016/09/20/aspect-oriented-programming-in-android</id>
    <content type="html"><![CDATA[<p>Aspect-oriented programming entails breaking down program logic into &ldquo;concerns&rdquo; (cohesive areas of functionality). This means, that with AOP, we can add executable blocks to some source code without explicitly changing it. This programming paradigm pretends that “cross-cutting concerns” (the logic needed at many places, without a single class where to implement them) should be implemented once and injected it many times into those places.</p>

<p>Code injection becomes a very important part of AOP: it is useful for dealing with the mentioned &ldquo;concerns&rdquo; that cut across the whole application, such as logging or performance monitoring, and, using it in this way, should not be something used rarely as you might think, quite the contrary; every programmer will come into a situation where this ability of injecting code, could prevent a lot of pain and frustration.</p>

<p>AOP is a paradigm that has been with us for many years, and I found it very useful to apply it to Android. After some investigation I consider that we can get a lot of advantages and very useful stuff when making use of it.</p>

<!-- more -->


<h2>Terminology (Mini glossary)</h2>

<p>Before we get started, let&rsquo;s have a look at some vocabulary that we should keep in mind:</p>

<ul>
<li><p>Cross-cutting concerns:Even though most classes in an OO model will perform a single, specific function, they often share common, secondary requirements with other classes. For example, we may want to add logging to classes within the data-access layer and also to classes in the UI layer whenever a thread enters or exits a method. Even though each class has a very different primary functionality, the code needed to perform the secondary functionality is often identical.</p></li>
<li><p>Advice: The code that is injected to a class file. Typically we talk about before, after, and around advices, which are executed before, after, or instead of a target method. It’s possible to make also other changes than injecting code into methods, e.g. adding fields or interfaces to a class.</p></li>
<li><p>Joint point: A particular point in a program that might be the target of code injection, e.g. a method call or method entry.</p></li>
<li><p>Pointcut: An expression which tells a code injection tool where to inject a particular piece of code, i.e. to which joint points to apply a particular advice. It could select only a single such point – e.g. execution of a single method – or many similar points – e.g. executions of all methods marked with a custom annotation such as @DebugTrace.</p></li>
<li><p>Aspect: The combination of the pointcut and the advice is termed an aspect. For instance, we add a logging aspect to our application by defining a pointcut and giving the correct advice.</p></li>
<li><p>Weaving: The process of injecting code – advices – into the target places – joint points.</p></li>
</ul>


<p>This picture summarizes a bit a few of these concepts:</p>

<center><img src="http://Solarex.github.io/images/aop.png"/></center>


<h2>So…where and when can we apply AOP?</h2>

<p>Some examples of cross-cutting concerns are:</p>

<ul>
<li>Logging</li>
<li>Persistance</li>
<li>Performance monitoring</li>
<li>Data Validation</li>
<li>Caching</li>
<li>Many others</li>
</ul>


<p>And in relation with &ldquo;when the magic happens&rdquo;, the code can be injected at different points in time:</p>

<ul>
<li><p>At run-time: your code has to explicitly ask for the enhanced code, e.g. by using a Dynamic Proxy (this is arguably not true code injection). Anyway here is an example I created for testing it.</p></li>
<li><p>At load-time: the modification are performed when the target classes are being loaded by Dalvik or ART. Byte-code or Dex-code weaving.</p></li>
<li><p>At build-time: you add an extra step to your build process to modify the compiled classes before packaging and deploying your application. Source-code weaving.</p></li>
</ul>


<p>Depending on the situation you will be choosing one or the other :).</p>

<h2>Tools and Libraries</h2>

<p>There are a few tools and libraries out there that help us use AOP:</p>

<ul>
<li><p><a href="https://eclipse.org/aspectj/">AspectJ</a>: A seamless aspect-oriented extension to the Javatm programming language (works with Android).</p></li>
<li><p><a href="https://github.com/crimsonwoods/javassist-android">Javassist for Android</a>: An android porting of the very well known java library Javassist for bytecode manipulation.</p></li>
<li><p><a href="https://code.google.com/p/dexmaker/">DexMaker</a>: A Java-language API for doing compile time or runtime code generation targeting the Dalvik VM.</p></li>
<li><p><a href="http://asm.ow2.org/asmdex-index.html">ASMDEX</a>: A bytecode manipulation library as ASM but it handles the DEX bytecode used by Android executables.</p></li>
</ul>


<h2>Why AspectJ?</h2>

<p>For our example below I have chosen AspectJ for the following reasons:</p>

<ul>
<li>Very powerful.</li>
<li>Supports build time and load time code injection.</li>
<li>Easy to use.</li>
</ul>


<h2>Example</h2>

<p>Let&rsquo;s say we want to measure the performance of a method (how long takes its execution). For doing this we want to mark our method with a <code>@DebugTrace</code> annotation and want to see the results using the logcat transparently without having to write code in each annotated method. Our approach is to use AspectJ for this purpose.</p>

<p>This is what is gonna happen under the hood:</p>

<ul>
<li>The annotation will be processed in a new step we are adding to our compilation fase.</li>
<li>Necessary boilerplate code will be generated and injected in the annotated method.</li>
</ul>


<p>I have to say here that while I was researching I found <a href="https://github.com/JakeWharton/hugo">Jake Wharton&rsquo;s Hugo Library</a> that it is suppose to do the same, so I refactored my code and looks similar to it, although mine is a more primitive and simpler version (I have learnt a lot by looking at its code by the way).</p>

<center><img src="http://Solarex.github.io/images/aspectweaving.png"/></center>


<h2>Project structure</h2>

<p>We will break up our sample application into 2 modules, the first will contain our android app and the second will be an android library that will make use of AspectJ library for weaving (code injection).</p>

<p>You may be wondering why we are using an android library module instead of a pure java library: <strong>the reason is that for AspectJ to work on Android we have to make use of some hooks when compiling our app and this is only possible using the android-library gradle plugin.</strong> (Do not worry about this yet, cause I will be giving some more details later).</p>

<h2>Creating our annotation</h2>

<p>We first create our Java annotation. This annotation will be persisted in the class (<code>RetentionPolicy.CLASS</code>) file and we will be able to annotate any constructor or method with it (<code>ElementType.CONSTRUCTOR</code> and <code>ElementType.METHOD</code>). So our <code>DebugTrace.java</code> file will look like this:</p>

<p><code>
@Retention(RetentionPolicy.CLASS)
@Target({ ElementType.CONSTRUCTOR, ElementType.METHOD })
public @interface DebugTrace {}
</code></p>

<h2>Our StopWatch for performance monitoring</h2>

<p>I have created a simple class that encapsulates time start/stop. Here is our <code>StopWatch.java</code> class:</p>

<p>```
/<em>*
 * Class representing a StopWatch for measuring time.
 </em>/
public class StopWatch {
  private long startTime;
  private long endTime;
  private long elapsedTime;</p>

<p>  public StopWatch() {</p>

<pre><code>//empty
</code></pre>

<p>  }</p>

<p>  private void reset() {</p>

<pre><code>startTime = 0;
endTime = 0;
elapsedTime = 0;
</code></pre>

<p>  }</p>

<p>  public void start() {</p>

<pre><code>reset();
startTime = System.nanoTime();
</code></pre>

<p>  }</p>

<p>  public void stop() {</p>

<pre><code>if (startTime != 0) {
  endTime = System.nanoTime();
  elapsedTime = endTime - startTime;
} else {
  reset();
}
</code></pre>

<p>  }</p>

<p>  public long getTotalTimeMillis() {</p>

<pre><code>return (elapsedTime != 0) ? TimeUnit.NANOSECONDS.toMillis(endTime - startTime) : 0;
</code></pre>

<p>  }
}
```</p>

<h2>DebugLog Class</h2>

<p>I just decorated the &ldquo;android.util.Log&rdquo; cause my first idea was to add some more functionality to the android log. Here it is:</p>

<p>```
/<em>*
 * Wrapper around {@link android.util.Log}
 </em>/
public class DebugLog {</p>

<p>  private DebugLog() {}</p>

<p>  /<em>*
   * Send a debug log message
   *
   * @param tag Source of a log message.
   * @param message The message you would like logged.
   </em>/
  public static void log(String tag, String message) {</p>

<pre><code>Log.d(tag, message);
</code></pre>

<p>  }
}
```</p>

<h2>Our Aspect</h2>

<p>Now it is time to create our aspect class (<code>TraceAspect.java</code>) that will be in charge of managing the annotation processing and source-code weaving.</p>

<p>```
/<em>*
 * Aspect representing the cross cutting-concern: Method and Constructor Tracing.
 </em>/
@Aspect
public class TraceAspect {</p>

<p>  private static final String POINTCUT_METHOD =</p>

<pre><code>  "execution(@org.android10.gintonic.annotation.DebugTrace * *(..))";
</code></pre>

<p>  private static final String POINTCUT_CONSTRUCTOR =</p>

<pre><code>  "execution(@org.android10.gintonic.annotation.DebugTrace *.new(..))";
</code></pre>

<p>  @Pointcut(POINTCUT_METHOD)
  public void methodAnnotatedWithDebugTrace() {}</p>

<p>  @Pointcut(POINTCUT_CONSTRUCTOR)
  public void constructorAnnotatedDebugTrace() {}</p>

<p>  @Around(&ldquo;methodAnnotatedWithDebugTrace() || constructorAnnotatedDebugTrace()&rdquo;)
  public Object weaveJoinPoint(ProceedingJoinPoint joinPoint) throws Throwable {</p>

<pre><code>MethodSignature methodSignature = (MethodSignature) joinPoint.getSignature();
String className = methodSignature.getDeclaringType().getSimpleName();
String methodName = methodSignature.getName();

final StopWatch stopWatch = new StopWatch();
stopWatch.start();
Object result = joinPoint.proceed();
stopWatch.stop();

DebugLog.log(className, buildLogMessage(methodName, stopWatch.getTotalTimeMillis()));

return result;
</code></pre>

<p>  }</p>

<p>  /<em>*
   * Create a log message.
   *
   * @param methodName A string with the method name.
   * @param methodDuration Duration of the method in milliseconds.
   * @return A string representing message.
   </em>/
  private static String buildLogMessage(String methodName, long methodDuration) {</p>

<pre><code>StringBuilder message = new StringBuilder();
message.append("Gintonic --&gt; ");
message.append(methodName);
message.append(" --&gt; ");
message.append("[");
message.append(methodDuration);
message.append("ms");
message.append("]");

return message.toString();
</code></pre>

<p>  }
}
```</p>

<p>Some important points to mention here:</p>

<ul>
<li><p>We declare 2 public methods with 2 pointcuts that will filter all methods and constructors annotated with &ldquo;org.android10.gintonic.annotation.DebugTrace&rdquo;.</p></li>
<li><p>We define the &ldquo;weaveJointPoint(ProceedingJoinPoint joinPoint)&rdquo; annotated with &ldquo;@Around&rdquo; which means that our code injection will happen around the annotated method with &ldquo;@DebugTrace&rdquo;.</p></li>
<li><p>The line &ldquo;Object result = joinPoint.proceed();&rdquo; is where the annotated method execution happens, so before this, is where we start our StopWatch to start measuring time, and after that, we stop it.</p></li>
<li><p>Finally we build our message and print it using the Android Log.</p></li>
</ul>


<h2>Making AspectJ to work with Android</h2>

<p>Now everything should be working, but, if we compile our sample, we will see that nothing happens.</p>

<p>The reason is that we have to use the AspectJ compiler (ajc, an extension of the java compiler) to weave all classes that are affected by an aspect. That&rsquo;s why, as I mention before, we need to add some extra configuration to our gradle build task to make it work.</p>

<p>This is how our <code>build.gradle</code> looks like:</p>

<p>```
import com.android.build.gradle.LibraryPlugin
import org.aspectj.bridge.IMessage
import org.aspectj.bridge.MessageHandler
import org.aspectj.tools.ajc.Main</p>

<p>buildscript {
  repositories {</p>

<pre><code>mavenCentral()
</code></pre>

<p>  }
  dependencies {</p>

<pre><code>classpath 'com.android.tools.build:gradle:0.12.+'
classpath 'org.aspectj:aspectjtools:1.8.1'
</code></pre>

<p>  }
}</p>

<p>apply plugin: &lsquo;android-library&rsquo;</p>

<p>repositories {
  mavenCentral()
}</p>

<p>dependencies {
  compile &lsquo;org.aspectj:aspectjrt:1.8.1&rsquo;
}</p>

<p>android {
  compileSdkVersion 19
  buildToolsVersion &lsquo;19.1.0&rsquo;</p>

<p>  lintOptions {</p>

<pre><code>abortOnError false
</code></pre>

<p>  }
}</p>

<p>android.libraryVariants.all { variant &ndash;>
  LibraryPlugin plugin = project.plugins.getPlugin(LibraryPlugin)
  JavaCompile javaCompile = variant.javaCompile
  javaCompile.doLast {</p>

<pre><code>String[] args = ["-showWeaveInfo",
                 "-1.5",
                 "-inpath", javaCompile.destinationDir.toString(),
                 "-aspectpath", javaCompile.classpath.asPath,
                 "-d", javaCompile.destinationDir.toString(),
                 "-classpath", javaCompile.classpath.asPath,
                 "-bootclasspath", plugin.project.android.bootClasspath.join(
    File.pathSeparator)]

MessageHandler handler = new MessageHandler(true);
new Main().run(args, handler)

def log = project.logger
for (IMessage message : handler.getMessages(null, true)) {
  switch (message.getKind()) {
    case IMessage.ABORT:
    case IMessage.ERROR:
    case IMessage.FAIL:
      log.error message.message, message.thrown
      break;
    case IMessage.WARNING:
    case IMessage.INFO:
      log.info message.message, message.thrown
      break;
    case IMessage.DEBUG:
      log.debug message.message, message.thrown
      break;
  }
}
</code></pre>

<p>  }
}
```</p>

<h2>Our test method</h2>

<p>Let&rsquo;s use our cool aspect annotation by adding it to a test method. I have created a method inside the main activity for testing purpose. Let&rsquo;s have a look at it:</p>

<p>```
@DebugTrace
  private void testAnnotatedMethod() {</p>

<pre><code>try {
  Thread.sleep(10);
} catch (InterruptedException e) {
  e.printStackTrace();
}
</code></pre>

<p>  }
```</p>

<h2>Executing our application</h2>

<p>We build and install our app on an android device/emulator by executing the gradle command:<code>gradlew clean build installDebug</code></p>

<p>If we open the logcat and execute our sample, we will see a debug log with:</p>

<p><code>Gintonic --&gt; testAnnotatedMethod --&gt; [10ms]</code></p>

<p>Our first android application using AOP worked!</p>

<p>You can use the <a href="https://play.google.com/store/apps/details?id=jp.itplus.android.dex.dump&amp;hl=en">Dex Dump</a> android application (from your phone), or any any other reverse engineering tool for decompiling the apk and see the source code generated and injected.</p>

<h2>Recap</h2>

<p>So to recap and summarize:</p>

<ul>
<li>We have had a taste of Aspect Oriented programming paradigm.</li>
<li>Code Injection becomes a very important part of this approach (AOP).</li>
<li>AspectJ is a very powerful and easy to use tool for source code weaving in Android applications.</li>
<li>We have created a working example using AOP capabilities.</li>
</ul>


<h2>Conclusion</h2>

<p>Aspect Oriented Programming is very powerful. Using it the right way, you can avoid duplicating a lot of code when you have &ldquo;cross-cutting concerns&rdquo; in your Android apps, like performance monitoring, as we have seen in our example. I do encourage you to give it a try, you will find it very useful.</p>

<p>I hope you like the article, the purpose of it was to share what I&rsquo;ve learnt so far, so feel free to comment and give feedback, or even better, fork the code and play a bit with it.</p>

<p>I&rsquo;m sure we can add very interesting stuff to our AOP module in the sample app. Ideas are very welcome ;).</p>

<h2>Source Code</h2>

<p>You can check 2 examples here, the first one uses AspectJ and the second one uses a Dynamic Proxy approach:</p>

<ul>
<li><a href="https://github.com/android10/Android-AOPExample.">https://github.com/android10/Android-AOPExample.</a></li>
<li><a href="https://github.com/android10/DynamicProxy_Java_Sample">https://github.com/android10/DynamicProxy_Java_Sample</a></li>
</ul>


<h2>Resources</h2>

<ul>
<li><a href="http://en.wikipedia.org/wiki/Aspect-oriented_programming">Aspect-oriented programming</a>.</li>
<li><a href="http://en.wikipedia.org/wiki/Aspect-oriented_software_development">Aspect-oriented software development</a>.</li>
<li><a href="http://www.javacodegeeks.com/2011/09/practical-introduction-into-code.html">Practical Introduction into Code Injection with AspectJ, Javassist, and Java Proxy</a>.</li>
<li><a href="http://java.dzone.com/articles/implementing-build-time">Implementing Build-time Bytecode Instrumentation With Javassist</a>.</li>
<li><a href="http://www.eclipse.org/aspectj/doc/released/faq.php">Frequently Asked Questions about AspectJ</a>.</li>
<li><a href="http://blog.espenberntsen.net/2010/03/20/aspectj-cheat-sheet/">AspectJ Cheat Sheet</a>.</li>
</ul>


<h2>reference</h2>

<ul>
<li><a href="https://fernandocejas.com/2014/08/03/aspect-oriented-programming-in-android/">Aspect Oriented Programming in Android</a></li>
</ul>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Make an android custom view,Publish and Open Source]]></title>
    <link href="http://Solarex.github.io/blog/2016/05/28/make-an-android-custom-view-publish-and-open-source/"/>
    <updated>2016-05-28T14:34:00+08:00</updated>
    <id>http://Solarex.github.io/blog/2016/05/28/make-an-android-custom-view-publish-and-open-source</id>
    <content type="html"><![CDATA[<p>Today I’m going to create an android custom view to implement circular <code>SeekBar</code> like the mockup below, make it as a library, open source at GitHub, and publish it to JCenter. In this post, I will cover several fundamental concepts of android custom view, write a helpful README on GitHub, and how to publish your library.</p>

<center><img src="http://Solarex.github.io/images/custom_view_seekbar.png"/></center>


<h2>Before you start…</h2>

<p>Try to understand the requirement or design specification, take a look at this widget first, the user can touch the indicator icon through this arc to set the current progress level. The indicator icon will stop dragging when exceeding max or min progress. It works like an extension of circular <code>SeekBar</code> with customized appearances and motion event.</p>

<!-- more -->


<h2>Get started:</h2>

<p>All the android view widgets are based on <code>View</code>, to implement custom view, you will start a subclass of <code>View</code> and override several lifecycle callback methods of view, so you need to understand the view lifecycle at first. The following diagram shows some important methods to override:</p>

<center><img src="http://Solarex.github.io/images/custom_view_lifecycle.png"/></center>


<p>To get started, the first thing we have to do is to create a class that extends <code>View</code>, and provide two default constructors which allows us to create the view programmatically (1st constructor) or in XML layout (2nd constructor). The <code>SwagPoint(Context context, AttributeSet attrs)</code> constructor is more important here because it is used when Android inflates the view from XML layout file, otherwise you will get exception.</p>

<p>```java
public class SwagPoints extends View {</p>

<pre><code>// used in view creation programmatically
public SwagPoints(Context context) {
    super(context);
}

// used in XML layout file
public SwagPoints(Context context, AttributeSet attrs) {
    super(context, attrs);
}
</code></pre>

<p>}
```</p>

<p>Then, there are several things we have to control or modify in our custom view:</p>

<ul>
<li><p><strong>Attributes</strong>: What things are customizable in your view? Determine custom attributes that allow developer to change its appearance and behavior in XML layout file according to their design.</p></li>
<li><p><strong>Size</strong>: Determine the dimensions of the view and every components in this custom view on the screen.</p></li>
<li><p><strong>Drawing</strong>: Determine how the view and components to render on the screen which contains the shape, location, appearance.</p></li>
<li><p><strong>Touch</strong>: Determine the way the user can interact with the view by touching.</p></li>
</ul>


<h2>1. Attribute:</h2>

<p>Here we provide several customizable attributes for developer: the initial progress <code>points</code>, the range of progress <code>max/min</code>, the interval when user change the progress <code>step</code>, the color and size of progress/arc/text. To define custom attributes, we create <code>res/values/attrs.xml</code> file and define custom attributes for your view in a <code>&lt;declare-styleable&gt;</code> resource element as below.</p>

<p>```xml
<resources></p>

<pre><code>&lt;declare-styleable name="SwagPoints"&gt;
    &lt;attr name="points" format="integer" /&gt;
    &lt;attr name="max" format="integer" /&gt;
    &lt;attr name="min" format="integer"/&gt;
    &lt;attr name="step" format="integer"/&gt;

    &lt;attr name="indicatorIcon" format="reference" /&gt;

    &lt;attr name="progressWidth" format="dimension" /&gt;
    &lt;attr name="progressColor" format="color" /&gt;

    &lt;attr name="arcWidth" format="dimension" /&gt;
    &lt;attr name="arcColor" format="color" /&gt;

    &lt;attr name="textSize" format="dimension"/&gt;
    &lt;attr name="textColor" format="color"/&gt;

    &lt;attr name="clockwise" format="boolean" /&gt;
    &lt;attr name="enabled" format="boolean" /&gt;

&lt;/declare-styleable&gt;
</code></pre>

<p></resources>
```</p>

<p>After adding <code>res/values/attrs.xml</code> file, to use <code>TypedArray</code> to retrieve attribute value in class and define instance variables (the following variable with <code>m</code> as prefix name) to store. Here we add a <code>init()</code> method to put <code>init()</code> inside the constructor after <code>super()</code> method to do this job:</p>

<p>```java
private void init(Context context, AttributeSet attrs) {</p>

<pre><code>float density = getResources().getDisplayMetrics().density;

// Defaults, may need to link this into theme settings
int arcColor = ContextCompat.getColor(context, R.color.color_arc);
int progressColor = ContextCompat.getColor(context, R.color.color_progress);
int textColor = ContextCompat.getColor(context, R.color.color_text);
mProgressWidth = (int) (mProgressWidth * density);
mArcWidth = (int) (mArcWidth * density);
mTextSize = (int) (mTextSize * density);

mIndicatorIcon = ContextCompat.getDrawable(context, R.drawable.indicator);

if (attrs != null) {
    // Attribute initialization
    final TypedArray a = context.obtainStyledAttributes(attrs,
            R.styleable.SwagPoints, 0, 0);

    Drawable indicatorIcon = a.getDrawable(R.styleable.SwagPoints_indicatorIcon);
    if (indicatorIcon != null)
        mIndicatorIcon = indicatorIcon;

    int indicatorIconHalfWidth = mIndicatorIcon.getIntrinsicWidth() / 2;
    int indicatorIconHalfHeight = mIndicatorIcon.getIntrinsicHeight() / 2;
    mIndicatorIcon.setBounds(-indicatorIconHalfWidth, -indicatorIconHalfHeight, indicatorIconHalfWidth,
            indicatorIconHalfHeight);

    mPoints = a.getInteger(R.styleable.SwagPoints_points, mPoints);
    mMin = a.getInteger(R.styleable.SwagPoints_min, mMin);
    mMax = a.getInteger(R.styleable.SwagPoints_max, mMax);
    mStep = a.getInteger(R.styleable.SwagPoints_step, mStep);

    mProgressWidth = (int) a.getDimension(R.styleable.SwagPoints_progressWidth, mProgressWidth);
    progressColor = a.getColor(R.styleable.SwagPoints_progressColor, progressColor);

    mArcWidth = (int) a.getDimension(R.styleable.SwagPoints_arcWidth, mArcWidth);
    arcColor = a.getColor(R.styleable.SwagPoints_arcColor, arcColor);

    mTextSize = (int) a.getDimension(R.styleable.SwagPoints_textSize, mTextSize);
    mTextColor = a.getColor(R.styleable.SwagPoints_textColor, mTextColor);

    mClockwise = a.getBoolean(R.styleable.SwagPoints_clockwise,
            mClockwise);
    mEnabled = a.getBoolean(R.styleable.SwagPoints_enabled, mEnabled);
    a.recycle();
}
</code></pre>

<p>}
```</p>

<h2>2. Size:</h2>

<p>In order to control the view dimension, we have to override <code>View.onMeasure()</code> method and calculate the size of each components. Here we have to define the arc radius according to the width/height of our view.</p>

<p>```java
@Override
protected void onMeasure(int widthMeasureSpec, int heightMeasureSpec) {</p>

<pre><code>final int width = getDefaultSize(getSuggestedMinimumWidth(), widthMeasureSpec);
final int height = getDefaultSize(getSuggestedMinimumHeight(), heightMeasureSpec);
final int min = Math.min(width, height);

mTranslateX = (int) (width * 0.5f);
mTranslateY = (int) (height * 0.5f);

int arcDiameter = min - getPaddingLeft();
mArcRadius = arcDiameter / 2;
float top = height / 2 - (arcDiameter / 2);
float left = width / 2 - (arcDiameter / 2);
mArcRect.set(left, top, left + arcDiameter, top + arcDiameter);

updateIndicatorIconPosition();
super.onMeasure(widthMeasureSpec, heightMeasureSpec);
</code></pre>

<p>}
```</p>

<h2>3. Drawing:</h2>

<p>Give you a pen and a paper, you can draw what you want. To draw the view, you have to override the <code>onDraw(Canvas canvas)</code> method.
Before that, we have to know what to draw and how to draw. Android provides two classes to do this job:</p>

<ul>
<li><p>What to draw, handled by <code>Canvas</code> which is provided as parameter in <code>onDraw()</code> method.</p></li>
<li><p>How to draw, handled by <code>Paint</code>.</p></li>
</ul>


<p>Before you use <code>Canvas</code> to draw anything, it’s necessary to create <code>Paint</code> objects. For performance optimization, creating the <code>Paint</code> objects ahead is quite important, because the <code>onDraw()</code> method is called when redrawn is needed at anytime, we won’t create the <code>Paint</code> objects inside the <code>onDraw()</code> method, we should avoid any allocation in <code>onDraw()</code> method. Here we define these objects (one for arc, another for progress and the other for text) as instance variables and initialize at <code>init()</code> method:</p>

<p>```java
private void init(Context context, AttributeSet attrs) {</p>

<pre><code>// ...

mArcPaint = new Paint();
mArcPaint.setColor(arcColor);
mArcPaint.setAntiAlias(true);
mArcPaint.setStyle(Paint.Style.STROKE);
mArcPaint.setStrokeWidth(mArcWidth);

mProgressPaint = new Paint();
mProgressPaint.setColor(progressColor);
mProgressPaint.setAntiAlias(true);
mProgressPaint.setStyle(Paint.Style.STROKE);
mProgressPaint.setStrokeWidth(mProgressWidth);

mTextPaint = new Paint();
mTextPaint.setColor(textColor);
mTextPaint.setAntiAlias(true);
mTextPaint.setStyle(Paint.Style.FILL);
mTextPaint.setTextSize(mTextSize);
</code></pre>

<p>}
```</p>

<p>Once we have <code>Paint</code> objects defined, we can start to implement the <code>onDraw(Canvas canvas)</code> method, here we’re going to draw the text to display current progress number, the arc and current progress:</p>

<p>```java
@Override
protected void onDraw(Canvas canvas) {</p>

<pre><code>if (!mClockwise) {
    canvas.scale(-1, 1, mArcRect.centerX(), mArcRect.centerY());
}

// draw the text
String textPoint = String.valueOf(mPoints);
mTextPaint.getTextBounds(textPoint, 0, textPoint.length(), mTextRect);
// center the text
int xPos = canvas.getWidth() / 2 - mTextRect.width() / 2;
int yPos = (int)((mArcRect.centerY()) - ((mTextPaint.descent() + mTextPaint.ascent()) / 2));
canvas.drawText(String.valueOf(mPoints), xPos, yPos, mTextPaint);

// draw the arc and progress
canvas.drawArc(mArcRect, ANGLE_OFFSET, 360, false, mArcPaint);
canvas.drawArc(mArcRect, ANGLE_OFFSET, mProgressSweep, false, mProgressPaint);

if (mEnabled) {
    // draw the indicator icon
    canvas.translate(mTranslateX - mIndicatorIconX, mTranslateY - mIndicatorIconY);
    mIndicatorIcon.draw(canvas);
}
</code></pre>

<p>}
```</p>

<p>After overriding <code>onDraw()</code> method, there is one more important method about drawing to introduce: <code>invalidate()</code>, this method is used when any redrawing is needed, we won’t call <code>onDraw()</code> directly, we just call this method instead, you can use this method anywhere inside your custom view, however, for performance optimization, make sure it’s called as infrequently as possible.</p>

<h2>4. Touching:</h2>

<p>When the user touch the screen, Android calls the <code>onTouchEvent()</code> method, so we override <code>View.onTouchEvent()</code> to handle the user input gestures:</p>

<p>```java
@Override
public boolean onTouchEvent(MotionEvent event) {</p>

<pre><code>if (mEnabled) {
    this.getParent().requestDisallowInterceptTouchEvent(true);

    switch (event.getAction()) {
        case MotionEvent.ACTION_DOWN:
            if (mOnSwagPointsChangeListener != null)
                mOnSwagPointsChangeListener.onStartTrackingTouch(this);
            updateOnTouch(event);
            break;
        case MotionEvent.ACTION_MOVE:
            updateOnTouch(event);
            break;
        case MotionEvent.ACTION_UP:
            if (mOnSwagPointsChangeListener != null)
                mOnSwagPointsChangeListener.onStopTrackingTouch(this);
            setPressed(false);
            this.getParent().requestDisallowInterceptTouchEvent(false);
            break;
        case MotionEvent.ACTION_CANCEL:
            if (mOnSwagPointsChangeListener != null)
                mOnSwagPointsChangeListener.onStopTrackingTouch(this);
            setPressed(false);
            this.getParent().requestDisallowInterceptTouchEvent(false);
            break;
    }
    return true;
}
return false;
</code></pre>

<p>}
```</p>

<p>There are several things we have to control when user touches the indicator or other place of view:</p>

<ul>
<li><p>Update the indicator icon position and progress text.</p></li>
<li><p>Draw the current progress on the arc.</p></li>
<li><p>Stop when reaching max or min.</p></li>
</ul>


<p>To know the indicator icon position and the current progress to draw, we have to convert the touch coordinate on the screen to the angle of arc.</p>

<p>In our custom view, we consider the center of arc as origin <code>(0, 0)</code>, and use trigonometric functions to transform the touch coordinate into the angle of the arc in degree <code>(0, 360)</code>, and map to the current progress value of given range <code>(min, max)</code>.</p>

<center><img src="http://Solarex.github.io/images/custom_view_touch.png"/></center>


<p>Here we have a method to convert from touch coordinate to the arc angle:</p>

<p>```java
private double convertTouchEventPointToAngle(float xPos, float yPos) {</p>

<pre><code>// transform touch coordinate into component coordinate
float x = xPos - mTranslateX;
float y = yPos - mTranslateY;

x = (mClockwise) ? x : -x;
double angle = Math.toDegrees(Math.atan2(y, x) + (Math.PI / 2));
angle = (angle &lt; 0) ? (angle + 360) : angle;
return angle;
</code></pre>

<p>}
```</p>

<h2>Final demo</h2>

<center><img src="http://Solarex.github.io/images/custom_view_final_demo.gif"/></center>


<h2>Open source at GitHub:</h2>

<p>So you just finish a android custom view project, great! Let’s put on GitHub to get more developers to use you project. However, before you share your GitHub link to others, just make sure you have a nice document first. When developers are looking at you project, there are some points they care about:</p>

<ul>
<li><p>Does this project fit my requirement or solve my problem?</p></li>
<li><p>If the answer is YES, how can I get starting right now?</p></li>
</ul>


<p>A nice document is like a salesman for you project. The README plays this important role to give the first impression to the developers who are looking at your project, so providing a well-documented README is necessary and gives you more chance to promote you project.</p>

<p>Knowing how to write a REAME is equivalently important to write a clean code or design a great architecture.</p>

<h3>1. Provide a screenshot and short description:</h3>

<p>A picture is worth a thousand words, especially in a UI widget project, make sure that you provide a photo, GIF or video with a short description to demonstrate how your UI looks like or works. (If you are familiar with some design software, i.e. Sketch or PhotoShop, try to use them to help you make a great cover with the screenshot for your project)</p>

<center><img src="http://Solarex.github.io/images/custom_view_screensot.png"/></center>


<h3>Give easy installation/usage instruction</h3>

<p>Before using you project, developer have to install it first, make sure to give a clean and easy installation instruction to get started. After installing you project successfully, just give some example code snippet to show what your project does, and how the developers can customize what they want, maybe just give a list of customizable attributes or provide an APK to install or sample module to run.</p>

<h2>Publish your library:</h2>

<p>After finish pushing your project to GitHub, there is the last step to get done: publish it so that developers can just add dependency</p>

<p>```bash
dependencies {</p>

<pre><code>...
compile 'com.dualcores.swagpoints:swagpoints:1.0.0'
</code></pre>

<p>}
```</p>

<p>to use you project. Here we go:</p>

<h3>1. Sign-up or sign-in at JFrog Bintray.</h3>

<h3>2. Go to profile page to create a repository, package, and version:</h3>

<p>The repository is the place to host your several projects. You can choose any repository name whatever you want, it doesn’t matter for other developers.</p>

<center><img src="http://Solarex.github.io/images/custom_view_frog_new_repo.png"/></center>


<p>Inside the new repository, you can create a package, that is place to host your project. Your project also can import from GitHub.</p>

<center><img src="http://Solarex.github.io/images/custom_view_frog_import_github.png"/></center>


<p>For each package, you can create several versions, again, you can choose whatever name you want, not restricted to the traditional version number major.minor.patch rule.</p>

<center><img src="http://Solarex.github.io/images/custom_view_frog_create_new_version.png"/></center>


<h3>3. Generate and upload the aar files:</h3>

<p>We use gradle to do this job, here I use this library to help <a href="https://github.com/blundell/release-android-library.">https://github.com/blundell/release-android-library.</a>
Open you library module gradle file, add the following code snippet to buttom of module build.gradle file:</p>

<p><code>bash
// or use the remote copy to keep update with latest changes
apply from: 'https://raw.githubusercontent.com/blundell/release-android-library/master/android-release-aar.gradle'
</code></p>

<p>and JCenter configuration:</p>

<center><img src="http://Solarex.github.io/images/custom_view_frog_build_gradle.png"/></center>


<p>then, sync your project and open your terminal, go to your project root path, execute the command:</p>

<p><code>bash
./gradlew clean build generateRelease
</code></p>

<p>If success, you will see the result in you terminal and you can upload the zip file from <code>PROJECT_ROOT/library/build/release/1.0.0/</code>:</p>

<center><img src="http://Solarex.github.io/images/custom_view_frog_generate_aar.png"/></center>


<h3>4. Add to JCenter:</h3>

<p>Go back to your project page in bintray, there will be a Add to JCenter button in right-hand column, just click it to fill out a message and wait to be accepted. It takes hours or several days to be accepted, just be patient. This step is required so that to make your project downloadable and discoverable by gradle dependencies.</p>

<center><img src="http://Solarex.github.io/images/custom_view_frog_add_jcenter.png"/></center>


<h3>5. Project is accepted and test if everything is all right:</h3>

<p>You will receive an email to inform you that your Add to JCenter request is accepted.Once it is accepted, test if gradle dependency works well by adding the dependency to sample module and sync. If it builds successfully, congratulation!!!! You’ve done. Good job~</p>

<p><code>bash
compile 'com.dualcores.swagpoints:swagpoints:1.0.0'
</code></p>
]]></content>
  </entry>
  
</feed>
