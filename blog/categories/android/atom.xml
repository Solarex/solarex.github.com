<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: android | Solarex's Blog]]></title>
  <link href="http://Solarex.github.io/blog/categories/android/atom.xml" rel="self"/>
  <link href="http://Solarex.github.io/"/>
  <updated>2019-09-11T21:36:49+08:00</updated>
  <id>http://Solarex.github.io/</id>
  <author>
    <name><![CDATA[Solarex]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[自定义View总结三]]></title>
    <link href="http://Solarex.github.io/blog/2019/03/12/summary-of-custom-views-part-iii/"/>
    <updated>2019-03-12T00:34:00+08:00</updated>
    <id>http://Solarex.github.io/blog/2019/03/12/summary-of-custom-views-part-iii</id>
    <content type="html"><![CDATA[<h3>自定义View总结 &ndash; 触摸反馈</h3>

<p>之前分析了<a href="http://solarex.github.io/blog/2018/03/25/android-touch-system/">Android触摸事件分发机制</a>，在自定义View的时候进行触摸反馈，一般都是重写<code>onTouchEvent</code>，当然也有一些工具类可以使用，本文就对这些工具类进行总结，他们是<code>ViewConfiguration</code>，<code>Scroller</code>，<code>OverScroller</code>，<code>VelocityTracker</code>，<code>GestureDetector</code>，<code>ScaleGestureDetector</code>，<code>ViewDragHelper</code>。</p>

<!-- more -->


<h4>ViewConfiguration</h4>

<p><code>ViewConfiguration</code>定义了一些UI系统用用到的常量，包括timeouts,sizes,distances。timeouts比如<code>DEFAULT_LONG_PRESS_TIMEOUT</code>,<code>DOUBLE_TAP_TIMEOUT</code>等，sizes包括<code>SCROLL_BAR_SIZE</code>等，distances我们平时自定义View的时候可能用的比较多，常用的有<code>getScaledTouchSlop</code>来判断是否是滑动，<code>getScaledPagingTouchSlop</code>来判断是否是翻页滑动，自己写<code>ViewPager</code>的时候可以用到，<code>getScaledMaximumFlingVelocity</code>和<code>getMinimumFlingVelocity</code>来对惯性滑动进行判断处理。</p>

<h3>Scroller &amp; OverScroller</h3>

<p><code>View</code>的<code>scrollTo</code>和<code>scrollBy</code>是瞬间完成的，如果需要<code>View</code>的滑动有个动画效果，说白了，就是View的位置移动有段时间间隔，可以使用<code>Scroller</code>或<code>OverScroller</code>来完成。<code>Scroller</code>本身无法让View滑动，它主要是个计算器，得配合View的<code>computeScroll</code>使用才能完成这个功能，或者不使用View的<code>computeScroll</code>，你自己写个<code>Runnable</code>，在<code>Runnable</code>里面进行<code>Scroller</code>计算完成的判断并调用View的<code>scrollTo</code>，然后再<code>postOnAnimation(this)</code>将自身传入再次调用即可。</p>

<p>使用<code>computeScroll</code>的样板代码如下：</p>

<p>```java
Scroller scroller = new Scroller(context);</p>

<p>// 缓慢滚动到指定位置
private void smoothScrollTo(int destX, int destY) {</p>

<pre><code>int scrollx = getScrollX();
int dx = destX - scrollx;
scroller.startScroll(scrollx, 0, dx, 0, 1000);
// 这步很重要，触发下面的 computeScroll
invalidate();
</code></pre>

<p>}</p>

<p>@Override
public void computeScroll() {</p>

<pre><code>if(scroller.computeScrollOffset()) {
    scrollTo(scroller.getCurrX(), scroller.getCurrY());
    // 这步继续触发 computeScroll，Scroller会更新x,y，View继续scrollTo新位置
    postInvalidate();或者invalidate();
}
</code></pre>

<p>}
```</p>

<p><code>OverScroller</code>的<code>startScroll</code>，<code>fling</code>方法和<code>Scroller</code>类似，不再赘述，除此之外<code>OverScroller</code>还有一个带over参数的<code>fling</code>函数<code>public void fling(int startX, int startY, int velocityX, int velocityY, int minX, int maxX, int minY, int maxY, int overX, int overY)</code>可以滑动超出View的边界。</p>

<h4>VelocityTracker</h4>

<p>速度追踪，用于追踪手指在滑动过程中的速度，包括水平和垂直方向的速度，一般配合<code>Scroller</code>的<code>fling</code>使用。它的使用过程很简单，首先，在View的<code>onTouchEvent</code>方法中追踪当前单击事件的速度：</p>

<p><code>java
// onTouchEvent
VelocityTracker velocityTracker = VelocityTracker.obtain();
velocityTracker.addMovement(event);
</code></p>

<p>接着，在手指抬起，也就是<code>ACTION_UP</code>的时候，获取速度：</p>

<p><code>java
// onTouchEvent ACTION_UP
velocityTracker.computeCurrentVelocity(1000);
int xVel = (int) velocityTracker.getXVelocity();
int yVel = (int) velocityTracker.getYVelocity();
/* do something like fling */
velocityTracker.clear();
velocityTracker.recycle(); // 重置并回收
</code></p>

<p>速度的计算公式是<code>速度=(终点位置 - 起点位置)/时间段</code>，所以逆着手机坐标系的正方向滑动，所产生的速度为负值。另外记得要重置并回收<code>VelocityTracker</code>。</p>

<h4>GestureDetector &amp; ScaleGestureDetector</h4>

<p><code>GestureDetector</code>手势检测，用于辅助检测用户的单击、滑动、长按、双击等行为。<code>ScaleGestureDetector</code>主要是双指或多指的pinch zoom放大缩小行为。要使用<code>GestureDetector</code>也很简单，参考如下过程。</p>

<p>首先，创建<code>GestureDetector</code>对象并实现<code>GestureDetector.OnGestureListener</code>接口，根据需要也可以实现<code>GestureDetector.OnDoubleTapListener</code>接口或者<code>GestureDetector.OnContextClickListener</code>接口，或者使用<code>SimpleOnGestureListener</code>来在自己感兴趣的方法中做处理。</p>

<table>
<thead>
<tr>
<th></th>
<th align="center">        方法名        </th>
<th align="center">                             描述                             </th>
<th align="center">      所属接口       </th>
</tr>
</thead>
<tbody>
<tr>
<td></td>
<td align="center">        onDown        </td>
<td align="center">            手指轻触屏幕，由1个<code>ACTION_DOWN</code>触发            </td>
<td align="center">  OnGestureListener  </td>
</tr>
<tr>
<td></td>
<td align="center">     onShowPress      </td>
<td align="center">    手指轻触屏幕，尚未松开或拖动，由1个<code>ACTION_DOWN</code>触发    </td>
<td align="center">  OnGestureListener  </td>
</tr>
<tr>
<td></td>
<td align="center">    onSingleTapUp     </td>
<td align="center">   手指轻触屏幕后松开，随着<code>ACTION_UP</code>触发，这是单击行为    </td>
<td align="center">  OnGestureListener  </td>
</tr>
<tr>
<td></td>
<td align="center">       onScroll       </td>
<td align="center"> 手指按下屏幕并拖动，由1个<code>ACTION_DOWN</code>及多个<code>ACTION_MOVE</code>触发，这是拖动行为 </td>
<td align="center">  OnGestureListener  </td>
</tr>
<tr>
<td></td>
<td align="center">     onLongPress      </td>
<td align="center">                             长按                             </td>
<td align="center">  OnGestureListener  </td>
</tr>
<tr>
<td></td>
<td align="center">       onFling        </td>
<td align="center"> 按下屏幕快速滑动后松开，由1个<code>ACTION_DOWN</code>多个<code>ACTION_MOVE</code>和1个<code>ACTION_UP</code>触发，快速滑动 </td>
<td align="center">  OnGestureListener  </td>
</tr>
<tr>
<td></td>
<td align="center">     onDoubleTap      </td>
<td align="center"> 双击，由2次连续的单击组成，不可能和onSingleTapConfirmed共存  </td>
<td align="center"> OnDoubleTapListener </td>
</tr>
<tr>
<td></td>
<td align="center"> onSingleTapConfirmed </td>
<td align="center">                        严格的单击行为                        </td>
<td align="center"> OnDoubleTapListener </td>
</tr>
<tr>
<td></td>
<td align="center">   onDoubleTapEvent   </td>
<td align="center"> 发生了双击行为，在双击期间，<code>ACTION_DOWN</code>、<code>ACTION_MOVE</code>、<code>ACTION_UP</code>都会触发此回调 </td>
<td align="center"> OnDoubleTapListener </td>
</tr>
</tbody>
</table>


<p>接着，接管目标View的<code>onTouchEvent</code>方法</p>

<p><code>java
// onTouchEvent
boolean consume = mGestureDetector.onTouchEvent(event);
return consume;
</code></p>

<p>事件经过判断后就会回调我们实现的listener中的方法。如果只是监听滑动相关的可以自己在<code>onTouchEvent</code>方法的<code>ACTION_MOVE</code>中调用<code>View</code>的<code>scrollTo(x,y)</code>来实现View的滑动，如果是监听双击这种行为的话，就使用<code>GestureDetector</code>。</p>

<p><code>ScaleGestureDetector</code>是处理放大缩小手势的，使用和<code>GestureDetector</code>类似。</p>

<table>
<thead>
<tr>
<th></th>
<th align="center">                           方法名                            </th>
<th align="center">                             描述                             </th>
<th align="center">        所属接口        </th>
</tr>
</thead>
<tbody>
<tr>
<td></td>
<td align="center">   public boolean onScale(ScaleGestureDetector detector);    </td>
<td align="center"> 通过调用detector.getScaleFactor来获得放大的系数，来进行进一步处理，比如对ImageView的Matrix进行操作等等，返回值代表事件有没有被消费 </td>
<td align="center"> OnScaleGestureListener |</td>
</tr>
<tr>
<td></td>
<td align="center"> public boolean onScaleBegin(ScaleGestureDetector detector); </td>
<td align="center"> 如果要检测放大缩小手势，返回true，类似于<code>ACTION_DOWN</code>对事件感兴趣返回true </td>
<td align="center"> OnScaleGestureListener |</td>
</tr>
<tr>
<td></td>
<td align="center">   public void onScaleEnd(ScaleGestureDetector detector);    </td>
<td align="center"> 放大或缩小结束，可以调用detector.getFocusX()或detector.getFocusY()来获取焦点 </td>
<td align="center"> OnScaleGestureListener |</td>
</tr>
</tbody>
</table>


<h3>ViewDragHelper &amp; View.OnDragListener</h3>

<p><code>ViewDragHelper</code>可以实现各种不同的滑动、拖放需求，使用参考如下过程。<code>ViewDragHelper</code>一般在自定义<code>ViewGroup</code>中使用。</p>

<p>首先，初始化<code>ViewDragHelper</code>，实现<code>ViewDragHelper.Callback</code>。<code>mViewDragHelper = ViewDragHelper.create(viewgroup, callback);</code></p>

<p>然后，接管ViewGroup的事件处理，样板代码如下：</p>

<p>```java
@Override
public boolean onInterceptTouchEvent(MotionEvent ev) {</p>

<pre><code>return mViewDragHelper.shouldInterceptTouchEvent(ev);
</code></pre>

<p>}</p>

<p>@Override
public boolean onTouchEvent(MotionEvent ev) {</p>

<pre><code>mViewDragHelper.processTouchEvent(ev);
return true;
</code></pre>

<p>}
```</p>

<p>接着，处理<code>computeScroll</code>，<code>ViewDragHelper</code>内部也是通过<code>Scroller</code>来实现平滑移动的，样板代码如下：</p>

<p>```java
@Override
public void computeScroll() {</p>

<pre><code>if(mViewDragHelper.continueSettling(true)) {
    ViewCompat.postInvalidateOnAnimation(this);
}
</code></pre>

<p>}
```</p>

<table>
<thead>
<tr>
<th></th>
<th align="center">                            方法名                            </th>
<th align="center">                             描述                             </th>
<th align="center">        所属接口         </th>
</tr>
</thead>
<tbody>
<tr>
<td></td>
<td align="center"> public abstract boolean tryCaptureView(View child, int pointerId); </td>
<td align="center">                哪个子View可以被拖动就返回true                </td>
<td align="center"> ViewDragHelper.Callback |</td>
</tr>
<tr>
<td></td>
<td align="center"> public int clampViewPositionVertical(View child, int top, int dy) {     return 0; } </td>
<td align="center">             限制被捕捉的View垂直方向上活动的范围             </td>
<td align="center"> ViewDragHelper.Callback |</td>
</tr>
<tr>
<td></td>
<td align="center"> public int clampViewPositionHorizontal(View child, int left, int dx) {     return 0; } </td>
<td align="center">              限制被捕捉View水平方向上活动的范围              </td>
<td align="center"> ViewDragHelper.Callback |</td>
</tr>
<tr>
<td></td>
<td align="center"> public void onViewCaptured(View capturedChild, int activePointerId) {} </td>
<td align="center">                    View被捕捉的时候被调用                    </td>
<td align="center"> ViewDragHelper.Callback |</td>
</tr>
<tr>
<td></td>
<td align="center"> public void onViewPositionChanged(View changedView, int left, int top, int dx, int dy) {} </td>
<td align="center">                被捕捉的View位置发生变化时调用                </td>
<td align="center"> ViewDragHelper.Callback |</td>
</tr>
<tr>
<td></td>
<td align="center">       public void onViewDragStateChanged(int state) {}       </td>
<td align="center"> drag state变化时调用，STATE_IDLE，STATE_DRAGGING，STATE_SETTLING </td>
<td align="center"> ViewDragHelper.Callback |</td>
</tr>
<tr>
<td></td>
<td align="center"> public void onViewReleased(View releasedChild, float xvel, float yvel) {} </td>
<td align="center">                       View被松开时调用                       </td>
<td align="center"> ViewDragHelper.Callback |</td>
</tr>
<tr>
<td></td>
<td align="center">  public void onEdgeTouched(int edgeFlags, int pointerId) {}  </td>
<td align="center">            没有View被捕捉，父View的边缘被touch到             </td>
<td align="center"> ViewDragHelper.Callback |</td>
</tr>
<tr>
<td></td>
<td align="center"> public boolean onEdgeLock(int edgeFlags) {     return false; } </td>
<td align="center">                                                              </td>
<td align="center"> ViewDragHelper.Callback |</td>
</tr>
<tr>
<td></td>
<td align="center"> public void onEdgeDragStarted(int edgeFlags, int pointerId) {} </td>
<td align="center">                                                              </td>
<td align="center"> ViewDragHelper.Callback |</td>
</tr>
<tr>
<td></td>
<td align="center"> public int getOrderedChildIndex(int index) {     return index; } </td>
<td align="center">                                                              </td>
<td align="center"> ViewDragHelper.Callback |</td>
</tr>
<tr>
<td></td>
<td align="center"> public int getViewHorizontalDragRange(View child) {     return 0; } </td>
<td align="center">                                                              </td>
<td align="center"> ViewDragHelper.Callback |</td>
</tr>
<tr>
<td></td>
<td align="center"> public int getViewVerticalDragRange(View child) {     return 0; } </td>
<td align="center">                                                              </td>
<td align="center"> ViewDragHelper.Callback |</td>
</tr>
</tbody>
</table>


<p><code>View.OnDragListener</code>只有一个方法<code>boolean onDrag(View v, DragEvent event);</code>，当拖拽事件被分发到View时调用。<code>DragEvent</code>有几个状态可以在其中做处理<code>ACTION_DRAG_STARTED</code>，<code>ACTION_DRAG_ENDED</code>，<code>ACTION_DRAG_ENTERED</code>，<code>ACTION_DRAG_EXITED</code>。View开始拖动可以调用<code>ViewCompat.startDragAndDrop(@NonNull View v, ClipData data,View.DragShadowBuilder shadowBuilder, Object localState, int flags)</code>来开始拖动，这样会在View上方出现一个Shadow来表示被拖动的View。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[自定义View总结二]]></title>
    <link href="http://Solarex.github.io/blog/2019/02/12/summary-of-custom-views-part-ii/"/>
    <updated>2019-02-12T00:34:00+08:00</updated>
    <id>http://Solarex.github.io/blog/2019/02/12/summary-of-custom-views-part-ii</id>
    <content type="html"><![CDATA[<h3>自定义View总结 &ndash; 布局</h3>

<h4>布局基础</h4>

<p>布局过程，就是程序在运行时利用布局文件中的代码来计算出实际尺寸和位置的过程。有两个阶段，测量阶段和布局阶段，分别对应<code>measure</code>和<code>layout</code>。</p>

<p>对于一个<code>View</code>而言，默认的<code>onMeasure</code>实现是：</p>

<!-- more -->


<p>```java</p>

<pre><code>/**
 * &lt;p&gt;
 * Measure the view and its content to determine the measured width and the
 * measured height. This method is invoked by {@link #measure(int, int)} and
 * should be overridden by subclasses to provide accurate and efficient
 * measurement of their contents.
 * &lt;/p&gt;
 *
 * &lt;p&gt;
 * &lt;strong&gt;CONTRACT:&lt;/strong&gt; When overriding this method, you
 * &lt;em&gt;must&lt;/em&gt; call {@link #setMeasuredDimension(int, int)} to store the
 * measured width and height of this view. Failure to do so will trigger an
 * &lt;code&gt;IllegalStateException&lt;/code&gt;, thrown by
 * {@link #measure(int, int)}. Calling the superclass'
 * {@link #onMeasure(int, int)} is a valid use.
 * &lt;/p&gt;
 *
 * &lt;p&gt;
 * The base class implementation of measure defaults to the background size,
 * unless a larger size is allowed by the MeasureSpec. Subclasses should
 * override {@link #onMeasure(int, int)} to provide better measurements of
 * their content.
 * &lt;/p&gt;
 *
 * &lt;p&gt;
 * If this method is overridden, it is the subclass's responsibility to make
 * sure the measured height and width are at least the view's minimum height
 * and width ({@link #getSuggestedMinimumHeight()} and
 * {@link #getSuggestedMinimumWidth()}).
 * &lt;/p&gt;
 *
 * @param widthMeasureSpec horizontal space requirements as imposed by the parent.
 *                         The requirements are encoded with
 *                         {@link android.view.View.MeasureSpec}.
 * @param heightMeasureSpec vertical space requirements as imposed by the parent.
 *                         The requirements are encoded with
 *                         {@link android.view.View.MeasureSpec}.
 *
 * @see #getMeasuredWidth()
 * @see #getMeasuredHeight()
 * @see #setMeasuredDimension(int, int)
 * @see #getSuggestedMinimumHeight()
 * @see #getSuggestedMinimumWidth()
 * @see android.view.View.MeasureSpec#getMode(int)
 * @see android.view.View.MeasureSpec#getSize(int)
 */
protected void onMeasure(int widthMeasureSpec, int heightMeasureSpec) {
    setMeasuredDimension(getDefaultSize(getSuggestedMinimumWidth(), widthMeasureSpec),
            getDefaultSize(getSuggestedMinimumHeight(), heightMeasureSpec));
}

/**
 * Utility to return a default size. Uses the supplied size if the
 * MeasureSpec imposed no constraints. Will get larger if allowed
 * by the MeasureSpec.
 *
 * @param size Default size for this view
 * @param measureSpec Constraints imposed by the parent
 * @return The size this view should be.
 */
public static int getDefaultSize(int size, int measureSpec) {
    int result = size;
    int specMode = MeasureSpec.getMode(measureSpec);
    int specSize = MeasureSpec.getSize(measureSpec);

    switch (specMode) {
    case MeasureSpec.UNSPECIFIED:
        result = size;
        break;
    case MeasureSpec.AT_MOST:
    case MeasureSpec.EXACTLY:
        result = specSize;
        break;
    }
    return result;
}

/**
 * Returns the suggested minimum width that the view should use. This
 * returns the maximum of the view's minimum width
 * and the background's minimum width
 *  ({@link android.graphics.drawable.Drawable#getMinimumWidth()}).
 * &lt;p&gt;
 * When being used in {@link #onMeasure(int, int)}, the caller should still
 * ensure the returned width is within the requirements of the parent.
 *
 * @return The suggested minimum width of the view.
 */
protected int getSuggestedMinimumWidth() {
    return (mBackground == null) ? mMinWidth : max(mMinWidth, mBackground.getMinimumWidth());
}
</code></pre>

<p>```</p>

<p>可以看到在<code>getDefault</code>方法中对<code>AT_MOST</code>(<code>wrap_content</code>)和<code>EXACTLY</code>(<code>match_parent</code>)的处理都是用父View的size来作为了子View的size，这种处理有的时候是不合适的，需要我们额外做些处理，下面是一个在写自定义View的时候的一个utils方法：</p>

<p>```java</p>

<pre><code>public static int measure(int measureSpec, int defaultSize){
    int result = defaultSize;
    int specMode = View.MeasureSpec.getMode(measureSpec);
    int specSize = View.MeasureSpec.getSize(measureSpec);
    if (specMode == View.MeasureSpec.EXACTLY){
        result = specSize;
    } else if (specMode == View.MeasureSpec.AT_MOST){
        result = Math.min(specSize, defaultSize);
    }
    return result;
}
</code></pre>

<p>```</p>

<p>测量阶段，<code>measure()</code>方法被父View调用，在<code>measure()</code>中做一些准备和优化工作后，调用<code>onMeasure()</code>来进行实际的自我测量。<code>onMeasure()</code>中做的事，<code>View</code>和<code>ViewGroup</code>不太一样：</p>

<ul>
<li><code>View</code>在<code>onMeasure()</code>中根据父View传过来的MeasureSpec约束计算自己的大小并调用<code>setMeasuredDimension</code>保存下来。</li>
<li><code>ViewGroup</code>在<code>onMeasure</code>中调用<code>measureChildren</code>测量子View，并根据子View计算出的期望大小来计算出它们的实际尺寸和位置然后保存。同时根据子View的尺寸和位置来计算出自己的尺寸并保存。</li>
</ul>


<p>在<code>ViewGroup</code>测量子View的时候，也就是调用<code>childView.measure()</code>的时候需要将自己的约束MeasureSpec传递给子View，这个MeasureSpec如何计算，下面会说。回到最顶层的父View，也即<code>DecorView</code>，它的MeasureSpec是<code>LayoutParams.MATCH_PARENT, LayoutParams.MATCH_PARENT</code>。</p>

<p>布局过程，<code>layout()</code>方法被父View调用，在<code>layout()</code>方法中它会保存父View传进来的自己的位置和尺寸，并且调用<code>onLayout</code>来进行实际的内部布局。<code>onLayout</code>中做的事，<code>View</code>和<code>ViewGroup</code>也不一样：</p>

<ul>
<li><code>View</code>由于没有子View，它的<code>onLayout</code>什么也不做</li>
<li><code>ViewGroup</code>在<code>onLayout</code>中会调用自己所有子View的<code>layout</code>方法，把它们的尺寸和位置传给它们，让它们完成自我的内部布局。</li>
</ul>


<h4>全新定义 View 的尺寸</h4>

<p>子View在计算的时候需要保证计算结果满足父View MeasureSpec对自己的尺寸限制。<code>ViewGroup</code>提供了几个工具方法供我们调用：</p>

<p>```</p>

<pre><code>/**
 * Ask all of the children of this view to measure themselves, taking into
 * account both the MeasureSpec requirements for this view and its padding.
 * We skip children that are in the GONE state The heavy lifting is done in
 * getChildMeasureSpec.
 *
 * @param widthMeasureSpec The width requirements for this view
 * @param heightMeasureSpec The height requirements for this view
 */
protected void measureChildren(int widthMeasureSpec, int heightMeasureSpec) {
    final int size = mChildrenCount;
    final View[] children = mChildren;
    for (int i = 0; i &lt; size; ++i) {
        final View child = children[i];
        if ((child.mViewFlags &amp; VISIBILITY_MASK) != GONE) {
            measureChild(child, widthMeasureSpec, heightMeasureSpec);
        }
    }
}

/**
 * Ask one of the children of this view to measure itself, taking into
 * account both the MeasureSpec requirements for this view and its padding.
 * The heavy lifting is done in getChildMeasureSpec.
 *
 * @param child The child to measure
 * @param parentWidthMeasureSpec The width requirements for this view
 * @param parentHeightMeasureSpec The height requirements for this view
 */
protected void measureChild(View child, int parentWidthMeasureSpec,
        int parentHeightMeasureSpec) {
    final LayoutParams lp = child.getLayoutParams();

    final int childWidthMeasureSpec = getChildMeasureSpec(parentWidthMeasureSpec,
            mPaddingLeft + mPaddingRight, lp.width);
    final int childHeightMeasureSpec = getChildMeasureSpec(parentHeightMeasureSpec,
            mPaddingTop + mPaddingBottom, lp.height);

    child.measure(childWidthMeasureSpec, childHeightMeasureSpec);
}

/**
 * Does the hard part of measureChildren: figuring out the MeasureSpec to
 * pass to a particular child. This method figures out the right MeasureSpec
 * for one dimension (height or width) of one child view.
 *
 * The goal is to combine information from our MeasureSpec with the
 * LayoutParams of the child to get the best possible results. For example,
 * if the this view knows its size (because its MeasureSpec has a mode of
 * EXACTLY), and the child has indicated in its LayoutParams that it wants
 * to be the same size as the parent, the parent should ask the child to
 * layout given an exact size.
 *
 * @param spec The requirements for this view
 * @param padding The padding of this view for the current dimension and
 *        margins, if applicable
 * @param childDimension How big the child wants to be in the current
 *        dimension
 * @return a MeasureSpec integer for the child
 */
public static int getChildMeasureSpec(int spec, int padding, int childDimension) {
    int specMode = MeasureSpec.getMode(spec);
    int specSize = MeasureSpec.getSize(spec);

    int size = Math.max(0, specSize - padding);

    int resultSize = 0;
    int resultMode = 0;

    switch (specMode) {
    // Parent has imposed an exact size on us
    case MeasureSpec.EXACTLY:
        if (childDimension &gt;= 0) {
            resultSize = childDimension;
            resultMode = MeasureSpec.EXACTLY;
        } else if (childDimension == LayoutParams.MATCH_PARENT) {
            // Child wants to be our size. So be it.
            resultSize = size;
            resultMode = MeasureSpec.EXACTLY;
        } else if (childDimension == LayoutParams.WRAP_CONTENT) {
            // Child wants to determine its own size. It can't be
            // bigger than us.
            resultSize = size;
            resultMode = MeasureSpec.AT_MOST;
        }
        break;

    // Parent has imposed a maximum size on us
    case MeasureSpec.AT_MOST:
        if (childDimension &gt;= 0) {
            // Child wants a specific size... so be it
            resultSize = childDimension;
            resultMode = MeasureSpec.EXACTLY;
        } else if (childDimension == LayoutParams.MATCH_PARENT) {
            // Child wants to be our size, but our size is not fixed.
            // Constrain child to not be bigger than us.
            resultSize = size;
            resultMode = MeasureSpec.AT_MOST;
        } else if (childDimension == LayoutParams.WRAP_CONTENT) {
            // Child wants to determine its own size. It can't be
            // bigger than us.
            resultSize = size;
            resultMode = MeasureSpec.AT_MOST;
        }
        break;

    // Parent asked to see how big we want to be
    case MeasureSpec.UNSPECIFIED:
        if (childDimension &gt;= 0) {
            // Child wants a specific size... let him have it
            resultSize = childDimension;
            resultMode = MeasureSpec.EXACTLY;
        } else if (childDimension == LayoutParams.MATCH_PARENT) {
            // Child wants to be our size... find out how big it should
            // be
            resultSize = View.sUseZeroUnspecifiedMeasureSpec ? 0 : size;
            resultMode = MeasureSpec.UNSPECIFIED;
        } else if (childDimension == LayoutParams.WRAP_CONTENT) {
            // Child wants to determine its own size.... find out how
            // big it should be
            resultSize = View.sUseZeroUnspecifiedMeasureSpec ? 0 : size;
            resultMode = MeasureSpec.UNSPECIFIED;
        }
        break;
    }
    //noinspection ResourceType
    return MeasureSpec.makeMeasureSpec(resultSize, resultMode);
}
</code></pre>

<p>```</p>

<p>可以看到子View<code>MeasureSpec</code>是由3个因素共同决定的，父View的<code>MeasureSpec</code>，<code>padding</code>，<code>LayoutParams</code>中的值，其中父View的<code>MeasureSpec</code>是从<code>DecorView</code>一层层约束下来得到的，不难理解，那<code>LayoutParams</code>是从哪里来的呢？   其实<code>LayoutParams</code>是在<code>LayoutInflater</code>解析xml布局的时候，父布局会根据xml中的<code>layout_width</code>和<code>layout_height</code>来给子View<code>generateLayoutParams</code>保存在子View中，所以，可以认为子View的<code>LayoutParams</code>实际上保存的是布局中的开发者对View的要求。</p>

<p>着重看下<code>getChildMeasureSpec</code>这个方法，这个方法对父View尺寸有无限制的情况下子View的大小应该如何进行了处理，注释的比较清楚，就不解释了。</p>

<h4>定制 Layout(ViewGroup) 的内部布局</h4>

<p>通过重写<code>onMeasure()</code>来计算内部布局，重写<code>onLayout</code>来摆放子View。</p>

<p>重写<code>onMeasure()</code>的三个步骤：</p>

<ul>
<li>调用每个子View的<code>measure</code>方法来计算子View的尺寸</li>
<li>计算子View的位置并保存子View的位置和尺寸</li>
<li>计算自己的尺寸并用<code>setMeasuredDimension()</code>保存</li>
</ul>


<p>计算子View尺寸的关键在于<code>measure()</code>方法的两个MeasureSpec参数的计算。子View的<code>MeasureSpec</code>的计算方式：</p>

<ul>
<li>结合开发者的要求（xml中的layout_打头的属性）和自己的可用空间（自己的尺寸上限-已用尺寸）</li>
<li>尺寸上限根据自己的<code>MeasureSpec</code>中的mode而定，<code>EXACTLY/AT_MOST</code>尺寸上限为<code>MeasureSpec</code>中的size，<code>UNSPECIFIED</code>尺寸无上限。</li>
</ul>


<p>重写<code>onLayout</code>的方式，在<code>onLayout</code>里调用每个子View的<code>layout()</code>。</p>

<h4>reference</h4>

<ul>
<li><a href="https://hencoder.com/tag/bu-ju/">自定义 View &ndash; 布局</a></li>
</ul>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[自定义View总结一]]></title>
    <link href="http://Solarex.github.io/blog/2019/01/12/summary-of-custom-views-part-i/"/>
    <updated>2019-01-12T00:33:00+08:00</updated>
    <id>http://Solarex.github.io/blog/2019/01/12/summary-of-custom-views-part-i</id>
    <content type="html"><![CDATA[<h2>自定义View总结 &ndash; 绘制</h2>

<h3>绘制基础</h3>

<ul>
<li><code>Canvas.drawColor(@ColorInt int color)</code> 颜色填充</li>
<li><code>drawCircle(float centerX, float centerY, float radius, Paint paint)</code> 画圆</li>
<li><code>Paint.setColor(int color)</code>,<code>Paint.setStyle(Paint.Style style)</code>,<code>Paint.setStrokeWidth(float width)</code>,<code>Paint.setAntiAlias(boolean aa)</code></li>
<li><code>drawRect(float left, float top, float right, float bottom, Paint paint)</code> 画矩形</li>
<li><code>drawPoint(float x, float y, Paint paint)</code> 画点</li>
<li><code>drawPoints(float[] pts, int offset, int count, Paint paint) / drawPoints(float[] pts, Paint paint)</code> 画点（批量）</li>
<li><code>drawOval(float left, float top, float right, float bottom, Paint paint)</code>画椭圆</li>
<li><code>drawLine(float startX, float startY, float stopX, float stopY, Paint paint)</code> 画线</li>
<li><code>drawLines(float[] pts, int offset, int count, Paint paint) / drawLines(float[] pts, Paint paint)</code> 画线（批量）</li>
<li><code>drawRoundRect(float left, float top, float right, float bottom, float rx, float ry, Paint paint)</code> 画圆角矩形</li>
<li><code>drawArc(float left, float top, float right, float bottom, float startAngle, float sweepAngle, boolean useCenter, Paint paint)</code> 绘制弧形或扇形</li>
<li><code>drawPath(Path path, Paint paint)</code> 画自定义图形</li>
<li><code>drawBitmap(Bitmap bitmap, float left, float top, Paint paint)</code> 画 Bitmap</li>
<li><code>drawText(String text, float x, float y, Paint paint)</code>绘制文字</li>
</ul>


<!-- more -->


<h4>Path</h4>

<ul>
<li><code>addCircle(float x, float y, float radius, Direction dir)</code> 添加圆</li>
<li><code>addOval(float left, float top, float right, float bottom, Direction dir) / addOval(RectF oval, Direction dir)</code>添加椭圆</li>
<li><code>addRect(float left, float top, float right, float bottom, Direction dir) / addRect(RectF rect, Direction dir)</code>添加矩形</li>
<li><code>addRoundRect(RectF rect, float rx, float ry, Direction dir) / addRoundRect(float left, float top, float right, float bottom, float rx, float ry, Direction dir) / addRoundRect(RectF rect, float[] radii, Direction dir) / addRoundRect(float left, float top, float right, float bottom, float[] radii, Direction dir)</code>添加圆角矩形</li>
<li><code>addPath(Path path)</code> 添加另一个 Path</li>
<li><code>lineTo(float x, float y) / rLineTo(float x, float y)</code>画直线</li>
<li><code>quadTo(float x1, float y1, float x2, float y2) / rQuadTo(float dx1, float dy1, float dx2, float dy2)</code>画二次贝塞尔曲线</li>
<li><code>cubicTo(float x1, float y1, float x2, float y2, float x3, float y3) / rCubicTo(float x1, float y1, float x2, float y2, float x3, float y3)</code> 画三次贝塞尔曲线</li>
<li><code>moveTo(float x, float y) / rMoveTo(float x, float y)</code>移动到目标位置</li>
<li><code>arcTo(RectF oval, float startAngle, float sweepAngle, boolean forceMoveTo) / arcTo(float left, float top, float right, float bottom, float startAngle, float sweepAngle, boolean forceMoveTo) / arcTo(RectF oval, float startAngle, float sweepAngle)</code> 画弧形</li>
<li><code>addArc(float left, float top, float right, float bottom, float startAngle, float sweepAngle) / addArc(RectF oval, float startAngle, float sweepAngle)</code>,<code>addArc()</code> 只是一个直接使用了 <code>forceMoveTo = true</code> 的简化版 <code>arcTo()</code></li>
<li><code>close()</code>封闭当前子图形</li>
<li><code>Path.setFillType(Path.FillType ft)</code> 设置填充方式</li>
</ul>


<h3>Paint详解</h3>

<center><p><img src="http://Solarex.github.io/images/canvas-color.jpg" alt="Canvas绘制的内容，有三层对颜色的处理"></p></center>


<h4>颜色</h4>

<table>
<thead>
<tr>
<th></th>
<th align="center">     canvas 方法      </th>
<th> 像素颜色的设置方式 </th>
</tr>
</thead>
<tbody>
<tr>
<td></td>
<td align="center"> drawColor/RGB/ARGB() </td>
<td> 直接作为参数传入   |</td>
</tr>
<tr>
<td></td>
<td align="center"> drawBitmap() </td>
<td> 与<code>bitmap</code>参数的像素颜色相同 |</td>
</tr>
<tr>
<td></td>
<td align="center"> 图形和文字(drawCircle()/drawPath()/drawText()&hellip;) </td>
<td> 在<code>paint</code>参数中设置 |</td>
</tr>
</tbody>
</table>


<h5>直接设置颜色<code>Paint.setColor(int color)</code>,<code>Paint.setARGB(int a,int r,int g,int b)</code></h5>

<h5>setShader(Shader shader) 设置shader</h5>

<ul>
<li><p>shader着色器，它和直接设置颜色的区别是，着色器设置的是一个颜色方案，或者说是一套着色规则。</p></li>
<li><p>LinearGradient 线性渐变</p></li>
<li><p>RadialGradient 辐射渐变，辐射渐变很好理解，就是从中心向周围辐射状的渐变。</p></li>
<li><p>SweepGradient 扫描渐变</p></li>
<li><p>BitmapShader 用 Bitmap 来着色，其实也就是用 Bitmap 的像素来作为图形或文字的填充。</p></li>
<li><p>ComposeShader 混合着色器 所谓混合，就是把两个 Shader 一起使用。</p></li>
</ul>


<h5>setColorFilter(ColorFilter colorFilter)</h5>

<p>为绘制设置颜色过滤。颜色过滤的意思，就是为绘制的内容设置一个统一的过滤策略，然后 Canvas.drawXXX() 方法会对每个像素都进行过滤后再绘制出来。</p>

<ul>
<li><code>LightingColorFilter(int mul, int add)</code></li>
</ul>


<p><code>java
R' = R * mul.R / 0xff + add.R  
G' = G * mul.G / 0xff + add.G  
B' = B * mul.B / 0xff + add.B  
</code></p>

<ul>
<li><code>PorterDuffColorFilter(int color, PorterDuff.Mode mode)</code></li>
<li><code>ColorMatrixColorFilter</code></li>
</ul>


<p><code>ColorMatrixColorFilter</code> 使用一个 <code>ColorMatrix</code> 来对颜色进行处理。 <code>ColorMatrix</code> 这个类，内部是一个 4x5 的矩阵：</p>

<p>```java
[ a, b, c, d, e,
  f, g, h, i, j,
  k, l, m, n, o,
  p, q, r, s, t ]</p>

<p>R’ = a<em>R + b</em>G + c<em>B + d</em>A + e;<br/>
G’ = f<em>R + g</em>G + h<em>B + i</em>A + j;<br/>
B’ = k<em>R + l</em>G + m<em>B + n</em>A + o;<br/>
A’ = p<em>R + q</em>G + r<em>B + s</em>A + t;
```</p>

<p><a href="https://github.com/chengdazhi/StyleImageView">StyleImageView</a></p>

<h5>setXfermode(Xfermode xfermode)</h5>

<ul>
<li><p>使用离屏缓冲（Off-screen Buffer）</p></li>
<li><p>控制好透明区域</p></li>
</ul>


<h4>效果</h4>

<h5>setAntiAlias (boolean aa) 设置抗锯齿</h5>

<h5>setStyle(Paint.Style style)</h5>

<h5>线条形状</h5>

<ul>
<li><p><code>setStrokeWidth(float width)</code></p></li>
<li><p><code>setStrokeCap(Paint.Cap cap)</code></p></li>
<li><p><code>setStrokeJoin(Paint.Join join)</code></p></li>
<li><p><code>setStrokeMiter(float miter)</code></p></li>
</ul>


<h5>色彩优化</h5>

<ul>
<li><p><code>setDither(boolean dither)</code> 设置图像的抖动</p></li>
<li><p><code>setFilterBitmap(boolean filter)</code> 设置是否使用双线性过滤来绘制 Bitmap</p></li>
</ul>


<h5>setPathEffect(PathEffect effect)</h5>

<p>使用 <code>PathEffect</code> 来给图形的轮廓设置效果。对 Canvas 所有的图形绘制有效，也就是  <code>drawLine() drawCircle() drawPath()</code> 这些方法。</p>

<ul>
<li><p><code>CornerPathEffect</code> 把所有拐角变成圆角</p></li>
<li><p><code>DiscretePathEffect</code> 把线条进行随机的偏离，让轮廓变得乱七八糟。</p></li>
<li><p><code>DashPathEffect</code> 使用虚线来绘制线条</p></li>
<li><p><code>PathDashPathEffect</code> 这个方法比 DashPathEffect 多一个前缀 Path ，所以顾名思义，它是使用一个 Path 来绘制「虚线」。</p></li>
<li><p><code>SumPathEffect</code> 这是一个组合效果类的 PathEffect 。它的行为特别简单，就是分别按照两种 PathEffect 分别对目标进行绘制。</p></li>
<li><p><code>ComposePathEffect</code> 这也是一个组合效果类的 PathEffect 。不过它是先对目标 Path 使用一个 PathEffect，然后再对这个改变后的 Path 使用另一个 PathEffect。它的构造方法 <code>ComposePathEffect(PathEffect outerpe, PathEffect innerpe)</code> 中的两个  PathEffect 参数， innerpe 是先应用的， outerpe 是后应用的。</p></li>
</ul>


<h5>setShadowLayer(float radius, float dx, float dy, int shadowColor)</h5>

<p>在之后的绘制内容下面加一层阴影。如果要清除阴影层，使用 clearShadowLayer() 。</p>

<ul>
<li><p>在硬件加速开启的情况下， setShadowLayer() 只支持文字的绘制，文字之外的绘制必须关闭硬件加速才能正常绘制阴影。</p></li>
<li><p>如果 shadowColor 是半透明的，阴影的透明度就使用 shadowColor 自己的透明度；而如果 shadowColor 是不透明的，阴影的透明度就使用 paint 的透明度。</p></li>
</ul>


<h5>setMaskFilter(MaskFilter maskfilter)</h5>

<p>为之后的绘制设置 <code>MaskFilter</code>。上一个方法 <code>setShadowLayer()</code> 是设置的在绘制层下方的附加效果；而这个 <code>MaskFilter</code> 和它相反，设置的是在绘制层上方的附加效果。</p>

<ul>
<li><p><code>BlurMaskFilter</code> 模糊效果的 MaskFilter。<code>BlurMaskFilter(float radius, BlurMaskFilter.Blur style)</code> 中， radius 参数是模糊的范围， style 是模糊的类型。NORMAL: 内外都模糊绘制，SOLID: 内部正常绘制，外部模糊，INNER: 内部模糊，外部不绘制，OUTER: 内部不绘制，外部模糊。</p></li>
<li><p><code>EmbossMaskFilter</code> 浮雕效果的 MaskFilter。</p></li>
</ul>


<h5>获取绘制的 Path</h5>

<p>根据 paint 的设置，计算出绘制 Path 或文字时的实际 Path。所谓实际 Path ，指的就是 drawPath() 的绘制内容的轮廓，要算上线条宽度和设置的 PathEffect。</p>

<ul>
<li><p><code>getFillPath(Path src, Path dst)</code>，<code>getFillPath(src, dst)</code> 方法就能获取这个实际 Path。方法的参数里，src 是原 Path ，而 dst 就是实际 Path 的保存位置。 <code>getFillPath(src, dst)</code> 会计算出实际 Path，然后把结果保存在 dst 里。</p></li>
<li><p><code>getTextPath(String text, int start, int end, float x, float y, Path path) / getTextPath(char[] text, int index, int count, float x, float y, Path path)</code> 文字的绘制，虽然是使用 Canvas.drawText() 方法，但其实在下层，文字信息全是被转化成图形，对图形进行绘制的。  getTextPath() 方法，获取的就是目标文字所对应的 Path</p></li>
</ul>


<h4>Paint初始化类</h4>

<ul>
<li><p><code>reset()</code></p></li>
<li><p><code>set(Paint src)</code></p></li>
<li><p><code>setFlags(int flags)</code></p></li>
</ul>


<h3>文字的绘制</h3>

<h5>Canvas 绘制文字的方式</h5>

<ul>
<li><p><code>drawText(String text, float x, float y, Paint paint)</code></p></li>
<li><p><code>drawTextRun()</code></p></li>
<li><p><code>drawTextOnPath()</code></p></li>
<li><p><code>StaticLayout</code></p></li>
</ul>


<h5>Paint 对文字绘制的辅助</h5>

<ul>
<li><p><code>setTextSize(float textSize)</code></p></li>
<li><p><code>setTypeface(Typeface typeface)</code></p></li>
<li><p><code>setFakeBoldText(boolean fakeBoldText)</code> 伪粗体（ fake bold ），因为它并不是通过选用更高 weight 的字体让文字变粗，而是通过程序在运行时把文字给「描粗」了</p></li>
<li><p><code>setStrikeThruText(boolean strikeThruText)</code> 是否加删除线</p></li>
<li><p><code>setUnderlineText(boolean underlineText)</code> 是否加下划线</p></li>
<li><p><code>setTextSkewX(float skewX)</code> 设置文字横向错切角度。其实就是文字倾斜度的啦。</p></li>
<li><p><code>setTextScaleX(float scaleX)</code> 设置文字横向放缩。也就是文字变胖变瘦。</p></li>
<li><p><code>setLetterSpacing(float letterSpacing)</code> 设置字符间距。默认值是 0。</p></li>
<li><p><code>setFontFeatureSettings(String settings)</code></p></li>
<li><p><code>setTextAlign(Paint.Align align)</code> 设置文字的对齐方式。一共有三个值：LEFT CETNER 和 RIGHT。默认值为 LEFT。</p></li>
<li><p><code>setTextLocale(Locale locale) / setTextLocales(LocaleList locales)</code> 设置绘制所使用的 Locale。</p></li>
<li><p><code>setHinting(int mode)</code> 设置是否启用字体的 hinting （字体微调）。</p></li>
<li><p><code>setElegantTextHeight(boolean elegant)</code> 设置是否开启文字的 elegant height 。开启之后，文字的高度就变优雅了</p></li>
<li><p><code>setSubpixelText(boolean subpixelText)</code> 是否开启次像素级的抗锯齿（ sub-pixel anti-aliasing ）。</p></li>
<li><p><code>setLinearText(boolean linearText)</code></p></li>
<li><p><code>hasGlyph(String string)</code> 检查指定的字符串中是否是一个单独的字形 (glyph）。</p></li>
</ul>


<h5>测量文字尺寸类</h5>

<ul>
<li><p><code>float getFontSpacing()</code> 获取推荐的行距。</p></li>
<li><p><code>FontMetircs getFontMetrics()</code> 获取 Paint 的 FontMetrics。<code>FontMetrics</code> 是个相对专业的工具类，它提供了几个文字排印方面的数值：<code>ascent</code>,  <code>descent</code>, <code>top</code>, <code>bottom</code>, <code>leading</code>。<code>ascent</code> 和 <code>descent</code> 这两个值还可以通过 <code>Paint.ascent()</code> 和 <code>Paint.descent()</code> 来快捷获取。</p></li>
<li><p><code>getTextBounds(String text, int start, int end, Rect bounds)</code> 获取文字的显示范围。</p></li>
<li><p><code>float measureText(String text)</code> 测量文字的宽度并返回。</p></li>
</ul>


<p>如果你用代码分别使用 getTextBounds() 和 measureText() 来测量文字的宽度，你会发现  measureText() 测出来的宽度总是比 getTextBounds() 大一点点。这是因为这两个方法其实测量的是两个不一样的东西。getTextBounds: 它测量的是文字的显示范围（关键词：显示）。形象点来说，你这段文字外放置一个可变的矩形，然后把矩形尽可能地缩小，一直小到这个矩形恰好紧紧包裹住文字，那么这个矩形的范围，就是这段文字的 bounds。measureText(): 它测量的是文字绘制时所占用的宽度（关键词：占用）。前面已经讲过，一个文字在界面中，往往需要占用比他的实际显示宽度更多一点的宽度，以此来让文字和文字之间保留一些间距，不会显得过于拥挤。</p>

<ul>
<li><p><code>getTextWidths(String text, float[] widths)</code> 获取字符串中每个字符的宽度，并把结果填入参数 widths。</p></li>
<li><p><code>int breakText(String text, boolean measureForwards, float maxWidth, float[] measuredWidth)</code> 这个方法也是用来测量文字宽度的。但和 measureText() 的区别是， breakText() 是在给出宽度上限的前提下测量文字的宽度。如果文字的宽度超出了上限，那么在临近超限的位置截断文字。</p></li>
</ul>


<h5>光标相关</h5>

<ul>
<li><p><code>getRunAdvance(CharSequence text, int start, int end, int contextStart, int contextEnd, boolean isRtl, int offset)</code> 对于一段文字，计算出某个字符处光标的 x 坐标。</p></li>
<li><p><code>getOffsetForAdvance(CharSequence text, int start, int end, int contextStart, int contextEnd, boolean isRtl, float advance)</code> 给出一个位置的像素值，计算出文字中最接近这个位置的字符偏移量</p></li>
</ul>


<h3>Canvas 对绘制的辅助 clipXXX() 和 Matrix</h3>

<h5>范围裁切</h5>

<p>范围裁切有两个方法： <code>clipRect()</code> 和 <code>clipPath()</code>。裁切方法之后的绘制代码，都会被限制在裁切范围内。</p>

<ul>
<li><p><code>clipRect()</code></p></li>
<li><p><code>clipPath()</code></p></li>
</ul>


<h5>几何变换</h5>

<p>几何变换的使用大概分为三类：</p>

<ul>
<li>使用 Canvas 来做常见的二维变换；</li>
<li>使用 Matrix 来做常见和不常见的二维变换；</li>
<li>使用 Camera 来做三维变换。</li>
</ul>


<h6>使用 Canvas 来做常见的二维变换</h6>

<ul>
<li><p><code>Canvas.translate(float dx, float dy)</code> 平移</p></li>
<li><p><code>Canvas.rotate(float degrees, float px, float py)</code> 旋转</p></li>
<li><p><code>Canvas.scale(float sx, float sy, float px, float py)</code> 放缩</p></li>
<li><p><code>skew(float sx, float sy)</code> 错切</p></li>
</ul>


<h6>使用 Matrix 来做变换</h6>

<p>Matrix 做常见变换的方式：</p>

<ul>
<li>创建 Matrix 对象；</li>
<li>调用 Matrix 的 <code>pre/postTranslate/Rotate/Scale/Skew()</code> 方法来设置几何变换；</li>
<li>使用 <code>Canvas.setMatrix(matrix)</code> 或 <code>Canvas.concat(matrix)</code> 来把几何变换应用到 Canvas。</li>
</ul>


<p>把 Matrix 应用到 Canvas 有两个方法： <code>Canvas.setMatrix(matrix)</code> 和 <code>Canvas.concat(matrix)</code>。</p>

<ul>
<li><code>Canvas.setMatrix(matrix)</code>：用 Matrix 直接替换 Canvas 当前的变换矩阵，即抛弃 Canvas 当前的变换，改用 Matrix 的变换（注：根据下面评论里以及我在微信公众号中收到的反馈，不同的系统中 setMatrix(matrix) 的行为可能不一致，所以还是尽量用  concat(matrix) 吧）；</li>
<li><code>Canvas.concat(matrix)</code>：用 Canvas 当前的变换矩阵和 Matrix 相乘，即基于 Canvas 当前的变换，叠加上 Matrix 中的变换。</li>
</ul>


<p>使用 Matrix 来做自定义变换</p>

<ul>
<li><code>Matrix.setPolyToPoly(float[] src, int srcIndex, float[] dst, int dstIndex, int pointCount)</code> 用点对点映射的方式设置变换。poly 就是「多」的意思。setPolyToPoly() 的作用是通过多点的映射的方式来直接设置变换。「多点映射」的意思就是把指定的点移动到给出的位置，从而发生形变。例如：(0, 0) &ndash;> (100, 100) 表示把 (0, 0) 位置的像素移动到 (100, 100) 的位置，这个是单点的映射，单点映射可以实现平移。而多点的映射，就可以让绘制内容任意地扭曲。</li>
</ul>


<h6>使用 Camera 来做三维变换</h6>

<p>Camera 的三维变换有三类：旋转、平移、移动相机。</p>

<ul>
<li><p><code>Camera.rotate*()</code> 三维旋转 <code>Camera.rotate*()</code> 一共有四个方法： <code>rotateX(deg) rotateY(deg) rotateZ(deg) rotate(x, y, z)</code>。</p></li>
<li><p><code>Camera.translate(float x, float y, float z)</code> 移动</p></li>
<li><p><code>Camera.setLocation(x, y, z)</code> 设置虚拟相机的位置。在 Camera 中，相机的默认位置是 (0, 0, -8)（英寸）。8 x 72 = 576，所以它的默认位置是 (0, 0, -576)（像素）。</p></li>
</ul>


<h3>绘制顺序</h3>

<h5>super.onDraw() 前 or 后？</h5>

<h5><code>dispatchDraw()</code>：绘制子 View 的方法</h5>

<h5>绘制过程简述</h5>

<p>绘制过程中最典型的两个部分是上面讲到的主体和子 View，但它们并不是绘制过程的全部。除此之外，绘制过程还包含一些其他内容的绘制。具体来讲，一个完整的绘制过程会依次绘制以下几个内容：</p>

<ul>
<li>背景</li>
<li>主体（onDraw()）</li>
<li>子 View（dispatchDraw()）</li>
<li>滑动边缘渐变和滑动条</li>
<li>前景</li>
</ul>


<center><p><img src="http://Solarex.github.io/images/canvas-draw-process.jpg"/></p></center>


<h5>onDrawForeground()</h5>

<p>在 onDrawForeground() 中，会依次绘制滑动边缘渐变、滑动条和前景。</p>

<h5>draw() 总调度方法</h5>

<center><p><img src="http://Solarex.github.io/images/canvas-draw.jpg"/></p></center>


<p>关于绘制方法，有两点需要注意一下：</p>

<ul>
<li><p>出于效率的考虑，ViewGroup 默认会绕过 <code>draw()</code> 方法，换而直接执行  <code>dispatchDraw()</code>，以此来简化绘制流程。所以如果你自定义了某个 ViewGroup 的子类（比如 LinearLayout）并且需要在它的除 <code>dispatchDraw()</code> 以外的任何一个绘制方法内绘制内容，你可能会需要调用 <code>View.setWillNotDraw(false)</code> 这行代码来切换到完整的绘制流程（是「可能」而不是「必须」的原因是，有些 ViewGroup 是已经调用过  setWillNotDraw(false) 了的，例如 ScrollView）。</p></li>
<li><p>有的时候，一段绘制代码写在不同的绘制方法中效果是一样的，这时你可以选一个自己喜欢或者习惯的绘制方法来重写。但有一个例外：如果绘制代码既可以写在  <code>onDraw()</code> 里，也可以写在其他绘制方法里，那么优先写在 <code>onDraw()</code> ，因为 Android 有相关的优化，可以在不需要重绘的时候自动跳过 <code>onDraw()</code> 的重复执行，以提升开发效率。享受这种优化的只有 <code>onDraw()</code> 一个方法。</p></li>
</ul>


<h3>属性动画 Property Animation</h3>

<p> Android 里动画是有一些分类的：动画可以分为两类：Animation 和 Transition；其中 Animation 又可以再分为 View Animation 和 Property Animation 两类： View Animation 是纯粹基于 framework 的绘制转变，Property Animation，属性动画，这是在 Android 3.0 开始引入的新的动画形式。</p>

<p> ##### ViewPropertyAnimator</p>

<p> <center><p><img src="http://Solarex.github.io/images/view-animate.jpg"/></p></center></p>

<p> ##### ObjectAnimator</p>

<p>使用方式：</p>

<ul>
<li>如果是自定义控件，需要添加 setter / getter 方法；</li>
<li>用 ObjectAnimator.ofXXX() 创建 ObjectAnimator 对象；</li>
<li>用 start() 方法执行动画。</li>
</ul>


<h5>通用方法</h5>

<ul>
<li><p><code>setDuration(int duration)</code> 设置动画时长</p></li>
<li><p><code>setInterpolator(Interpolator interpolator)</code> 设置 Interpolator,<code>AccelerateDecelerateInterpolator</code>,<code>LinearInterpolator</code>,<code>AccelerateInterpolator</code>,<code>DecelerateInterpolator</code>,<code>AnticipateInterpolator</code>,<code>OvershootInterpolator</code>,<code>AnticipateOvershootInterpolator</code>,<code>BounceInterpolator</code>,<code>CycleInterpolator</code>,<code>PathInterpolator</code>,<code>FastOutLinearInInterpolator</code>,<code>FastOutSlowInInterpolator</code>,<code>LinearOutSlowInInterpolator</code></p></li>
</ul>


<h5>设置监听器</h5>

<p>设置监听器的方法， ViewPropertyAnimator 和 ObjectAnimator 略微不一样：  ViewPropertyAnimator 用的是 setListener() 和 setUpdateListener() 方法，可以设置一个监听器，要移除监听器时通过 set[Update]Listener(null) 填 null 值来移除；而  ObjectAnimator 则是用 addListener() 和 addUpdateListener() 来添加一个或多个监听器，移除监听器则是通过 remove[Update]Listener() 来指定移除对象。另外，由于 ObjectAnimator 支持使用 pause() 方法暂停，所以它还多了一个  addPauseListener() / removePauseListener() 的支持；而 ViewPropertyAnimator 则独有  withStartAction() 和 withEndAction() 方法，可以设置一次性的动画开始或结束的监听。</p>

<p>AnimatorListener 共有 4 个回调方法：</p>

<ul>
<li><p><code>onAnimationStart(Animator animation)</code></p></li>
<li><p><code>onAnimationEnd(Animator animation)</code></p></li>
<li><p><code>onAnimationCancel(Animator animation)</code></p></li>
<li><p><code>onAnimationRepeat(Animator animation)</code></p></li>
</ul>


<p><code>AnimatorUpdateListener</code>它只有一个回调方法：<code>onAnimationUpdate(ValueAnimator animation)</code></p>

<p><code>ViewPropertyAnimator.withStartAction/EndAction()</code>，<code>withStartAction() / withEndAction()</code> 是一次性的，在动画执行结束后就自动弃掉了，就算之后再重用 <code>ViewPropertyAnimator</code> 来做别的动画，用它们设置的回调也不会再被调用。而 <code>set/addListener()</code> 所设置的 <code>AnimatorListener</code> 是持续有效的，当动画重复执行时，回调总会被调用。<code>withEndAction()</code> 设置的回调只有在动画正常结束时才会被调用，而在动画被取消时不会被执行。这点和 <code>AnimatorListener.onAnimationEnd()</code> 的行为是不一致的。</p>

<h5>TypeEvaluator</h5>

<ul>
<li><p><code>ArgbEvaluator</code></p></li>
<li><p>自定义 Evaluator</p></li>
</ul>


<p>借助于 TypeEvaluator，属性动画就可以通过 ofObject() 来对不限定类型的属性做动画了。方式很简单：</p>

<ul>
<li><p>为目标属性写一个自定义的 TypeEvaluator</p></li>
<li><p>使用 ofObject() 来创建 Animator，并把自定义的 TypeEvaluator 作为参数填入</p></li>
</ul>


<h5>PropertyValuesHolder 同一个动画中改变多个属性</h5>

<h5>AnimatorSet 多个动画配合执行</h5>

<h5>PropertyValuesHolders.ofKeyframe() 把同一个属性拆分</h5>

<h3>硬件加速</h3>

<ul>
<li><p><a href="https://developer.android.google.cn/guide/topics/graphics/hardware-accel.html">Hardware Acceleration | Android Developers</a></p></li>
<li><p><a href="https://www.youtube.com/watch?v=v9S5EO7CLjo">Google I/O 2011: Accelerated Android Rendering</a></p></li>
</ul>


<p>所谓硬件加速，指的是把某些计算工作交给专门的硬件来做，而不是和普通的计算工作一样交给 CPU 来处理。这样不仅减轻了 CPU 的压力，而且由于有了「专人」的处理，这份计算工作的速度也被加快了。这就是「硬件加速」。</p>

<p>而对于 Android 来说，硬件加速有它专属的意思：在 Android 里，硬件加速专指把 View 中绘制的计算工作交给 GPU 来处理。进一步地再明确一下，这个「绘制的计算工作」指的就是把绘制方法中的那些 Canvas.drawXXX() 变成实际的像素这件事。</p>

<p>在硬件加速关闭的时候，Canvas 绘制的工作方式是：把要绘制的内容写进一个  Bitmap，然后在之后的渲染过程中，这个 Bitmap 的像素内容被直接用于渲染到屏幕。这种绘制方式的主要计算工作在于把绘制操作转换为像素的过程（例如由一句  Canvas.drawCircle() 来获得一个具体的圆的像素信息），这个过程的计算是由 CPU 来完成的。而在硬件加速开启时，Canvas 的工作方式改变了：它只是把绘制的内容转换为 GPU 的操作保存了下来，然后就把它交给 GPU，最终由 GPU 来完成实际的显示工作。</p>

<p>硬件加速不只是好处，也有它的限制：受到 GPU 绘制方式的限制，Canvas 的有些方法在硬件加速开启式会失效或无法正常工作。比如，在硬件加速开启时， clipPath() 在 API 18 及以上的系统中才有效。具体的 API 限制和 API 版本的关系如下图：</p>

<center><p><img src="http://Solarex.github.io/images/hardware-acceleration.jpg"></p></center>


<h5>View Layer</h5>

<p>setLayerType() 这个方法，它的作用其实就是名字里的意思：设置 View Layer 的类型。所谓 View Layer，又称为离屏缓冲（Off-screen Buffer），它的作用是单独启用一块地方来绘制这个 View ，而不是使用软件绘制的 Bitmap 或者通过硬件加速的 GPU。这块「地方」可能是一块单独的 Bitmap，也可能是一块 OpenGL 的纹理（texture，OpenGL 的纹理可以简单理解为图像的意思），具体取决于硬件加速是否开启。采用什么来绘制 View 不是关键，关键在于当设置了 View Layer 的时候，它的绘制会被缓存下来，而且缓存的是最终的绘制结果，而不是像硬件加速那样只是把 GPU 的操作保存下来再交给 GPU 去计算。通过这样更进一步的缓存方式，View 的重绘效率进一步提高了：只要绘制的内容没有变，那么不论是 CPU 绘制还是 GPU 绘制，它们都不用重新计算，而只要只用之前缓存的绘制结果就可以了。</p>

<p>基于这样的原理，在进行移动、旋转等（无需调用 invalidate()）的属性动画的时候开启 Hardware Layer 将会极大地提升动画的效率，因为在动画过程中 View 本身并没有发生改变，只是它的位置或角度改变了，而这种改变是可以由 GPU 通过简单计算就完成的，并不需要重绘整个 View。所以在这种动画的过程中开启 Hardware Layer，可以让本来就依靠硬件加速而变流畅了的动画变得更加流畅。</p>

<p>不过一定要注意，只有你在对 translationX translationY rotation alpha 等无需调用  invalidate() 的属性做动画的时候，这种方法才适用，因为这种方法本身利用的就是当界面不发生时，缓存未更新所带来的时间的节省。所以简单地说——这种方式不适用于基于自定义属性绘制的动画。</p>

<p>另外，由于设置了 View Layer 后，View 在初次绘制时以及每次 invalidate() 后重绘时，需要进行两次的绘制工作（一次绘制到 Layer，一次从 Layer 绘制到显示屏），所以其实它的每次绘制的效率是被降低了的。所以一定要慎重使用 View Layer，在需要用到它的时候再去使用。</p>

<h3>reference</h3>

<ul>
<li><a href="https://github.com/xinghongfei/awesome-view">awesome-view</a></li>
<li><a href="https://github.com/GcsSloop/AndroidNote/tree/master/CustomView">GcsSloop CustomView</a></li>
<li><a href="https://blog.csdn.net/aigestudio/column/info/androidcustomview">Android自定义控件其实很简单</a></li>
<li><a href="https://hencoder.com/tag/hui-zhi/">自定义View-绘制</a></li>
</ul>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[RecyclerView平滑滑动到指定位置]]></title>
    <link href="http://Solarex.github.io/blog/2018/05/30/recyclerview-smooth-scoll-to-position/"/>
    <updated>2018-05-30T14:33:00+08:00</updated>
    <id>http://Solarex.github.io/blog/2018/05/30/recyclerview-smooth-scoll-to-position</id>
    <content type="html"><![CDATA[<p>最近在做一个周日历的新需求，其中有个要求是要RecyclerView平滑的滑动到指定位置，刚开始的时候我以为只要调用<code>smoothScrollToPosition</code>这个方法就可以了，测试的时候发现，<code>smoothScrollToPosition</code>只会对不可见的item有效，对于已经可见的item滑动没有效果，于是翻看了一下<code>smoothScrollToPosition</code>的源码，发现是调用了<code>LayoutManger</code>的<code>smoothScrollToPosition</code>方法。</p>

<!-- more -->


<p>```java
// LinearLayoutManager</p>

<pre><code>@Override
public void smoothScrollToPosition(RecyclerView recyclerView, RecyclerView.State state,
        int position) {
    LinearSmoothScroller linearSmoothScroller =
            new LinearSmoothScroller(recyclerView.getContext());
    linearSmoothScroller.setTargetPosition(position);
    startSmoothScroll(linearSmoothScroller);
}
</code></pre>

<p>```</p>

<p>发现其实是实例化了一个<code>LinearSmoothScroller</code>，然后调用<code>startSmoothScroll</code>将<code>LinearSmoothScroller</code>传入进去。在<a href="https://stackoverflow.com/questions/31235183/recyclerview-how-to-smooth-scroll-to-top-of-item-on-a-certain-position/32819067">StackOverflow</a>上看到一个回答，复写了<code>getVerticalSnapPreference</code>方法，返回<code>SNAP_START</code>，由于我的<code>RecyclerView</code>是水平滑动的，于是复写了<code>getHorizontalSnapPreference</code>返回<code>SNAP_START</code>，测试发现对可见的item也有滑动效果了，可是会有闪烁的现象。</p>

<p>继续看<code>LinearSmoothScroller</code>源码，发现有<code>calculateSpeedPerPixel</code>方法，默认是用<code>25</code>去计算，复写这个方法，换一个大点的数去计算，发现滑动的速度慢下来了，闪烁的现象消失了。具体的代码可以参考<a href="https://github.com/flyfire/WeeklyCalendarViewDemo/blob/master/weeklycalendarview/src/main/java/com/solarexsoft/weeklycalendarview/WeeklyCalendarView.java">WeeklyCalendarView</a>。</p>

<p>问题虽然解决了，但是<code>RecyclerView</code>与各个插件的协同工作机制，<code>LayoutManager</code>,<code>SmoothScroller</code>原理没来的及分析，这个留待以后分析。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Java代理]]></title>
    <link href="http://Solarex.github.io/blog/2018/04/26/java-proxy/"/>
    <updated>2018-04-26T10:07:00+08:00</updated>
    <id>http://Solarex.github.io/blog/2018/04/26/java-proxy</id>
    <content type="html"><![CDATA[<p>Java代理有静态代理和动态代理之分。</p>

<h4>静态代理</h4>

<p>静态代理类图如下：</p>

<p><center><img src="http://Solarex.github.io/images/java-proxy-static.png" width=225 height=225/></center></p>


<p><code>ProxyObject</code>持有<code>RealObject</code>的引用，在<code>someOperation</code>方法中可以代理<code>RealObject</code>做操作。</p>

<!-- more -->


<h4>动态代理</h4>

<p>动态代理有Java的InvocationHandler实现方式和CGLib实现方式，我没用过CGLib，这里只讨论<code>InvocationHandler</code>实现方式。主要有三个步骤，代码示例可以在<a href="https://github.com/flyfire/YouDontKnowJava/tree/master/src/com/solarexsoft/test/proxy">github</a>上面看</p>

<ul>
<li>定义一个interface</li>
<li>定义一个InvocationHandler实现类，将要代理的对象传入InvocationHandler中，也即让InvocationHandler实现类代理传入的对象</li>
<li>调用Proxy.newProxyInstance</li>
</ul>


<p>动态代理的秘密主要是藏在<code>Proxy.newProxyInstance</code>当中</p>

<p>```java
public static Object newProxyInstance(ClassLoader loader,Class&lt;?>[] interfaces,InvocationHandler h) throws IllegalArgumentException
{</p>

<pre><code>...
    /*
     * Look up or generate the designated proxy class.
     */
    Class&lt;?&gt; cl = getProxyClass0(loader, intfs);
    final Constructor&lt;?&gt; cons = cl.getConstructor(constructorParams);
    final InvocationHandler ih = h;
    return cons.newInstance(new Object[]{h});
</code></pre>

<p>}
```</p>

<p>可以看出它先调用<code>getProxyClass(loader, interfaces)</code>得到动态代理类，然后将<code>InvocationHandler</code>作为代理类构造函数入参新建代理类对象。</p>

<p>```java</p>

<pre><code>/**
 * Returns the {@code java.lang.Class} object for a proxy class
 * given a class loader and an array of interfaces.  The proxy class
 * will be defined by the specified class loader and will implement
 * all of the supplied interfaces.  If any of the given interfaces
 * is non-public, the proxy class will be non-public. If a proxy class
 * for the same permutation of interfaces has already been defined by the
 * class loader, then the existing proxy class will be returned; otherwise,
 * a proxy class for those interfaces will be generated dynamically
 * and defined by the class loader.
 *
 * &lt;p&gt;There are several restrictions on the parameters that may be
 * passed to {@code Proxy.getProxyClass}:
 *
 * &lt;ul&gt;
 * &lt;li&gt;All of the {@code Class} objects in the
 * {@code interfaces} array must represent interfaces, not
 * classes or primitive types.
 *
 * &lt;li&gt;No two elements in the {@code interfaces} array may
 * refer to identical {@code Class} objects.
 *
 * &lt;li&gt;All of the interface types must be visible by name through the
 * specified class loader.  In other words, for class loader
 * {@code cl} and every interface {@code i}, the following
 * expression must be true:
 * &lt;pre&gt;
 *     Class.forName(i.getName(), false, cl) == i
 * &lt;/pre&gt;
 *
 * &lt;li&gt;All non-public interfaces must be in the same package;
 * otherwise, it would not be possible for the proxy class to
 * implement all of the interfaces, regardless of what package it is
 * defined in.
 *
 * &lt;li&gt;For any set of member methods of the specified interfaces
 * that have the same signature:
 * &lt;ul&gt;
 * &lt;li&gt;If the return type of any of the methods is a primitive
 * type or void, then all of the methods must have that same
 * return type.
 * &lt;li&gt;Otherwise, one of the methods must have a return type that
 * is assignable to all of the return types of the rest of the
 * methods.
 * &lt;/ul&gt;
 *
 * &lt;li&gt;The resulting proxy class must not exceed any limits imposed
 * on classes by the virtual machine.  For example, the VM may limit
 * the number of interfaces that a class may implement to 65535; in
 * that case, the size of the {@code interfaces} array must not
 * exceed 65535.
 * &lt;/ul&gt;
 *
 * &lt;p&gt;If any of these restrictions are violated,
 * {@code Proxy.getProxyClass} will throw an
 * {@code IllegalArgumentException}.  If the {@code interfaces}
 * array argument or any of its elements are {@code null}, a
 * {@code NullPointerException} will be thrown.
 *
 * &lt;p&gt;Note that the order of the specified proxy interfaces is
 * significant: two requests for a proxy class with the same combination
 * of interfaces but in a different order will result in two distinct
 * proxy classes.
 *
 */
</code></pre>

<p>/<em>*
 * 得到代理类，不存在则动态生成
 * @param loader 代理类所属 ClassLoader
 * @param interfaces 代理类需要实现的接口
 * @return
 </em>/
public static Class&lt;?> getProxyClass(ClassLoader loader,</p>

<pre><code>                                 Class&lt;?&gt;... interfaces)
throws IllegalArgumentException
</code></pre>

<p>{</p>

<pre><code>if (interfaces.length &gt; 65535) {
    throw new IllegalArgumentException("interface limit exceeded");
}
// 代理类类对象
Class proxyClass = null;

/* collect interface names to use as key for proxy class cache */
String[] interfaceNames = new String[interfaces.length];

Set interfaceSet = new HashSet();       // for detecting duplicates

/**
 * 入参 interfaces 检验，包含三部分
 * （1）是否在入参指定的 ClassLoader 内
 * （2）是否是 Interface
 * （3）interfaces 中是否有重复
 */
for (int i = 0; i &lt; interfaces.length; i++) {
    String interfaceName = interfaces[i].getName();
    Class interfaceClass = null;
    try {
        interfaceClass = Class.forName(interfaceName, false, loader);
    } catch (ClassNotFoundException e) {
    }
    if (interfaceClass != interfaces[i]) {
        throw new IllegalArgumentException(
            interfaces[i] + " is not visible from class loader");
    }

    if (!interfaceClass.isInterface()) {
        throw new IllegalArgumentException(
            interfaceClass.getName() + " is not an interface");
    }

    if (interfaceSet.contains(interfaceClass)) {
        throw new IllegalArgumentException(
            "repeated interface: " + interfaceClass.getName());
    }
    interfaceSet.add(interfaceClass);

    interfaceNames[i] = interfaceName;
}

// 以接口名对应的 List 作为缓存的 key
Object key = Arrays.asList(interfaceNames);

/*
 * loaderToCache 是个双层的 Map
 * 第一层 key 为 ClassLoader，第二层 key 为 上面的 List，value 为代理类的弱引用
 */
Map cache;
synchronized (loaderToCache) {
    cache = (Map) loaderToCache.get(loader);
    if (cache == null) {
        cache = new HashMap();
        loaderToCache.put(loader, cache);
    }
}

/*
 * 以上面的接口名对应的 List 为 key 查找代理类，如果结果为：
 * (1) 弱引用，表示代理类已经在缓存中
 * (2) pendingGenerationMarker 对象，表示代理类正在生成中，等待生成完成通知。
 * (3) null 表示不在缓存中且没有开始生成，添加标记到缓存中，继续生成代理类
 */
synchronized (cache) {
    do {
        Object value = cache.get(key);
        if (value instanceof Reference) {
            proxyClass = (Class) ((Reference) value).get();
        }
        if (proxyClass != null) {
            // proxy class already generated: return it
            return proxyClass;
        } else if (value == pendingGenerationMarker) {
            // proxy class being generated: wait for it
            try {
                cache.wait();
            } catch (InterruptedException e) {
            }
            continue;
        } else {
            cache.put(key, pendingGenerationMarker);
            break;
        }
    } while (true);
}

try {
    String proxyPkg = null;     // package to define proxy class in

    /*
     * 如果 interfaces 中存在非 public 的接口，则所有非 public 接口必须在同一包下面，后续生成的代理类也会在该包下面
     */
    for (int i = 0; i &lt; interfaces.length; i++) {
        int flags = interfaces[i].getModifiers();
        if (!Modifier.isPublic(flags)) {
            String name = interfaces[i].getName();
            int n = name.lastIndexOf('.');
            String pkg = ((n == -1) ? "" : name.substring(0, n + 1));
            if (proxyPkg == null) {
                proxyPkg = pkg;
            } else if (!pkg.equals(proxyPkg)) {
                throw new IllegalArgumentException(
                    "non-public interfaces from different packages");
            }
        }
    }

    if (proxyPkg == null) {     // if no non-public proxy interfaces,
        proxyPkg = "";          // use the unnamed package
    }

    {
        // 得到代理类的类名，jdk 1.6 版本中缺少对这个生成类已经存在的处理。
        long num;
        synchronized (nextUniqueNumberLock) {
            num = nextUniqueNumber++;
        }
        String proxyName = proxyPkg + proxyClassNamePrefix + num;

        // 动态生成代理类的字节码
        // 最终调用 sun.misc.ProxyGenerator.generateClassFile() 得到代理类相关信息写入 DataOutputStream 实现
        byte[] proxyClassFile = ProxyGenerator.generateProxyClass(
            proxyName, interfaces);
        try {
            // native 层实现，虚拟机加载代理类并返回其类对象
            proxyClass = defineClass0(loader, proxyName,
                proxyClassFile, 0, proxyClassFile.length);
        } catch (ClassFormatError e) {
            throw new IllegalArgumentException(e.toString());
        }
    }
    // add to set of all generated proxy classes, for isProxyClass
    proxyClasses.put(proxyClass, null);

} finally {
    // 代理类生成成功则保存到缓存，否则从缓存中删除，然后通知等待的调用
    synchronized (cache) {
        if (proxyClass != null) {
            cache.put(key, new WeakReference(proxyClass));
        } else {
            cache.remove(key);
        }
        cache.notifyAll();
    }
}
return proxyClass;
</code></pre>

<p>}</p>

<p>```</p>

<p>函数主要包括三部分：</p>

<ul>
<li>入参 interfaces 检验，包含是否在入参指定的 ClassLoader 内、是否是 Interface、interfaces 中是否有重复
以接口名对应的 List 为 key 查找代理类，如果结果为：

<ul>
<li>弱引用，表示代理类已经在缓存中；</li>
<li>pendingGenerationMarker 对象，表示代理类正在生成中，等待生成完成返回；</li>
<li>null 表示不在缓存中且没有开始生成，添加标记到缓存中，继续生成代理类。</li>
</ul>
</li>
<li>如果代理类不存在调用ProxyGenerator.generateProxyClass(…)生成代理类并存入缓存，通知在等待的缓存。</li>
</ul>


<p>函数中几个注意的地方：</p>

<ul>
<li>代理类的缓存 key 为接口名对应的 List，接口顺序不同表示不同的 key 即不同的代理类。</li>
<li>如果 interfaces 中存在非 public 的接口，则所有非 public 接口必须在同一包下面，后续生成的代理类也会在该包下面。</li>
<li>代理类如果在 ClassLoader 中已经存在的情况没有做处理。</li>
</ul>


<p>可以开启 System Properties 的<code>sun.misc.ProxyGenerator.saveGeneratedFiles</code>开关，保存动态类到目的地址。</p>

<p>Java 1.7 的实现略有不同，通过<code>getProxyClass0(…)</code>函数实现，实现中调用代理类的缓存，判断代理类在缓存中是否已经存在，存在直接返回，不存在则调用proxyClassCache的valueFactory属性进行动态生成，valueFactory的apply函数与上面的<code>getProxyClass(…)</code>函数逻辑类似。</p>

<p>```
import java.lang.reflect.InvocationHandler;
import java.lang.reflect.Method;
import java.lang.reflect.Proxy;
import java.lang.reflect.UndeclaredThrowableException;</p>

<p>public final class $Proxy0 extends Proxy
  implements Operate
{
  private static Method m4;
  private static Method m1;
  private static Method m5;
  private static Method m0;
  private static Method m3;
  private static Method m2;</p>

<p>  public $Proxy0(InvocationHandler paramInvocationHandler)</p>

<pre><code>throws 
</code></pre>

<p>  {</p>

<pre><code>super(paramInvocationHandler);
</code></pre>

<p>  }</p>

<p>  public final void operateMethod1()</p>

<pre><code>throws 
</code></pre>

<p>  {</p>

<pre><code>try
{
  h.invoke(this, m4, null);
  return;
}
catch (Error|RuntimeException localError)
{
  throw localError;
}
catch (Throwable localThrowable)
{
  throw new UndeclaredThrowableException(localThrowable);
}
</code></pre>

<p>  }</p>

<p>  public final boolean equals(Object paramObject)</p>

<pre><code>throws 
</code></pre>

<p>  {</p>

<pre><code>try
{
  return ((Boolean)h.invoke(this, m1, new Object[] { paramObject })).booleanValue();
}
catch (Error|RuntimeException localError)
{
  throw localError;
}
catch (Throwable localThrowable)
{
  throw new UndeclaredThrowableException(localThrowable);
}
</code></pre>

<p>  }</p>

<p>  public final void operateMethod2()</p>

<pre><code>throws 
</code></pre>

<p>  {</p>

<pre><code>try
{
  h.invoke(this, m5, null);
  return;
}
catch (Error|RuntimeException localError)
{
  throw localError;
}
catch (Throwable localThrowable)
{
  throw new UndeclaredThrowableException(localThrowable);
}
</code></pre>

<p>  }</p>

<p>  public final int hashCode()</p>

<pre><code>throws 
</code></pre>

<p>  {</p>

<pre><code>try
{
  return ((Integer)h.invoke(this, m0, null)).intValue();
}
catch (Error|RuntimeException localError)
{
  throw localError;
}
catch (Throwable localThrowable)
{
  throw new UndeclaredThrowableException(localThrowable);
}
</code></pre>

<p>  }</p>

<p>  public final void operateMethod3()</p>

<pre><code>throws 
</code></pre>

<p>  {</p>

<pre><code>try
{
  h.invoke(this, m3, null);
  return;
}
catch (Error|RuntimeException localError)
{
  throw localError;
}
catch (Throwable localThrowable)
{
  throw new UndeclaredThrowableException(localThrowable);
}
</code></pre>

<p>  }</p>

<p>  public final String toString()</p>

<pre><code>throws 
</code></pre>

<p>  {</p>

<pre><code>try
{
  return (String)h.invoke(this, m2, null);
}
catch (Error|RuntimeException localError)
{
  throw localError;
}
catch (Throwable localThrowable)
{
  throw new UndeclaredThrowableException(localThrowable);
}
</code></pre>

<p>  }</p>

<p>  static
  {</p>

<pre><code>try
{
  m4 = Class.forName("com.codekk.java.test.dynamicproxy.Operate").getMethod("operateMethod1", new Class[0]);
  m1 = Class.forName("java.lang.Object").getMethod("equals", new Class[] { Class.forName("java.lang.Object") });
  m5 = Class.forName("com.codekk.java.test.dynamicproxy.Operate").getMethod("operateMethod2", new Class[0]);
  m0 = Class.forName("java.lang.Object").getMethod("hashCode", new Class[0]);
  m3 = Class.forName("com.codekk.java.test.dynamicproxy.Operate").getMethod("operateMethod3", new Class[0]);
  m2 = Class.forName("java.lang.Object").getMethod("toString", new Class[0]);
  return;
}
catch (NoSuchMethodException localNoSuchMethodException)
{
  throw new NoSuchMethodError(localNoSuchMethodException.getMessage());
}
catch (ClassNotFoundException localClassNotFoundException)
{
  throw new NoClassDefFoundError(localClassNotFoundException.getMessage());
}
</code></pre>

<p>  }
}
```</p>

<p>可以看到实际上在底层生成了一个class的字节流，并且被ClassLoader加载了，生成了一个继承<code>Proxy</code>实现了接口的类，这个类以<code>InvocationHandler</code>为构造函数参数，所以实际上是在调用方法时，生成的<code>$Proxy0</code>对象代理了<code>InvocationHandler</code>实现对象，<code>InvocationHandler</code>对象代理了实际的对象。</p>
]]></content>
  </entry>
  
</feed>
