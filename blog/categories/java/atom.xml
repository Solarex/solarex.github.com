<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: java | Solarex's Blog]]></title>
  <link href="http://Solarex.github.io/blog/categories/java/atom.xml" rel="self"/>
  <link href="http://Solarex.github.io/"/>
  <updated>2019-09-11T18:02:36+08:00</updated>
  <id>http://Solarex.github.io/</id>
  <author>
    <name><![CDATA[Solarex]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[检测链表中是否有环]]></title>
    <link href="http://Solarex.github.io/blog/2019/08/05/floyd-cycle-detection-in-linkedlist/"/>
    <updated>2019-08-05T17:50:00+08:00</updated>
    <id>http://Solarex.github.io/blog/2019/08/05/floyd-cycle-detection-in-linkedlist</id>
    <content type="html"><![CDATA[<p>本文主要讲解如何检测链表中是否有环，如果有环确定环的起点。</p>

<!-- more -->


<h3>reference</h3>

<ul>
<li><a href="https://www.youtube.com/watch?v=zbozWoMgKW0">Detect loop in linked list(floyd algo / Tortoise and hare algo)</a></li>
<li><a href="https://www.youtube.com/watch?v=LUm2ABqAs1w">Why Floyd&rsquo;s cycle detection algorithm works? Detecting loop in a linked list.</a></li>
</ul>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Java线程池解析]]></title>
    <link href="http://Solarex.github.io/blog/2019/08/04/java-threadpoolexecutor/"/>
    <updated>2019-08-04T20:27:00+08:00</updated>
    <id>http://Solarex.github.io/blog/2019/08/04/java-threadpoolexecutor</id>
    <content type="html"><![CDATA[<p>本文主要对Executor框架以及Java平台线程池技术进行分析。</p>

<!-- more -->


<p>Executor框架主要由3大部分组成：</p>

<ul>
<li>任务。包括被执行任务需要实现的接口：Runnable接口或Callable接口</li>
<li>任务的执行。包括任务执行机制的核心接口Executor，以及继承自Executor的ExecutorService接口。Executor框架有两个关键类实现了ExecutorService接口（ThreadPoolExecutor和ScheduledThreadPoolExecutor）</li>
<li>异步计算的结果。包括接口Future和实现Future接口的FutureTask类。</li>
</ul>


<p>通过Executor框架的工具类Executors，可以创建3中类型的ThreadPoolExecutor：</p>

<ul>
<li>FixedThreadPool</li>
<li>SingleThreadPool</li>
<li>CachedThreadPool</li>
</ul>


<p>ThreadPoolExecutor执行execute方法分下面4种情况：</p>

<ul>
<li>如果当前运行的线程少于corePoolSize，则创建新线程来执行任务（注意，执行这一步骤需要获取全局锁）</li>
<li>如果运行的线程等于或多于corePoolSize，则将任务加入BlockingQueue。</li>
<li>如果无法将任务加入BlockingQueue（队列已满），则创建新的线程来处理任务（注意，执行这一步骤需要获取全局锁）</li>
<li>如果创建新线程将使当前运行的线程超出maximumPoolSize，任务将交给饱和策略来处理。</li>
</ul>


<p>RejectExecutionHandler(饱和策略)</p>

<ul>
<li>AbortPolicy：直接抛出异常</li>
<li>CallerRunsPolicy：调用者线程来运行任务</li>
<li>DiscardOldestPolicy：丢弃队列中最近的一个任务，并执行当前任务</li>
<li>DiscardPolicy：不处理，丢弃掉</li>
</ul>


<p>关闭线程池：可以通过调用线程池的shutdown或shutdownNow方法来关闭线程池。它们的原理是遍历线程池中的工作线程，然后逐个调用线程的interrupt方法来中断线程，所以无法响应中断的任务可能永远无法终止。但是它们存在一定的区别，shutdownNow首先将线程池的状态设置成STOP，然后尝试停止所有的正在执行或暂停任务的线程，并返回等待执行任务的列表，而shutdown只是将线程池的状态设置成SHUTDOWN状态，然后中断所有没有正在执行任务的线程。只要调用了这两个关闭方法中的任意一个，isShutdown方法就会返回true，当所有的任务都已关闭后，才表示线程池关闭成功，这时调用isTerminated方法会返回true。</p>

<p>FixedThreadPool的corePoolSize和maximumPoolSize都被设置为创建FixedThreadPool时指定的参数nThreads。当线程池中的线程数大于corePoolSize时，keepAliveTime为多余的空闲线程等待新任务的最长时间，超过这个时间后多余的线程将被终止。keepAliveTime设置为0意味着多余的空闲线程会被立即终止。FixedThreadPool使用无界队列LinkedBlockingQueue作为线程池的工作队列。当线程池的线程数达到corePoolSize后，新任务将在无界队列中等待，因此线程池中线程数不会超过corePoolSize，maximunPoolSize是无效的参数，keepAliveTime也变成了无效参数。</p>

<p>SingleThreadExecutor的corePoolSize和maximumPoolSize被设置成1,其他参数与FixedThreadPool相同。</p>

<p>CachedThreadPool是一个会根据需要创建新线程的线程池。CachedThreadPool的corePoolSize被设置为0，即corePoolSize为空，maximumPoolSize被设置为Integer.MAX_VALUE，即maximumPool是无界的，keepAliveTime被设置为60，意味着CachedThreadPool中的空闲线程等待新任务的最长时间是60s，空闲线程超过60s后将会被终止。CachedThreadPool使用没有容量的SynchronousQueue作为线程池的工作队列，但CachedThreadPool的maximumPool是无界的，这意味着，如果主线程提交任务的速度高于maximumPool中线程处理任务的速度时，CachedThreadPool会不断创建新线程，极端情况下，CachedThreadPool会因为创建过多线程而耗尽CPU和内存资源。</p>

<p>ScheduledThreadPoolExecutor使用DelayQueue作为工作队列，DelayQueue是无界队列，所以maximumPoolSize参数无意义。ScheduledThreadPoolExecutor的执行主要分为两大部分：</p>

<ul>
<li>当调用ScheduledThreadPoolExecutor的scheduleAtFixedRate()方法或者scheduleWithFixedDelay()方法时，会向DelayQueue中添加一个实现了RunnableScheduledFuture接口的ScheduledFutureTask。</li>
<li>线程池的线程从DelayQueue中获取ScheduledFutureTask，然后执行任务。</li>
</ul>


<p>可以自己<a href="https://github.com/flyfire/ReadJCIP/tree/master/src/main/java/com/solarexsoft/jcip/art/ch04">参考</a>着实现一个简陋版的线程池。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Java BlockingQueue解析]]></title>
    <link href="http://Solarex.github.io/blog/2019/08/01/java-blockingqueue/"/>
    <updated>2019-08-01T20:26:00+08:00</updated>
    <id>http://Solarex.github.io/blog/2019/08/01/java-blockingqueue</id>
    <content type="html"><![CDATA[<p>本文主要分析Java平台BlockingQueue的各个实现。</p>

<!-- more -->


<p>阻塞队列BlockingQueue是一个支持两个附加操作的队列。这两个附加的操作支持阻塞的插入和移除方法。</p>

<ul>
<li>支持阻塞的插入方法：意思是当队列满时，队列会阻塞插入元素的线程，直到队列不满。</li>
<li>支持阻塞的移除方法：意思是在队列为空时，获取元素的线程会等待队列变为非空。</li>
</ul>


<p>当阻塞队列不可用时，这两个附加操作提供了4种处理方式。</p>

<table>
<thead>
<tr>
<th></th>
<th> 方法/处理方式 </th>
<th> 抛出异常  </th>
<th> 返回特殊值 </th>
<th> 一直阻塞 </th>
<th> 超时退出           </th>
</tr>
</thead>
<tbody>
<tr>
<td></td>
<td> 插入方法      </td>
<td> add(e)    </td>
<td> offer(e)   </td>
<td> put(e)   </td>
<td> offer(e,time,unit) |</td>
</tr>
<tr>
<td></td>
<td> 移除方法      </td>
<td> remove(e) </td>
<td> poll()     </td>
<td> take()   </td>
<td> poll(time, unit)   |</td>
</tr>
<tr>
<td></td>
<td> 检查方法      </td>
<td> element() </td>
<td> peek()     </td>
<td> 不可用   </td>
<td> 不可用             |</td>
</tr>
</tbody>
</table>


<ul>
<li>抛出异常：当队列满时，如果再往队列里插入元素，会抛出IllegalStateException(&ldquo;Queue full&rdquo;)异常。当队列空时，从队列里获取元素会抛出NoSuchElementException异常。</li>
<li>返回特殊值：当往队列插入元素时，会返回元素是否插入成功，成功返回true。如果是移除方法，则是从队列里取出一个元素，如果没有则返回null。</li>
<li>一直阻塞：当阻塞队列满时，如果生产者线程往队列里put元素，队列会一直阻塞生产者线程，直到队列可用或者响应中断退出。当队列空时，如果消费者线程从队列里take元素，队列会阻塞住消费者线程，直到队列不为空。</li>
<li>超时退出：当阻塞队列满时，如果生产者线程往队列里插入元素，队列会阻塞生产者线程一段时间，如果超过了指定的时间，生产者线程就会退出。</li>
</ul>


<p>如果是无界阻塞队列，队列不可能会出现满的情况，所以使用put或offer方法永远不会被阻塞，而且offer方法永远返回true。</p>

<p>JDK 7提供了7个阻塞队列：</p>

<ul>
<li>ArrayBlockingQueue：一个由数组结构组成的有界阻塞队列</li>
<li>LinkedBlockingQueue：一个由链表结构组成的有界阻塞队列</li>
<li>PriorityBlockingQueue：一个支持优先级排序的无界阻塞队列</li>
<li>DelayQueue：一个使用优先级队列实现的无界阻塞队列</li>
<li>SynchronousQueue：一个不存储元素的阻塞队列</li>
<li>LinkedTransferQueue：一个由链表结构组成的无界阻塞队列</li>
<li>LinkedBlockingDeque：一个由链表结构组成的双向阻塞队列</li>
</ul>


<p>ArrayBlockingQueue是一个用数组实现的有界阻塞队列。此队列按照FIFO的原则对元素进行排序。访问线程的公平性是使用可重入锁实现的。</p>

<p>LinkedBlockingQueue是一个用链表实现的有界阻塞队列，此队列的默认和最大长度为Integer.MAX_VALUE。此队列按照先进先出的原则对元素进行排序。</p>

<p>PriorityBlockingQueue是一个支持优先级的无界阻塞队列。默认情况下元素采用自然顺序升序排列。也可以自定义类实现compareTo()方法来指定元素排序规则，或者初始化PriorityBlockingQueue时，指定构造参数Comparator来对元素进行排序。需要注意的是不能保证同优先级元素的顺序。</p>

<p>DelayQueue是一个支持延时获取元素的无界阻塞队列。队列使用PriorityQueue来实现。队列中的元素必须实现Delayed接口，在创建元素时可以指定多久才能从队列中获取当前元素。只有在延迟期满时才能从队列中提取元素。DelayQueue非常有用，可以将DelayQueue运用在以下应用场景。</p>

<ul>
<li>缓存系统的设计：可以用DelayQueue保存缓存元素的有效期，使用一个线程循环查询DelayQueue，一旦能从DelayQueue中获取元素时，表示缓存有效期到了。</li>
<li>定时任务调度：使用DelayQueue保存当天将会执行的任务和执行时间，一旦从DelayQueue中获取到任务就开始执行，比如TimerQueue就是使用DelayQueue实现的。</li>
</ul>


<p>延时阻塞队列的实现很简单，当消费者从队列里获取元素时，如果元素没有达到延时时间，就阻塞当前线程。</p>

<p>SyncrhonousQueue是一个不存储元素的阻塞队列。每一个put操作必须等待一个take操作，否则不能继续添加元素。它支持公平访问队列。默认情况下线程采用非公平性策略访问队列。SynchronousQueue可以看成是一个传球手，负责把生产者线程处理的数据直接传递给消费者线程。队列本身并不存储任何元素，非常适合传递性场景。SynchronousQueue的吞吐量高于LinkedBlockingQueue和ArrayBlockingQueue。</p>

<p>LinkedTransferQueue是一个由链表结构组成的无界阻塞TransferQueue队列。相对于其他阻塞队列，LinkedTransferQueue多了tryTransfer和transfer方法。</p>

<ul>
<li>transfer方法：如果当前有消费者正在等待接收元素（消费者使用take()方法或带时间限制的poll()方法时），transfer方法可以把生产者传入的元素立即transfer给消费者。如果没有消费者在等待接收元素，transfer方法会将元素存放在队列tail节点，并等到该元素被消费者消费了才返回。</li>
<li>tryTransfer方法：tryTransfer方法是用来试探生产者传入的元素是否能直接传给消费者。如果没有消费者等待接收元素，则返回false。和transfer方法的区别是tryTransfer方法无论消费者是否接收，方法立即返回，而transfer方法是必须等到消费者消费了才返回。对于带时间限制的tryTransfer(E e,long timeout, TimeUnit unit)方法，试图把生产者传入的元素直接传给消费者，但是如果没有消费者消费该元素则等待指定的时间再返回。如果超时还没消费元素，则返回false，如果在超时时间内消费了元素，则返回true。</li>
</ul>


<p>LinkedBlockingDeque是一个由链表结构组成的双向阻塞队列。所谓双向队列指的是可以从队列的两端插入和移除元素。双向队列因为多了一个操作队列的入口，在多线程同时入队时，也就减少了一半的竞争。相比其他的阻塞队列，LinkedBlockingDeque多了addFirst、addLast、offerFirst、offerLast、peekFirst、peekLast等方法。插入方法add等同于addLast，移除方法remove等同于removeFirst，take方法等同于takeFirst。在初始化LinkedBlockingDeque时可以设置容量防止其过度膨胀。LinkedBlockingDeque可以运用在“工作窃取”模式中。</p>

<p>阻塞队列实现原理：使用通知模式实现。ArrayBlockingQueue使用了Condition来实现。</p>

<p>可以自己<a href="https://github.com/flyfire/ReadJCIP/blob/master/src/main/java/com/solarexsoft/jcip/ch14/ConditionBoundedBuffer.java">参考</a>着实现一下。</p>

<h3>reference</h3>

<ul>
<li><a href="https://javadoop.com/post/java-concurrent-queue">解读 java 并发队列 BlockingQueue</a></li>
</ul>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Java AQS解析]]></title>
    <link href="http://Solarex.github.io/blog/2019/07/28/aqs/"/>
    <updated>2019-07-28T16:59:00+08:00</updated>
    <id>http://Solarex.github.io/blog/2019/07/28/aqs</id>
    <content type="html"><![CDATA[<p><code>AbstractQueuedSynchronizer</code>是很多并发工具类如<code>ReentrantLock</code>的实现基础，本文对其进行分析。</p>

<!-- more -->


<p>TL;DR</p>

<p>以下是对<a href="http://gee.cs.oswego.edu/dl/papers/aqs.pdf">aqs.pdf</a>部分内容零散的翻译，其实《Java并发编程实战》中有一章介绍了AQS，我也做了笔记，可以在<a href="https://solarex.github.io/reading-notes/jcip/ch14.html">这里</a>看到，对于AQS模板方法的使用，可以在<a href="https://solarex.github.io/reading-notes/the-art-of-java-concurrency-programming/ch05.html">这篇笔记</a>中看到。翻译很不专业，将就看下吧。如果想深入了解AQS，可以读下<a href="http://gee.cs.oswego.edu/dl/papers/aqs.pdf">aqs.pdf</a>或者看下本文reference部分的几篇文章。</p>

<p>Synchronizers possess two kinds of methods : at least one <code>acquire</code> operation that blocks the calling thread unless/until the synchronization state allows it to proceed, and at least one <code>release</code> operation that changes synchronization state in a way that may allow one or more blocked threads to unblock.</p>

<p>同步器提供两种方法：一个<code>acquire</code>方法在同步状态不允许线程通过运行时阻塞线程，一个<code>release</code>方法改变同步状态来允许一个或多个被阻塞的线程继续运行。</p>

<p>The <code>java.util.concurrent</code> package does not define a single unified API for synchronizers. Some are defined via common interfaces (e.g., <code>Lock</code>), but others contain only specialized versions. So, <code>acquire</code> and <code>release</code> operations take a range of names and forms across different classes. For example, methods <code>Lock.lock</code>,<code>Semaphore.acquire</code>, <code>CountDownLatch.await</code>, and <code>FutureTask.get</code> all map to <code>acquire</code> operations in the framework. However, the package does maintain consistent conventions across classes to support a range of common usage options. When meaningful, each synchronizer supports:
+ Nonblocking synchronization attempts (for example,<code>tryLock</code>) as well as blocking versions.
+ Optional timeouts, so applications can give up waiting.
+ Cancellability via interruption, usually separated into one version of acquire that is cancellable, and one that isn&rsquo;t.</p>

<p>JUC没有为同步器定义一个统一的API。有一些是在通用的接口中定义的，比如<code>Lock</code>，但是其他的包括一些特殊的版本。所以不同同步器的<code>acquire</code>和<code>release</code>方法在名字和形态上表现不同。比如，<code>Lock.lock</code>，<code>Semaphore.acquire</code>，<code>CountDownLatch.await</code>和<code>FutureTask.get</code>和AQS框架中的<code>acquire</code>方法相对应。但是JUC框架在通用操作上保持了一致性。对于同步器来说，一般都支持以下操作：</p>

<ul>
<li>非阻塞尝试和阻塞尝试，比如<code>Lock.tryLock</code>和<code>Lock.lock</code></li>
<li>可选的超时，超时后线程可以放弃等待尝试</li>
<li>在等待获取尝试的时候，对线程中断的响应或不响应</li>
</ul>


<p>Synchronizers may vary according to whether they manage only <code>exclusive</code> states – those in which only one thread at a time may continue past a possible blocking point – versus possible <code>shared</code> states in which multiple threads can at least sometimes proceed.Regular lock classes of course maintain only exclusive state, but counting semaphores, for example, may be acquired by as many threads as the count permits. To be widely useful, the framework must support both modes of operation.</p>

<p>同步器可能会因为共享状态是独占还是可共享的而不同。一般锁维护的是独占状态，同时只能有一个线程持有锁，但是Semaphore可能同时被多个线程获取。AQS对这两种模式都提供了支持。</p>

<p>The <code>java.util.concurrent</code> package also defines interface <code>Condition</code>, supporting monitor-style <code>await/signal</code> operations that may be associated with <code>exclusive Lock</code> classes, and whose implementations are intrinsically intertwined with their associated Lock classes.</p>

<p>JUC框架还定义了<code>Condition</code>接口，来提供和内置锁<code>wait/notify</code>类似的操作，<code>Condition</code>的<code>await/signal</code>方法和独占锁绑定在一起。</p>

<p>The basic ideas behind a synchronizer are quite straightforward.
An acquire operation proceeds as:</p>

<p>```java
while (synchronization state does not allow acquire) {</p>

<pre><code>enqueue current thread if not already queued;
possibly block current thread;
</code></pre>

<p>}
dequeue current thread if it was queued;
```</p>

<p>And a release operation is:</p>

<p><code>java
update synchronization state;
if (state may permit a blocked thread to acquire)
unblock one or more queued threads;
</code></p>

<p>Support for these operations requires the coordination of three basic components:
+ Atomically managing synchronization state
+ Blocking and unblocking threads
+ Maintaining queues</p>

<p>同步器背后的思想很简单，三个基本的部分构成了对同步器的支持：</p>

<ul>
<li>原子更新同步状态</li>
<li>线程的阻塞和唤醒</li>
<li>线程等待队列</li>
</ul>


<p>Class <code>AbstractQueuedSynchronizer</code> maintains synchronization state using only a single (32bit) int, and exports <code>getState</code>, <code>setState</code>, and <code>compareAndSetState</code> operations to access and update this state. These methods in turn rely on <code>java.util.concurrent.atomic</code> support providing JSR133 (Java Memory Model) compliant <code>volatile</code> semantics on <code>reads and writes</code>, and access to native <code>compare-and-swap</code> or <code>loadlinked/store-conditional</code> instructions to implement <code>compareAndSetState</code>, that atomically sets state to a given new value only if it holds a given expected value.</p>

<p><code>AbstractQueuedSynchronizer</code>用一个32位的int值来表示同步状态，暴露了<code>getState</code>, <code>setState</code>和<code>compareAndSetState</code> 方法来获取和更新同步状态。这些方法依赖JMM底层模型对<code>volatile</code>变量的语义支持，依赖CPU的<code>compare-and-swap</code> 或 <code>loadlinked/store-conditional</code> 指令来完成<code>compareAndSetState</code>操作。CAS操作原子地设置同步状态为新的值，只有同步状态等于期待的原值时才会成功。</p>

<p>Restricting synchronization state to a 32bit <code>int</code> was a pragmatic decision. While JSR166 also provides atomic operations on 64bit <code>long</code> fields, these must still be emulated using internal locks on enough platforms that the resulting synchronizers would not perform well. In the future, it seems likely that a second base class, specialized for use with 64bit state (i.e., with long control arguments), will be added. However, there is not now a compelling reason to include it in the package. Currently, 32 bits suffice for most applications. Only one <code>java.util.concurrent</code> synchronizer class, <code>CyclicBarrier</code>, would require more bits to maintain state, so instead uses locks (as do most higher-level utilities in the package).</p>

<p>JUC已经提供了<code>AbstractQueuedLongSynchronizer</code>，<code>AbstractQueuedLongSynchronizer</code>用<code>long</code>来表示同步状态。</p>

<p>Concrete classes based on <code>AbstractQueuedSynchronizer</code> must define methods <code>tryAcquire</code> and <code>tryRelease</code> in terms of these exported state methods in order to control the <code>acquire</code> and <code>release</code> operations. The <code>tryAcquire</code> method must return <code>true</code> if synchronization was acquired, and the <code>tryRelease</code> method must return <code>true</code> if the new synchronization state may allow future acquires. These methods accept a single <code>int</code> argument that can be used to communicate desired state; for example in a reentrant lock, to re-establish the recursion count when re-acquiring the lock after returning from a condition wait.Many synchronizers do not need such an argument, and so just ignore it.</p>

<p>AQS的具体实现类必须实现<code>tryAcquire</code> 和 <code>tryRelease</code>以便获得AQS提供的 <code>acquire</code> 和 <code>release</code> 操作。如果同步状态允许线程通过，<code>tryAcquire</code>方法必须返回<code>true</code>，<code>tryRelease</code>必须返回<code>true</code>如果新的同步状态允许阻塞的线程通过。<code>tryAcquire</code>和<code>tryRelease</code>接受一个<code>int</code>类型的参数，很多同步器不需要这个参数，直接忽略了它。</p>

<p>Until JSR166, there was no Java API available to block and unblock threads for purposes of creating synchronizers that are not based on built-in monitors. The only candidates were <code>Thread.suspend</code> and <code>Thread.resume</code>, which are unusable because they encounter an unsolvable race problem: If an unblocking thread invokes <code>resume</code> before the blocking thread has executed <code>suspend</code>, the <code>resume</code> operation will have no effect.</p>

<p>在JSR166之前，没有Java API来提供除了基于内置锁之外的线程阻塞唤醒同步操作。可选的有<code>Thread.suspend</code>和<code>Thread.resume</code>，但是如果一个线程在<code>suspend</code>之前先调用了<code>resume</code>，<code>resume</code>将无效。</p>

<p>The <code>java.util.concurrent.locks</code> package includes a <code>LockSupport</code> class with methods that address this problem. Method <code>LockSupport.park</code> blocks the current thread unless or until a <code>LockSupport.unpark</code> has been issued. (Spurious wakeups are also permitted.) Calls to <code>unpark</code> are not &ldquo;counted&rdquo;, so multiple unparks before a park only unblock a single park.Additionally, this applies per-thread, not per-synchronizer. A thread invoking park on a new synchronizer might return immediately because of a &ldquo;leftover&rdquo; unpark from a previous usage. However, in the absence of an unpark, its next invocation will block. While it would be possible to explicitly clear this state, it is not worth doing so. It is more efficient to invoke park multiple times when it happens to be necessary.This simple mechanism is similar to those used, at some level, in the Solaris-9 thread library, in WIN32 &ldquo;consumable events&rdquo;,and in the Linux NPTL thread library, and so maps efficiently to each of these on the most common platforms Java runs on.(However, the current Sun Hotspot JVM reference implementation on Solaris and Linux actually uses a pthread condvar in order to fit into the existing runtime design.) The park method also supports optional relative and absolute timeouts, and is integrated with JVM <code>Thread.interrupt</code> support — interrupting a thread unparks it.</p>

<p>JUC提供了<code>LockSupport</code>来解决这个问题。<code>LockSupport</code>还支持可选的超时，而且提供了对线程中断的支持。</p>

<p>The heart of the framework is maintenance of queues of blocked threads, which are restricted here to FIFO queues. Thus, the framework does not support priority-based synchronization.These days, there is little controversy that the most appropriate choices for synchronization queues are non-blocking data structures that do not themselves need to be constructed using lower-level locks. And of these, there are two main candidates: variants of Mellor-Crummey and Scott (MCS) locks, and variants of Craig, Landin, and Hagersten (CLH) locks.Historically, CLH locks have been used only in spinlocks.However, they appeared more amenable than MCS for use in the synchronizer framework because they are more easily adapted to handle cancellation and timeouts, so were chosen as a basis. The resulting design is far enough removed from the original CLH structure to require explanation.A CLH queue is not very queue-like, because its enqueuing and dequeuing operations are intimately tied to its uses as a lock. It is a linked queue accessed via two atomically updatable fields,head and tail, both initially pointing to a dummy node.</p>

<p>AQS的等待队列是CLH队列的变种。</p>

<p>A new node, node, is enqueued using an atomic operation:</p>

<p><code>java
do { pred = tail;
} while(!tail.compareAndSet(pred, node));
</code></p>

<p>The <code>release</code> status for each node is kept in its predecessor node.So, the &ldquo;spin&rdquo; of a spinlock looks like:</p>

<p><code>java
while (pred.status != RELEASED) ; // spin
</code></p>

<p>A dequeue operation after this spin simply entails setting the head field to the node that just got the lock:</p>

<p><code>java
head = node;
</code></p>

<p>新节点入队通过CAS设置<code>tail</code>来实现，当前节点的释放状态取决于前驱节点的状态。自旋结束后出队一个节点会把<code>head</code>设置为这个节点。</p>

<p>AQS的等待队列使用<code>next</code>指针保存了后继节点，用<code>status</code>保存了节点代表的线程的状态，比如可能线程已经取消了等待。</p>

<p>Omitting such details, the general form of the resulting implementation of the basic acquire operation (exclusive,noninterruptible, untimed case only) is:</p>

<p>```java
if (!tryAcquire(arg)) {</p>

<pre><code>node = create and enqueue new node;
pred = node's effective predecessor;
while (pred is not head node || !tryAcquire(arg)) {
    if (pred's signal bit is set)
        park();
    else
        compareAndSet pred's signal bit to true;
    pred = node's effective predecessor;
}
head = node;
</code></pre>

<p>}
```</p>

<p>And the release operation is:</p>

<p>```java
if (tryRelease(arg) &amp;&amp; head node&rsquo;s signal bit is set) {</p>

<pre><code>compareAndSet head's signal bit to false;
unpark head's successor, if one exists
</code></pre>

<p>}
```</p>

<p>The synchronizer framework provides a <code>ConditionObject</code> class for use by synchronizers that maintain exclusive synchronization and conform to the Lock interface. Any number of condition objects may be attached to a lock object, providing classic monitor-style <code>await</code>, <code>signal</code>, and <code>signalAll</code> operations, including those with timeouts, along with some inspection and monitoring methods.</p>

<p>AQS框架还提供了<code>ConditionObject</code>来提供和内置锁<code>wait/notify/notifyAll</code>类似的<code>await/signal/signalAll</code>功能。</p>

<p>The <code>ConditionObject</code> class enables conditions to be efficiently integrated with other synchronization operations,again by fixing some design decisions. This class supports only Java-style monitor access rules in which condition operations are legal only when the lock owning the condition is held by the current thread. Thus, a <code>ConditionObject</code> attached to a ReentrantLock acts in the same way as do built-in monitors (via <code>Object.wait</code> etc), differing only in method names, extra functionality, and the fact that users can declare multiple conditions per lock.A <code>ConditionObject</code> uses the same internal queue nodes as synchronizers, but maintains them on a separate condition queue.The signal operation is implemented as a queue transfer from the condition queue to the lock queue, without necessarily waking up the signalled thread before it has re-acquired its lock.</p>

<p>The basic await operation is:</p>

<p><code>java
 create and add new node to condition queue;
 release lock;
 block until node is on lock queue;
 re-acquire lock;
</code></p>

<p>And the signal operation is:</p>

<p><code>java
 transfer the first node from condition queue to lock queue;
</code></p>

<p><code>ConditionObject</code>提供和内置锁类似的功能，在一个<code>Lock</code>上可以声明多个<code>ConditionObject</code>。<code>ConditionObject</code>使用condition queue来维护等待队列，condition queue上的节点和lock queue中的节点相同，<code>await</code>是入condition queue，<code>signal</code>是从condition queue中转移到lock queue中。</p>

<p>Because these operations are performed only when the lock is held, they can use sequential linked queue operations (using a <code>nextWaiter</code> field in nodes) to maintain the condition queue.The transfer operation simply unlinks the first node from the condition queue, and then uses CLH insertion to attach it to the lock queue. The main complication in implementing these operations is dealing with cancellation of condition waits due to timeouts or <code>Thread.interrupt</code>. A cancellation and signal occuring at approximately the same time encounter a race whose outcome conforms to the specifications for built-in monitors. As revised in JSR133, these require that if an interrupt occurs before a signal, then the <code>await</code> method must, after re-acquiring the lock, throw <code>InterruptedException</code>. But if it is interrupted after a signal, then the method must return without throwing an exception, but with its thread interrupt status set.</p>

<p>transfer操作是从将condition queue里的第一个节点从condition queue中移除，插入到lock queue中去。如果在<code>signal</code>之前发生了线程中断，那么<code>await</code>必须在重新获取锁之后抛出<code>InterruptedException</code>。如果在<code>signal</code>之后发生了中断，那么线程中断状态将被设置，但是不会抛出异常。</p>

<p>Here are sketches of how java.util.concurrent synchronizer classes are defined using this framework:</p>

<ul>
<li>The <code>ReentrantLock</code> class uses synchronization state to hold the (recursive) lock count. When a lock is acquired, it also records the identity of the current thread to check recursions and detect illegal state exceptions when the wrong thread tries to unlock. The class also uses the provided <code>ConditionObject</code>, and exports other monitoring and inspection methods. The class supports an optional &ldquo;fair&rdquo; mode by internally declaring two different <code>AbstractQueuedSynchronizer</code> subclasses (the fair one disabling barging) and setting each <code>ReentrantLock</code> instance to use the appropriate one upon construction.</li>
<li>The <code>ReentrantReadWriteLock</code> class uses 16 bits of the synchronization state to hold the write lock count, and the remaining 16 bits to hold the read lock count. The <code>WriteLock</code> is otherwise structured in the same way as <code>ReentrantLock</code>.The <code>ReadLock</code> uses the <code>acquireShared</code> methods to enable multiple readers.</li>
<li>The <code>Semaphore</code> class (a counting semaphore) uses the synchronization state to hold the current count. It defines <code>acquireShared</code> to decrement the count or block if nonpositive, and <code>tryRelease</code> to increment the count, possibly unblocking threads if it is now positive.</li>
<li>The <code>CountDownLatch</code> class uses the synchronization state to represent the count. All acquires pass when it reaches zero.</li>
<li>The <code>FutureTask</code> class uses the synchronization state to represent the run-state of a future (initial, running, cancelled,done). Setting or cancelling a future invokes <code>release</code>,unblocking threads waiting for its computed value via <code>acquire</code>.</li>
<li>The <code>SynchronousQueue</code> class (a CSP-style handoff) uses internal wait-nodes that match up producers and consumers. It uses the synchronization state to allow a producer to proceed when a consumer takes the item, and vice-versa.</li>
</ul>


<p>JUC框架中几个使用AQS的同步器类的内部实现。</p>

<h3>reference</h3>

<ul>
<li><a href="https://javadoop.com/post/AbstractQueuedSynchronizer">一行一行源码分析清楚 AbstractQueuedSynchronizer</a></li>
<li><a href="https://javadoop.com/post/AbstractQueuedSynchronizer-2">一行一行源码分析清楚 AbstractQueuedSynchronizer（二）</a></li>
<li><a href="https://javadoop.com/post/AbstractQueuedSynchronizer-3">一行一行源码分析清楚 AbstractQueuedSynchronizer（三）</a></li>
<li><a href="http://ifeve.com/introduce-abstractqueuedsynchronizer/">AbstractQueuedSynchronizer的介绍和原理分析</a></li>
<li><a href="https://www.infoq.cn/article/jdk1.8-abstractqueuedsynchronizer">深度解析 Java 8：JDK1.8 AbstractQueuedSynchronizer 的实现分析（上）</a></li>
<li><a href="https://www.infoq.cn/article/java8-abstractqueuedsynchronizer">深度解析 Java 8：AbstractQueuedSynchronizer 的实现分析（下）</a></li>
<li><a href="https://juejin.im/post/5aeb07ab6fb9a07ac36350c8">深入理解AbstractQueuedSynchronizer(AQS)</a></li>
<li><a href="https://liuzhengyang.github.io/2017/05/12/aqs/">AbstractQueuedSynchronizer使用和源码分析</a></li>
<li><a href="https://www.jianshu.com/p/e7659436538b">AbstractQueuedSynchronizer 源码分析 (基于Java 8)</a></li>
<li><a href="https://segmentfault.com/a/1190000014221325">源码分析JDK8之AbstractQueuedSynchronizer</a></li>
<li><a href="http://gee.cs.oswego.edu/dl/papers/aqs.pdf">aqs.pdf</a></li>
<li><a href="http://www.cs.tau.ac.il/~shanir/nir-pubs-web/Papers/CLH.pdf">CLH.pdf</a></li>
<li><a href="https://coderbee.net/index.php/concurrent/20131115/577">自旋锁、排队自旋锁、MCS锁、CLH锁</a></li>
</ul>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Java FutureTask解析]]></title>
    <link href="http://Solarex.github.io/blog/2019/06/28/futuretask/"/>
    <updated>2019-06-28T16:59:00+08:00</updated>
    <id>http://Solarex.github.io/blog/2019/06/28/futuretask</id>
    <content type="html"><![CDATA[<p>本文主要对FutureTask源码进行分析。</p>

<!-- more -->


<p>Java中一般通过继承Thread类或实现Runnable接口来创建线程，但是这两种方式都有个缺陷，就是不能在线程执行完成后获取执行的结果，因此Java1.5之后提供了<code>Callable</code>和<code>Future</code>接口，通过他们就可以在任务执行完成之后获取到任务的执行结果。</p>

<h3>Callable接口</h3>

<p>```java
/<em>*
 * A task that returns a result and may throw an exception.
 * Implementors define a single method with no arguments called
 * {@code call}.
 *
 * <p>The {@code Callable} interface is similar to {@link
 * java.lang.Runnable}, in that both are designed for classes whose
 * instances are potentially executed by another thread.  A
 * {@code Runnable}, however, does not return a result and cannot
 * throw a checked exception.
 *
 * <p>The {@link Executors} class contains utility methods to
 * convert from other common forms to {@code Callable} classes.
 *
 * @see Executor
 * @since 1.5
 * @author Doug Lea
 * @param <V> the result type of method {@code call}
 </em>/
@FunctionalInterface
public interface Callable<V> {</p>

<pre><code>/**
 * Computes a result, or throws an exception if unable to do so.
 *
 * @return computed result
 * @throws Exception if unable to compute a result
 */
V call() throws Exception;
</code></pre>

<p>}
```</p>

<p>可以看到<code>Callable</code>是个泛型接口，泛型V代表返回值的类型，执行任务过程中如果有异常会抛出异常。</p>

<h3>Future接口</h3>

<p>```java
/<em>*
 * A {@code Future} represents the result of an asynchronous
 * computation.  Methods are provided to check if the computation is
 * complete, to wait for its completion, and to retrieve the result of
 * the computation.  The result can only be retrieved using method
 * {@code get} when the computation has completed, blocking if
 * necessary until it is ready.  Cancellation is performed by the
 * {@code cancel} method.  Additional methods are provided to
 * determine if the task completed normally or was cancelled. Once a
 * computation has completed, the computation cannot be cancelled.
 * If you would like to use a {@code Future} for the sake
 * of cancellability but not provide a usable result, you can
 * declare types of the form {@code Future&lt;?>} and
 * return {@code null} as a result of the underlying task.
 *
 * <p>
 * <b>Sample Usage</b> (Note that the following classes are all
 * made-up.)
 *
 * <pre> {@code
 * interface ArchiveSearcher { String search(String target); }
 * class App {
 *   ExecutorService executor = &hellip;
 *   ArchiveSearcher searcher = &hellip;
 *   void showSearch(final String target)
 *       throws InterruptedException {
 *     Future<String> future
 *       = executor.submit(new Callable<String>() {
 *         public String call() {
 *             return searcher.search(target);
 *         }});
 *     displayOtherThings(); // do other things while searching
 *     try {
 *       displayText(future.get()); // use future
 *     } catch (ExecutionException ex) { cleanup(); return; }
 *   }
 * }}</pre>
 *
 * The {@link FutureTask} class is an implementation of {@code Future} that
 * implements {@code Runnable}, and so may be executed by an {@code Executor}.
 * For example, the above construction with {@code submit} could be replaced by:
 * <pre> {@code
 * FutureTask<String> future =
 *   new FutureTask&lt;>(new Callable<String>() {
 *     public String call() {
 *       return searcher.search(target);
 *   }});
 * executor.execute(future);}</pre>
 *
 * <p>Memory consistency effects: Actions taken by the asynchronous computation
 * <a href="package-summary.html#MemoryVisibility"> <i>happen-before</i></a>
 * actions following the corresponding {@code Future.get()} in another thread.
 *
 * @see FutureTask
 * @see Executor
 * @since 1.5
 * @author Doug Lea
 * @param <V> The result type returned by this Future&rsquo;s {@code get} method
 </em>/
public interface Future<V> {</p>

<pre><code>/**
 * Attempts to cancel execution of this task.  This attempt will
 * fail if the task has already completed, has already been cancelled,
 * or could not be cancelled for some other reason. If successful,
 * and this task has not started when {@code cancel} is called,
 * this task should never run.  If the task has already started,
 * then the {@code mayInterruptIfRunning} parameter determines
 * whether the thread executing this task should be interrupted in
 * an attempt to stop the task.
 *
 * &lt;p&gt;After this method returns, subsequent calls to {@link #isDone} will
 * always return {@code true}.  Subsequent calls to {@link #isCancelled}
 * will always return {@code true} if this method returned {@code true}.
 *
 * @param mayInterruptIfRunning {@code true} if the thread executing this
 * task should be interrupted; otherwise, in-progress tasks are allowed
 * to complete
 * @return {@code false} if the task could not be cancelled,
 * typically because it has already completed normally;
 * {@code true} otherwise
 */
boolean cancel(boolean mayInterruptIfRunning);

/**
 * Returns {@code true} if this task was cancelled before it completed
 * normally.
 *
 * @return {@code true} if this task was cancelled before it completed
 */
boolean isCancelled();

/**
 * Returns {@code true} if this task completed.
 *
 * Completion may be due to normal termination, an exception, or
 * cancellation -- in all of these cases, this method will return
 * {@code true}.
 *
 * @return {@code true} if this task completed
 */
boolean isDone();

/**
 * Waits if necessary for the computation to complete, and then
 * retrieves its result.
 *
 * @return the computed result
 * @throws CancellationException if the computation was cancelled
 * @throws ExecutionException if the computation threw an
 * exception
 * @throws InterruptedException if the current thread was interrupted
 * while waiting
 */
V get() throws InterruptedException, ExecutionException;

/**
 * Waits if necessary for at most the given time for the computation
 * to complete, and then retrieves its result, if available.
 *
 * @param timeout the maximum time to wait
 * @param unit the time unit of the timeout argument
 * @return the computed result
 * @throws CancellationException if the computation was cancelled
 * @throws ExecutionException if the computation threw an
 * exception
 * @throws InterruptedException if the current thread was interrupted
 * while waiting
 * @throws TimeoutException if the wait timed out
 */
V get(long timeout, TimeUnit unit)
    throws InterruptedException, ExecutionException, TimeoutException;
</code></pre>

<p>}
```</p>

<p><code>Future</code>代表任务异步执行的结果，通过<code>Future</code>接口可以查询任务执行的状态，取消任务执行，获取任务执行的结果。</p>

<ul>
<li>cancel方法尝试去取消任务的执行，如果任务已经完成，或者已经取消，或者由于其他原因无法被取消，cancel方法将返回false。如果cancel调用的时候，任务还没开始执行，任务将不被执行，cancel返回true。如果cancel调用的时候，任务已经开始执行，<code>mayInterruptIfRunning</code>决定执行任务的线程是否应该被中断来执行任务的执行。cancel方法调用返回true后，后续的<code>isDone</code>方法总是返回true，后续的<code>isCancelled</code>方法总是返回true。</li>
<li>如果在任务完成之前被取消了，<code>isCancelled</code>方法会返回true。</li>
<li>任务完成后，<code>isDone</code>方法会返回true。无论是正常的结束，抛出异常结束，被取消，<code>isDone</code>都会返回true。</li>
<li>get方法会等待任务执行结束来获取任务执行的结果，如果任务已经执行结束，直接返回结果。可能抛出<code>CancellationException</code>如果任务被取消，<code>ExecutionException</code>如果任务执行过程中抛出了异常，<code>InterruptedException</code>如果当前线程在等待执行任务的线程的执行结果的过程中被中断了。</li>
<li>get(long,TimeUnit)会等待最多设定的时间来获取结果。可能抛出<code>CancellationException</code>如果任务被取消，<code>ExecutionException</code>如果任务执行过程中抛出了异常，<code>InterruptedException</code>如果当前线程在等待执行任务的线程的执行结果的过程中被中断了，<code>TimeoutException</code>如果等待超时了。</li>
</ul>


<h3>FutureTask</h3>

<p><code>Future</code>只是一个接口，<code>FutureTask</code>是<code>Future</code>的实现类。确切的说<code>FutureTask</code>实现了<code>RunnableFuture</code>接口，<code>RunnableFuture</code>接口扩展了<code>Runnable</code>和<code>Future</code>接口。</p>

<h4>FutureTask任务执行的状态</h4>

<p>```java</p>

<pre><code>/**
 * The run state of this task, initially NEW.  The run state
 * transitions to a terminal state only in methods set,
 * setException, and cancel.  During completion, state may take on
 * transient values of COMPLETING (while outcome is being set) or
 * INTERRUPTING (only while interrupting the runner to satisfy a
 * cancel(true)). Transitions from these intermediate to final
 * states use cheaper ordered/lazy writes because values are unique
 * and cannot be further modified.
 *
 * Possible state transitions:
 * NEW -&gt; COMPLETING -&gt; NORMAL
 * NEW -&gt; COMPLETING -&gt; EXCEPTIONAL
 * NEW -&gt; CANCELLED
 * NEW -&gt; INTERRUPTING -&gt; INTERRUPTED
 */
private volatile int state;
private static final int NEW          = 0;
private static final int COMPLETING   = 1;
private static final int NORMAL       = 2;
private static final int EXCEPTIONAL  = 3;
private static final int CANCELLED    = 4;
private static final int INTERRUPTING = 5;
private static final int INTERRUPTED  = 6;
</code></pre>

<p>```</p>

<p>可以看到<code>FutureTask</code>使用<code>volatile</code>变量<code>state</code>来表示任务执行的状态，初始时是<code>NEW</code>，在<code>set</code>，<code>setException</code>和<code>cancel</code>方法中会对<code>state</code>进行赋值。可能的状态转换有<code>NEW -&gt; COMPLETING -&gt; NORMAL</code>，<code>NEW -&gt; COMPLETING -&gt; EXCEPTIONAL</code>，<code>NEW -&gt; CANCELLED</code>，<code>NEW -&gt; INTERRUPTING -&gt; INTERRUPTED</code>。</p>

<h4>FutureTask内部变量</h4>

<p>```java</p>

<pre><code>/** The underlying callable; nulled out after running */
private Callable&lt;V&gt; callable;
/** The result to return or exception to throw from get() */
private Object outcome; // non-volatile, protected by state reads/writes
/** The thread running the callable; CASed during run() */
private volatile Thread runner;
/** Treiber stack of waiting threads */
private volatile WaitNode waiters;
</code></pre>

<p>```</p>

<p><code>callable</code>表示将要执行的任务，<code>volatile</code>类型的变量<code>runner</code>表示执行任务的线程，<code>waiters</code>表示等待任务执行结果的线程队列。任务执行的结果用Object类型的<code>outcome</code>表示，可以看到并没有用<code>volatile</code>关键字来修饰，那不会有可见性问题吗？这个问题后面我们会提到。</p>

<h4>FutureTask任务执行run</h4>

<p>```java
public void run() {</p>

<pre><code>    if (state != NEW ||
        !U.compareAndSwapObject(this, RUNNER, null, Thread.currentThread()))
        return;
    try {
        Callable&lt;V&gt; c = callable;
        if (c != null &amp;&amp; state == NEW) {
            V result;
            boolean ran;
            try {
                result = c.call();
                ran = true;
            } catch (Throwable ex) {
                result = null;
                ran = false;
                setException(ex); // 任务执行抛出异常走setException
            }
            if (ran)
                set(result); // 任务正常执行完成走set
        }
    } finally {
        // runner must be non-null until state is settled to
        // prevent concurrent calls to run()
        runner = null;
        // state must be re-read after nulling runner to prevent
        // leaked interrupts
        int s = state;
        if (s &gt;= INTERRUPTING)
            handlePossibleCancellationInterrupt(s);
    }
}
</code></pre>

<p>```</p>

<p><code>run</code>方法首先对状态进行判断，并尝试CAS替换<code>runner</code>为当前线程，如果失败，表明已经有线程在执行任务了，直接返回，否则执行任务，如果任务执行过程中抛出了异常，走<code>setException</code>分支，如果任务正常结束，走<code>set</code>分支，下面看下这两个方法。</p>

<h4>FutureTask的set和setException方法</h4>

<p>```java</p>

<pre><code>/**
 * Sets the result of this future to the given value unless
 * this future has already been set or has been cancelled.
 *
 * &lt;p&gt;This method is invoked internally by the {@link #run} method
 * upon successful completion of the computation.
 *
 * @param v the value
 */
protected void set(V v) {
    if (U.compareAndSwapInt(this, STATE, NEW, COMPLETING)) {
        outcome = v;
        U.putOrderedInt(this, STATE, NORMAL); // final state
        finishCompletion();
    }
}
/**
 * Removes and signals all waiting threads, invokes done(), and
 * nulls out callable.
 */
private void finishCompletion() {
    // assert state &gt; COMPLETING;
    for (WaitNode q; (q = waiters) != null;) {
        if (U.compareAndSwapObject(this, WAITERS, q, null)) {
            for (;;) {
                Thread t = q.thread;
                if (t != null) {
                    q.thread = null;
                    LockSupport.unpark(t);
                }
                WaitNode next = q.next;
                if (next == null)
                    break;
                q.next = null; // unlink to help gc
                q = next;
            }
            break;
        }
    }

    done();

    callable = null;        // to reduce footprint
}
/**
 * Causes this future to report an {@link ExecutionException}
 * with the given throwable as its cause, unless this future has
 * already been set or has been cancelled.
 *
 * &lt;p&gt;This method is invoked internally by the {@link #run} method
 * upon failure of the computation.
 *
 * @param t the cause of failure
 */
protected void setException(Throwable t) {
    if (U.compareAndSwapInt(this, STATE, NEW, COMPLETING)) {
        outcome = t;
        U.putOrderedInt(this, STATE, EXCEPTIONAL); // final state
        finishCompletion();
    }
}
</code></pre>

<p>```</p>

<p>可以看到<code>set</code>和<code>setException</code>方法都是CAS对<code>state</code>进行赋值，并对<code>outcome</code>进行赋值，同时调用<code>finishCompletion</code>方法唤醒等待队列中的线程去获取任务执行的结果。在这里可以看到对<code>outcome</code>的写发生在对<code>volatile</code>变量<code>state</code>写之前，因此保证了<code>state</code>为<code>NORMAL</code>或<code>EXCEPTIONAL</code>时<code>outcome</code>变量的可见性。在<code>finishCompletion</code>中可以看到是对等待队列上的线程进行唤醒操作，那么这些线程是什么时候进行等待队列并阻塞的呢，接下来看<code>get</code>方法。</p>

<h4>FutureTask的get方法</h4>

<p>```java</p>

<pre><code>/**
 * @throws CancellationException {@inheritDoc}
 */
public V get() throws InterruptedException, ExecutionException {
    int s = state;
    if (s &lt;= COMPLETING)
        s = awaitDone(false, 0L);
    return report(s);
}
/**
 * @throws CancellationException {@inheritDoc}
 */
public V get(long timeout, TimeUnit unit)
    throws InterruptedException, ExecutionException, TimeoutException {
    if (unit == null)
        throw new NullPointerException();
    int s = state;
    if (s &lt;= COMPLETING &amp;&amp;
        (s = awaitDone(true, unit.toNanos(timeout))) &lt;= COMPLETING)
        throw new TimeoutException();
    return report(s);
}
/**
 * Awaits completion or aborts on interrupt or timeout.
 *
 * @param timed true if use timed waits
 * @param nanos time to wait, if timed
 * @return state upon completion or at timeout
 */
private int awaitDone(boolean timed, long nanos)
    throws InterruptedException {
    // The code below is very delicate, to achieve these goals:
    // - call nanoTime exactly once for each call to park
    // - if nanos &lt;= 0L, return promptly without allocation or nanoTime
    // - if nanos == Long.MIN_VALUE, don't underflow
    // - if nanos == Long.MAX_VALUE, and nanoTime is non-monotonic
    //   and we suffer a spurious wakeup, we will do no worse than
    //   to park-spin for a while
    long startTime = 0L;    // Special value 0L means not yet parked
    WaitNode q = null;
    boolean queued = false;
    for (;;) {
        int s = state;
        if (s &gt; COMPLETING) {
            if (q != null)
                q.thread = null;
            return s;
        }
        else if (s == COMPLETING)
            // We may have already promised (via isDone) that we are done
            // so never return empty-handed or throw InterruptedException
            Thread.yield();
        else if (Thread.interrupted()) {
            removeWaiter(q);
            throw new InterruptedException();
        }
        else if (q == null) {
            if (timed &amp;&amp; nanos &lt;= 0L)
                return s;
            q = new WaitNode();
        }
        else if (!queued)
            queued = U.compareAndSwapObject(this, WAITERS,
                                            q.next = waiters, q);
        else if (timed) {
            final long parkNanos;
            if (startTime == 0L) { // first time
                startTime = System.nanoTime();
                if (startTime == 0L)
                    startTime = 1L;
                parkNanos = nanos;
            } else {
                long elapsed = System.nanoTime() - startTime;
                if (elapsed &gt;= nanos) {
                    removeWaiter(q);
                    return state;
                }
                parkNanos = nanos - elapsed;
            }
            // nanoTime may be slow; recheck before parking
            if (state &lt; COMPLETING)
                LockSupport.parkNanos(this, parkNanos);
        }
        else
            LockSupport.park(this);
    }
/**
 * Returns result or throws exception for completed task.
 *
 * @param s completed state value
 */
@SuppressWarnings("unchecked")
private V report(int s) throws ExecutionException {
    Object x = outcome;
    if (s == NORMAL)
        return (V)x;
    if (s &gt;= CANCELLED)
        throw new CancellationException();
    throw new ExecutionException((Throwable)x);
}
</code></pre>

<p>```</p>

<p>可以看到<code>get</code>的两个方法都是调用了<code>awaitDone</code>方法，下面重点看下<code>awaitDone</code>方法。</p>

<p><code>awaitDone</code>方法里面有个for死循环，退出循环的只有<code>state &gt; COMPLETING</code>时<code>return state</code>，或者是在<code>Thread.interrupted()</code>返回true表示线程被中断时将线程从等待队列中移除并抛出<code>InterruptedException</code>。</p>

<p>进入for循环的时候如果任务的状态已经完成或者任务执行的时候抛出了异常，也即<code>state &gt; COMPLETING</code>时，直接返回<code>state</code>，在<code>set</code>或者<code>setException</code>中会根据<code>state</code>进行<code>report</code>调用返回不同的状态。</p>

<p>在for循环中如果当前线程被中断，则将当前线程从等待队列中移除并抛出<code>InterruptedException</code>异常。</p>

<p>如果任务的状态<code>state &lt; COMPLETING</code>也即任务正在执行，当前线程也没有被中断，第一次进入for循环的时候会进入<code>q == null</code>分支，创建<code>WaitNode</code>节点。</p>

<p>```java
/**</p>

<pre><code> * Simple linked list nodes to record waiting threads in a Treiber
 * stack.  See other classes such as Phaser and SynchronousQueue
 * for more detailed explanation.
 */
static final class WaitNode {
    volatile Thread thread;
    volatile WaitNode next;
    WaitNode() { thread = Thread.currentThread(); }
}
</code></pre>

<p>```</p>

<p>下次再进入for循环会进入<code>!queued</code>分支，尝试将刚创建的<code>WaitNode</code>节点的next指针指向<code>FutureTask</code>的<code>waiters</code>，并CAS替换<code>FutureTask</code>的<code>waiters</code>为刚创建的<code>WaitNode</code>节点，如果CAS失败，说明有其他线程也在进行CAS替换<code>FutureTask</code>的<code>waiters</code>的操作，并且成功了，下次再进for循环继续进行这个CAS操作，直到返回true，<code>queued</code>为true为止。到此，线程进入到了等待队列中，下次再进入for循环会根据是否<code>timed</code>来进行<code>LockSupport.parkNanos</code>或<code>LockSupport.park</code>阻塞线程操作，等待其他线程<code>unpark</code>来唤醒当前线程。那什么时候唤醒呢，其实在分析<code>run</code>方法的时候我们已经看到了在执行完后会进行<code>finishCompletion</code>操作，在<code>finishCompletion</code>方法中会唤醒等待队列中的线程。</p>

<h4>FutureTask的cancel方法</h4>

<p>```java
public boolean cancel(boolean mayInterruptIfRunning) {</p>

<pre><code>    if (!(state == NEW &amp;&amp;
          U.compareAndSwapInt(this, STATE, NEW,
              mayInterruptIfRunning ? INTERRUPTING : CANCELLED)))
        return false;
    try {    // in case call to interrupt throws exception
        if (mayInterruptIfRunning) {
            try {
                Thread t = runner;
                if (t != null)
                    t.interrupt();
            } finally { // final state
                U.putOrderedInt(this, STATE, INTERRUPTED);
            }
        }
    } finally {
        finishCompletion();
    }
    return true;
}
</code></pre>

<p>```</p>

<p>如果<code>state == NEW &amp;&amp; U.compareAndSwapInt(this, STATE, NEW,mayInterruptIfRunning ? INTERRUPTING : CANCELLED)</code>返回false说明任务的<code>state</code>已经不是<code>NEW</code>了，直接返回false。否则根据<code>mayInterruptIfRunning</code>来对执行任务的线程<code>runner</code>进行中断操作。最后在<code>finally</code>块中进行了<code>finishCompletion</code>操作，来唤醒等待队列中的线程。</p>

<h4>FutureTask的runAndReset方法</h4>

<p>```java</p>

<pre><code>/**
 * Executes the computation without setting its result, and then
 * resets this future to initial state, failing to do so if the
 * computation encounters an exception or is cancelled.  This is
 * designed for use with tasks that intrinsically execute more
 * than once.
 *
 * @return {@code true} if successfully run and reset
 */
protected boolean runAndReset() {
    if (state != NEW ||
        !U.compareAndSwapObject(this, RUNNER, null, Thread.currentThread()))
        return false;
    boolean ran = false;
    int s = state;
    try {
        Callable&lt;V&gt; c = callable;
        if (c != null &amp;&amp; s == NEW) {
            try {
                c.call(); // don't set result
                ran = true;
            } catch (Throwable ex) {
                setException(ex);
            }
        }
    } finally {
        // runner must be non-null until state is settled to
        // prevent concurrent calls to run()
        runner = null;
        // state must be re-read after nulling runner to prevent
        // leaked interrupts
        s = state;
        if (s &gt;= INTERRUPTING)
            handlePossibleCancellationInterrupt(s);
    }
    return ran &amp;&amp; s == NEW;
}
</code></pre>

<p>```</p>

<p><code>runAndReset</code>方法相比<code>run</code>方法是在调用完<code>callable</code>的<code>call</code>方法后没有调用<code>set(result)</code>，没有对<code>state</code>任务状态进行转换，没有对<code>outcome</code>进行赋值，如果任务正常执行结束，<code>state</code>应该还是<code>NEW</code>，因此可以被重复调用。</p>

<h4>FutureTask的isCancelled和isDone方法</h4>

<p>```java</p>

<pre><code>public boolean isCancelled() {
    return state &gt;= CANCELLED;
}

public boolean isDone() {
    return state != NEW;
}
</code></pre>

<p>```</p>

<p>都是对<code>state</code>的判断</p>

<h3>reference</h3>

<ul>
<li><a href="https://stackoverflow.com/questions/14432400/why-outcome-object-in-futuretask-is-non-volatile">why outcome object in FutureTask is non-volatile?</a></li>
</ul>

]]></content>
  </entry>
  
</feed>
