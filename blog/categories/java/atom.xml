<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: java | Solarex's Blog]]></title>
  <link href="http://Solarex.github.io/blog/categories/java/atom.xml" rel="self"/>
  <link href="http://Solarex.github.io/"/>
  <updated>2019-04-18T11:48:18+08:00</updated>
  <id>http://Solarex.github.io/</id>
  <author>
    <name><![CDATA[Solarex]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[EffectiveJava2nd读书笔记]]></title>
    <link href="http://Solarex.github.io/blog/2018/07/12/notes-on-effective-java/"/>
    <updated>2018-07-12T14:30:00+08:00</updated>
    <id>http://Solarex.github.io/blog/2018/07/12/notes-on-effective-java</id>
    <content type="html"><![CDATA[<p>已迁移到gitbook，请访问<a href="https://solarex.github.io/reading-notes/effective-java/readme.html">EffectiveJava笔记</a>。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[深入理解Java虚拟机读书笔记]]></title>
    <link href="http://Solarex.github.io/blog/2018/07/11/notes-on-jvm/"/>
    <updated>2018-07-11T14:28:00+08:00</updated>
    <id>http://Solarex.github.io/blog/2018/07/11/notes-on-jvm</id>
    <content type="html"><![CDATA[<p>已迁移到gitbook，请访问<a href="https://solarex.github.io/reading-notes/deep-into-jvm/readme.html">深入理解Java虚拟机笔记</a></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Java泛型语法糖]]></title>
    <link href="http://Solarex.github.io/blog/2018/07/10/java-generics-syntactic-sugar/"/>
    <updated>2018-07-10T14:24:00+08:00</updated>
    <id>http://Solarex.github.io/blog/2018/07/10/java-generics-syntactic-sugar</id>
    <content type="html"><![CDATA[
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Java枚举语法糖]]></title>
    <link href="http://Solarex.github.io/blog/2018/07/10/java-enum-syntactic-sugar/"/>
    <updated>2018-07-10T14:24:00+08:00</updated>
    <id>http://Solarex.github.io/blog/2018/07/10/java-enum-syntactic-sugar</id>
    <content type="html"><![CDATA[<p>Java从1.5引入枚举类型，EffectiveJava第2版item 30也建议我们使用枚举来代替int常量。我们从下面的<code>Enum</code>示例中看下枚举类型到底是什么。</p>

<p>```java
public class Main {</p>

<pre><code>enum ExceptionHandleStrategy {
    IGNORE,
    LOG {
        @Override
        public void handle(Exception e) {
            System.out.println(e.getLocalizedMessage());
        }
    },
    THROW {
        @Override
        public void handle(Exception e) {
            throw new RuntimeException(e.getMessage());
        }
    };

    public void handle(Exception e) {
    }
}

public static void main(String[] args) {
    System.out.println(ExceptionHandleStrategy.IGNORE.getClass());
    System.out.println(ExceptionHandleStrategy.LOG.getClass());
    System.out.println(ExceptionHandleStrategy.THROW.getClass());
    System.out.println(EnumWithoutMethod.A.getClass());
    System.out.println(EnumWithoutMethod.B.getClass());
    System.out.println(EnumWithoutMethod.C.getClass());
    System.out.println(EnumWithVariable.A.getClass());
    System.out.println(EnumWithVariable.B.getClass());
    System.out.println(EnumWithVariable.C.getClass());
    System.out.println(EnumWithVariable.A.name());
    System.out.println(EnumWithVariable.A.getxxx());
    ExceptionHandleStrategy.LOG.handle(new RuntimeException("system just broken"));
}

enum EnumWithoutMethod {
    A,
    B,
    C;
}

enum EnumWithVariable {
    A("wristband"),
    B("glucometer"),
    C("fit");

    private String name;
    public String getxxx() {
        return this.name;
    }

    EnumWithVariable(String name){
        this.name = name;
    }
}
</code></pre>

<p>}
```</p>

<!-- more -->


<p>执行<code>java -jar ~/Software/confs/cfr-0.140.jar --sugarenums false Main.class</code>后我们得到如下结果：</p>

<p>```java
import java.io.PrintStream;</p>

<p>public class Main {</p>

<pre><code>public static void main(String[] arrstring) {
    System.out.println(((Object)((Object)ExceptionHandleStrategy.IGNORE)).getClass());
    System.out.println(((Object)((Object)ExceptionHandleStrategy.LOG)).getClass());
    System.out.println(((Object)((Object)ExceptionHandleStrategy.THROW)).getClass());
    System.out.println(((Object)((Object)EnumWithoutMethod.A)).getClass());
    System.out.println(((Object)((Object)EnumWithoutMethod.B)).getClass());
    System.out.println(((Object)((Object)EnumWithoutMethod.C)).getClass());
    System.out.println(((Object)((Object)EnumWithVariable.A)).getClass());
    System.out.println(((Object)((Object)EnumWithVariable.B)).getClass());
    System.out.println(((Object)((Object)EnumWithVariable.C)).getClass());
    System.out.println(EnumWithVariable.A.name());
    System.out.println(EnumWithVariable.A.getxxx());
    ExceptionHandleStrategy.LOG.handle(new RuntimeException("system just broken"));
}

static final class EnumWithVariable
extends Enum&lt;EnumWithVariable&gt; {
    public static final /* enum */ EnumWithVariable A = new EnumWithVariable("A", 0, "wristband");
    public static final /* enum */ EnumWithVariable B = new EnumWithVariable("B", 1, "glucometer");
    public static final /* enum */ EnumWithVariable C = new EnumWithVariable("C", 2, "fit");
    private String name;
    private static final /* synthetic */ EnumWithVariable[] $VALUES;

    public static EnumWithVariable[] values() {
        return (EnumWithVariable[])$VALUES.clone();
    }

    public static EnumWithVariable valueOf(String string) {
        return Enum.valueOf(EnumWithVariable.class, string);
    }

    public String getxxx() {
        return this.name;
    }

    private EnumWithVariable(String string, int n, String string2) {
        super(string, n);
        this.name = string2;
    }

    static {
        $VALUES = new EnumWithVariable[]{A, B, C};
    }
}

static final class EnumWithoutMethod
extends Enum&lt;EnumWithoutMethod&gt; {
    public static final /* enum */ EnumWithoutMethod A = new EnumWithoutMethod("A", 0);
    public static final /* enum */ EnumWithoutMethod B = new EnumWithoutMethod("B", 1);
    public static final /* enum */ EnumWithoutMethod C = new EnumWithoutMethod("C", 2);
    private static final /* synthetic */ EnumWithoutMethod[] $VALUES;

    public static EnumWithoutMethod[] values() {
        return (EnumWithoutMethod[])$VALUES.clone();
    }

    public static EnumWithoutMethod valueOf(String string) {
        return Enum.valueOf(EnumWithoutMethod.class, string);
    }

    private EnumWithoutMethod(String string, int n) {
        super(string, n);
    }

    static {
        $VALUES = new EnumWithoutMethod[]{A, B, C};
    }
}

static class ExceptionHandleStrategy
extends Enum&lt;ExceptionHandleStrategy&gt; {
    public static final /* enum */ ExceptionHandleStrategy IGNORE = new ExceptionHandleStrategy("IGNORE", 0);
    public static final /* enum */ ExceptionHandleStrategy LOG = new ExceptionHandleStrategy("LOG", 1){

        @Override
        public void handle(Exception exception) {
            System.out.println(exception.getLocalizedMessage());
        }
    };
    public static final /* enum */ ExceptionHandleStrategy THROW = new ExceptionHandleStrategy("THROW", 2){

        @Override
        public void handle(Exception exception) {
            throw new RuntimeException(exception.getMessage());
        }
    };
    private static final /* synthetic */ ExceptionHandleStrategy[] $VALUES;

    public static ExceptionHandleStrategy[] values() {
        return (ExceptionHandleStrategy[])$VALUES.clone();
    }

    public static ExceptionHandleStrategy valueOf(String string) {
        return Enum.valueOf(ExceptionHandleStrategy.class, string);
    }

    private ExceptionHandleStrategy(String string, int n) {
        super(string, n);
    }

    public void handle(Exception exception) {
    }

    static {
        $VALUES = new ExceptionHandleStrategy[]{IGNORE, LOG, THROW};
    }

}
</code></pre>

<p>}
```</p>

<p>可以看到我们的枚举类型都继承了<code>Enum</code>，编译器为我们生成了<code>$VALUES</code>类型数组，并在<code>static</code>静态块中进行了初始化。每个枚举类型实际上是个继承了<code>Enum</code>的类，并在类初始化的时候实例化了枚举类型的实例，可以看到非常重量级，实际上在Android开发中Google已经建议不要使用<code>Enum</code>，改而使用<code>@IntDef</code>之类的注解进行约束。</p>

<p>在看EffectiveJava的时候，看到作者认为Enum是实现单例的一种方式，<code>Enum</code>实现的单例帮我们处理了反射和序列化相关的问题，那它是怎么处理的呢？我们不妨看下源码来找下答案。</p>

<p>首先看下<code>Enum</code>类的<code>readObject</code>方法：</p>

<p>```java
/<em>*
  * prevent default deserialization
  </em>/
private void readObject(ObjectInputStream in) throws IOException,</p>

<pre><code>ClassNotFoundException {
throw new InvalidObjectException("can't deserialize enum");
</code></pre>

<p>}
```</p>

<p>可以看到这个方法直接抛出了一个异常来阻止反序列化。</p>

<p>再来看下如果我们想要使用反射来实例化一个枚举实例的时候会遇到什么问题，我们看下<code>Constructor</code>类的<code>newInstance</code>方法：</p>

<p>```java
public T newInstance(Object &hellip; initargs)</p>

<pre><code>    throws InstantiationException, IllegalAccessException,
           IllegalArgumentException, InvocationTargetException
{
    if (!override) {
        if (!Reflection.quickCheckMemberAccess(clazz, modifiers)) {
            Class&lt;?&gt; caller = Reflection.getCallerClass();
            checkAccess(caller, clazz, null, modifiers);
        }
    }
    // 阻止了通过反射来实例化Enum实例
    if ((clazz.getModifiers() &amp; Modifier.ENUM) != 0)
        throw new IllegalArgumentException("Cannot reflectively create enum objects");
    ConstructorAccessor ca = constructorAccessor;   // read volatile
    if (ca == null) {
        ca = acquireConstructorAccessor();
    }
    @SuppressWarnings("unchecked")
    T inst = (T) ca.newInstance(initargs);
    return inst;
}
</code></pre>

<p>```</p>

<p>可以看到在方法内如果发现要反射类的Modifier中有<code>Enum</code>标志，会直接抛出异常表示无法通过反射的方式来创建<code>Enum</code>实例。</p>

<h3>reference</h3>

<ul>
<li><a href="https://www.benf.org/other/cfr/how-are-enums-implemented.html">How are Enums implemented?</a></li>
</ul>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[HashMap源码分析]]></title>
    <link href="http://Solarex.github.io/blog/2018/07/02/analysis-of-hashmap/"/>
    <updated>2018-07-02T19:31:00+08:00</updated>
    <id>http://Solarex.github.io/blog/2018/07/02/analysis-of-hashmap</id>
    <content type="html"><![CDATA[<p><code>HashMap</code>是存储key-value的集合，底层采用<code>Node&lt;K,V&gt;[] table</code>实现，初始大小为2<sup>4</sup>即16。</p>

<!-- more -->


<p>```java
public V put(K key, V value) {</p>

<pre><code>    if (table == EMPTY_TABLE) {
        inflateTable(threshold);
    }
    if (key == null)
        return putForNullKey(value);
    int hash = hash(key);
    int i = indexFor(hash, table.length);
    for (Entry&lt;K,V&gt; e = table[i]; e != null; e = e.next) {
        Object k;
        if (e.hash == hash &amp;&amp; ((k = e.key) == key || key.equals(k))) {
            V oldValue = e.value;
            e.value = value;
            e.recordAccess(this);
            return oldValue;
        }
    }

    modCount++;
    addEntry(hash, key, value, i);
    return null;
}
</code></pre>

<p>```</p>

<p><code>put</code>操作首先根据<code>key</code>的hash值来找到要插入的<code>index</code>，如果存在相同<code>key</code>的元素则替换，否则插入。</p>

<p>```java
final int hash(Object k) {</p>

<pre><code>    int h = hashSeed;
    if (0 != h &amp;&amp; k instanceof String) {
        return sun.misc.Hashing.stringHash32((String) k);
    }

    h ^= k.hashCode();

    // This function ensures that hashCodes that differ only by
    // constant multiples at each bit position have a bounded
    // number of collisions (approximately 8 at default load factor).
    h ^= (h &gt;&gt;&gt; 20) ^ (h &gt;&gt;&gt; 12);
    return h ^ (h &gt;&gt;&gt; 7) ^ (h &gt;&gt;&gt; 4);
}
</code></pre>

<p>```</p>

<p><code>hash</code>方法采用的是<code>sun.misc.Hashing</code>中的方法。</p>

<p>```java
void addEntry(int hash, K key, V value, int bucketIndex) {</p>

<pre><code>    if ((size &gt;= threshold) &amp;&amp; (null != table[bucketIndex])) {
        resize(2 * table.length);
        hash = (null != key) ? hash(key) : 0;
        bucketIndex = indexFor(hash, table.length);
    }

    createEntry(hash, key, value, bucketIndex);
}
</code></pre>

<p>```</p>

<p>```java
void resize(int newCapacity) {</p>

<pre><code>    Entry[] oldTable = table;
    int oldCapacity = oldTable.length;
    if (oldCapacity == MAXIMUM_CAPACITY) {
        threshold = Integer.MAX_VALUE;
        return;
    }

    Entry[] newTable = new Entry[newCapacity];
    transfer(newTable, initHashSeedAsNeeded(newCapacity));
    table = newTable;
    threshold = (int)Math.min(newCapacity * loadFactor, MAXIMUM_CAPACITY + 1);
}
</code></pre>

<p>```</p>

<p>添加元素的时候会检查是否需要扩容，如果需要会将数组大小增大一倍，同时进行<code>rehash</code>来将之前的元素转移到现在的数组中来。</p>

<p>如果不需要扩容，直接添加元素</p>

<p>```java
void createEntry(int hash, K key, V value, int bucketIndex) {</p>

<pre><code>    Entry&lt;K,V&gt; e = table[bucketIndex];
    table[bucketIndex] = new Entry&lt;&gt;(hash, key, value, e);
    size++;
}
</code></pre>

<p>```</p>

<p>将<code>table</code>数组<code>index</code>位置元素指向插入元素，插入元素作为链表头。</p>

<p><code>get</code>操作和<code>put</code>操作差不多，根据<code>key</code>查找<code>Entry</code></p>

<p>```java
final Entry&lt;K,V> getEntry(Object key) {</p>

<pre><code>    if (size == 0) {
        return null;
    }

    int hash = (key == null) ? 0 : hash(key);
    for (Entry&lt;K,V&gt; e = table[indexFor(hash, table.length)];
         e != null;
         e = e.next) {
        Object k;
        if (e.hash == hash &amp;&amp;
            ((k = e.key) == key || (key != null &amp;&amp; key.equals(k))))
            return e;
    }
    return null;
}
</code></pre>

<p>```</p>

<p><code>table</code>数组的长度是2<sup>n</sup>，这样2<sup>n</sup>-1的二进制表示每一位都是1，方便进行index计算。</p>

<p>```java
static int indexFor(int h, int length) {</p>

<pre><code>    // assert Integer.bitCount(length) == 1 : "length must be a non-zero power of 2";
    return h &amp; (length-1);
}
</code></pre>

<p>```</p>

<p><code>LinkedHashMap</code>的<code>Entry</code>除了有一个<code>next</code>来处理冲突，还有<code>before</code>和<code>after</code>来将所有元素连接成一个双向循环链表。</p>

<p>```java
// LinkedHashMap
void createEntry(int hash, K key, V value, int bucketIndex) {</p>

<pre><code>    HashMap.Entry&lt;K,V&gt; old = table[bucketIndex];
    Entry&lt;K,V&gt; e = new Entry&lt;&gt;(hash, key, value, old);
    table[bucketIndex] = e;
    e.addBefore(header);
    size++;
}
</code></pre>

<p>```</p>

<p>```java
/**</p>

<pre><code>     * Inserts this entry before the specified existing entry in the list.
     */
    private void addBefore(Entry&lt;K,V&gt; existingEntry) {
        after  = existingEntry;
        before = existingEntry.before;
        before.after = this;
        after.before = this;
    }

    /**
     * This method is invoked by the superclass whenever the value
     * of a pre-existing entry is read by Map.get or modified by Map.set.
     * If the enclosing Map is access-ordered, it moves the entry
     * to the end of the list; otherwise, it does nothing.
     */
    void recordAccess(HashMap&lt;K,V&gt; m) {
        LinkedHashMap&lt;K,V&gt; lm = (LinkedHashMap&lt;K,V&gt;)m;
        if (lm.accessOrder) {
            lm.modCount++;
            remove();
            addBefore(lm.header);
        }
    }
</code></pre>

<p>```</p>

<p><code>Entry</code>的<code>addBefore</code>将元素添加至双向循环链表的尾部，<code>recordAccess</code>将元素从双向循环链表原来的位置移除，重新添加到链表尾部。如果key元素已经存在Map中，在<code>put</code>时会替换value，同时<code>recordAccess</code>，<code>recordAccess</code>在<code>HashMap</code>的<code>Entry</code>中是空实现，在<code>LinkedHashMap</code>中进行移除到链表尾部的操作。<code>recordAccess</code>还在<code>LinkedHashMap</code>的<code>get</code>方法中被调用，这样每次执行<code>get</code>操作返回元素的同时将<code>Entry</code>移动到链表尾部。</p>

<p><code>WeakHashMap</code>的<code>Entry</code>是<code>WeakReference</code>的子类，创建的时候和<code>ReferenceQueue</code>进行关联，referent是key，当key被回收时将移除key对应的entry。</p>

<p>```java
/**</p>

<pre><code> * Expunges stale entries from the table.
 */
private void expungeStaleEntries() {
    for (Object x; (x = queue.poll()) != null; ) {
        synchronized (queue) {
            @SuppressWarnings("unchecked")
                Entry&lt;K,V&gt; e = (Entry&lt;K,V&gt;) x;
            int i = indexFor(e.hash, table.length);

            Entry&lt;K,V&gt; prev = table[i];
            Entry&lt;K,V&gt; p = prev;
            while (p != null) {
                Entry&lt;K,V&gt; next = p.next;
                if (p == e) {
                    if (prev == e)
                        table[i] = next;
                    else
                        prev.next = next;
                    // Must not null out e.next;
                    // stale entries may be in use by a HashIterator
                    e.value = null; // Help GC
                    size--;
                    break;
                }
                prev = p;
                p = next;
            }
        }
    }
</code></pre>

<p>```</p>

<p>key被回收时<code>Entry</code>会被放入<code>ReferenceQueue</code>中。在调用<code>size()</code>和<code>resize()</code>方法时会调用<code>expungeStaleEntries</code>方法。</p>

<p>一般情况下，一个对象被标记为垃圾（并不代表被回收了）后会被加入引用队列。</p>

<p>对于虚引用来说，它指向的对象只有被回收后才会加入引用队列，所以可以作为记录该引用指向的对象是否被回收。</p>

<h2>reference</h2>

<ul>
<li><a href="https://android.googlesource.com/platform/libcore/+/8f9c9cae00ad906c39891890f7b9d7a0bc453c0a%5E2..8f9c9cae00ad906c39891890f7b9d7a0bc453c0a/">Android Hashing.java</a></li>
<li><a href="http://hg.openjdk.java.net/jdk7u/jdk7u6/jdk/file/8c2c5d63a17e/src/share/classes/sun/misc/Hashing.java">JDK Hashing.java</a></li>
<li><a href="http://learningviacode.blogspot.com/2014/02/reference-queues.html">Reference Queues</a></li>
</ul>

]]></content>
  </entry>
  
</feed>
