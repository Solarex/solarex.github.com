<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: dev | Solarex's Blog]]></title>
  <link href="http://Solarex.github.io/blog/categories/dev/atom.xml" rel="self"/>
  <link href="http://Solarex.github.io/"/>
  <updated>2017-10-18T22:21:39+08:00</updated>
  <id>http://Solarex.github.io/</id>
  <author>
    <name><![CDATA[Solarex]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[在Mac下进行JNI开发]]></title>
    <link href="http://Solarex.github.io/blog/2017/10/18/develop-jni-program-in-mac/"/>
    <updated>2017-10-18T21:56:00+08:00</updated>
    <id>http://Solarex.github.io/blog/2017/10/18/develop-jni-program-in-mac</id>
    <content type="html"><![CDATA[<p>本文主要讲述如何在Mac开发环境下进行JNI开发。</p>

<p>首先编写好Java文件，示例程序主要示范了Java访问C，C访问Java静态与非静态域。</p>

<p>```java
public class HelloJni{</p>

<pre><code>static{
    System.loadLibrary("HelloJni");
}
public native static String getStringFromCStatic();
public native String getStringFromCNonStatic();
public String key = "key";
public static int count = 5;
public native String accessField();
public native void accessStaticField();
public static void main(String[] args){
    System.out.println(getStringFromCStatic());
    HelloJni hello = new HelloJni();
    System.out.println(hello.getStringFromCNonStatic());
    System.out.println("change before key: " + hello.key);
    hello.accessField();
    System.out.println("change after key: " + hello.key);
    System.out.println("change before count: " + count);
    hello.accessStaticField();
    System.out.println("change after count: " + count);
}
</code></pre>

<p>}
```</p>

<!-- more -->


<p>在这个类的static代码块中加载的动态库是<code>HelloJni</code>，类库的名字前面需要加<code>lib</code>，在linux系统上面类库的扩展名为<code>so</code>，在Mac系统上面扩展名为<code>jnilib</code>，也就是说我们待会要生成的库的名字是<code>libHelloJni.jnilib</code>。</p>

<p>执行<code>javac HelloJni.java</code>生成class文件，执行<code>javah HelloJni</code>生成<code>HelloJni.h</code>头文件。其实生成的头文件都是有套路的，我们其实可以自己手动写。</p>

<p>```c
/<em> DO NOT EDIT THIS FILE &ndash; it is machine generated </em>/</p>

<h1>include &lt;jni.h></h1>

<p>/<em> Header for class HelloJni </em>/</p>

<h1>ifndef _Included_HelloJni</h1>

<h1>define _Included_HelloJni</h1>

<h1>ifdef __cplusplus</h1>

<p>extern &ldquo;C&rdquo; {</p>

<h1>endif</h1>

<p>/<em>
 * Class:     HelloJni
 * Method:    getStringFromCStatic
 * Signature: ()Ljava/lang/String;
 </em>/
JNIEXPORT jstring JNICALL Java_HelloJni_getStringFromCStatic
  (JNIEnv *, jclass);</p>

<p>/<em>
 * Class:     HelloJni
 * Method:    getStringFromCNonStatic
 * Signature: ()Ljava/lang/String;
 </em>/
JNIEXPORT jstring JNICALL Java_HelloJni_getStringFromCNonStatic
  (JNIEnv *, jobject);</p>

<p>/<em>
 * Class:     HelloJni
 * Method:    accessField
 * Signature: ()Ljava/lang/String;
 </em>/
JNIEXPORT jstring JNICALL Java_HelloJni_accessField
  (JNIEnv *, jobject);</p>

<p>/<em>
 * Class:     HelloJni
 * Method:    accessStaticField
 * Signature: ()V
 </em>/
JNIEXPORT void JNICALL Java_HelloJni_accessStaticField
  (JNIEnv *, jobject);</p>

<h1>ifdef __cplusplus</h1>

<p>}</p>

<h1>endif</h1>

<h1>endif</h1>

<p>```</p>

<p>接下来进行c文件的编写，示例程序演示了C访问java静态与非静态域。</p>

<p>```c</p>

<h1>include &ldquo;HelloJni.h&rdquo;</h1>

<h1>include &lt;stdio.h></h1>

<h1>include &lt;string.h></h1>

<p>JNIEXPORT jstring JNICALL Java_HelloJni_getStringFromCStatic(JNIEnv * env, jclass clz){</p>

<pre><code>return (*env)-&gt;NewStringUTF(env, "C String static");
</code></pre>

<p>}</p>

<p>JNIEXPORT jstring JNICALL Java_HelloJni_getStringFromCNonStatic(JNIEnv * env, jobject obj){</p>

<pre><code>return (*env)-&gt;NewStringUTF(env, "C string non static");
</code></pre>

<p>}</p>

<p>JNIEXPORT jstring JNICALL Java_HelloJni_accessField(JNIEnv * env, jobject obj){</p>

<pre><code>jclass jclz = (*env)-&gt;GetObjectClass(env, obj);
jfieldID fid = (*env)-&gt;GetFieldID(env, jclz, "key", "Ljava/lang/String;");
jstring jstr = (*env)-&gt;GetObjectField(env, obj, fid);
char* c_str = (*env)-&gt;GetStringUTFChars(env, jstr, NULL);
char text[30] = "solarex";
strcat(text, c_str);
jstring new_str = (*env)-&gt;NewStringUTF(env, text);
(*env)-&gt;SetObjectField(env, obj, fid, new_str);
(*env)-&gt;ReleaseStringChars(env, new_str, c_str);
return new_str;
</code></pre>

<p>}</p>

<p>JNIEXPORT void JNICALL Java_HelloJni_accessStaticField(JNIEnv * env, jobject obj){</p>

<pre><code>jclass jclz = (*env)-&gt;GetObjectClass(env, obj);
jfieldID fid = (*env)-&gt;GetStaticFieldID(env, jclz, "count", "I");
jint count = (*env)-&gt;GetStaticIntField(env, jclz, fid);
count++;
(*env)-&gt;SetStaticIntField(env, jclz, fid, count);
</code></pre>

<p>}
```</p>

<p>接下来就是编译c文件了，在<code>HelloJni.h</code>中有<code>#include &lt;jni.h&gt;</code>，编译的时候我们需要指出<code>jni.h</code>的路径。在Mac系统中<code>jni.h</code>在<code>/System/Library/Frameworks/JavaVM.framework/Headers</code>目录下。</p>

<p><code>
gcc -I/System/Library/Frameworks/JavaVM.framework/Headers -c HelloJni.c //生成.o文件
gcc -dynamiclib -o libHelloJni.jnilib HelloJni.o
</code></p>

<p>上面两条命令就生成了动态库。</p>

<p>然后我们再执行<code>java HelloJni</code>就可以看到java和c交互的输出了：</p>

<p><code>
C String static
C string non static
change before key: key
change after key: solarexkey
change before count: 5
change after count: 6
</code></p>

<p>Demo参见<a href="https://github.com/flyfire/HelloJni">HelloJni</a>。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Writing Better Adapters]]></title>
    <link href="http://Solarex.github.io/blog/2016/12/26/writing-better-adapters/"/>
    <updated>2016-12-26T16:11:00+08:00</updated>
    <id>http://Solarex.github.io/blog/2016/12/26/writing-better-adapters</id>
    <content type="html"><![CDATA[<p>Implementing adapters is one of the most frequent tasks for an Android developer. It’s the base for every list. Looking at apps, lists are the base of most apps.</p>

<p>The schema we follow to implement list views is often the same: a View with an adapter that holds the data. Doing this all the time can make us blind to what we are writing, even to ugly code. Even worse, we end up repeating that ugly code.</p>

<p>It’s time to take a close look into adapters.</p>

<h2>RecyclerView Basics</h2>

<p>The basic operations for RecyclerViews (but also applicable for ListView) are:</p>

<ul>
<li>Creating the view and the ViewHolder that holds the view information.</li>
<li>Binding the ViewHolder to the data that the adapter holds, probably a list of model classes.</li>
</ul>


<p>Implementing this is pretty straightforward and not much can be done wrong here.</p>

<!-- more -->


<h2>RecyclerView With Different Types</h2>

<p>It gets trickier when you need to have different kind of items in your views. It might be different kind of cards in case you use CardViews or could be ads stitched in between your elements. You might even have a list of completely different kind of objects (this article uses Kotlin but it can be easily applied to Java as no language specific feature are used)</p>

<p><code>
interface Animal
class Mouse: Animal
class Duck: Animal
class Dog: Animal
class Car
</code></p>

<p>You have various animals and then suddenly something like a car that is totally unrelated.</p>

<p>In those use cases you have probably different view types you need to show. Means you need to create different ViewHolders and probably inflate different layouts in each. The API defines type identifier as integers, that’s where the ugliness starts!</p>

<p>But let’s look at some code. When you have more than one item type you announce this by overriding:</p>

<p><code>
override fun getItemViewType(position: Int) : Int
</code></p>

<p>as the default implementation always returns zero. The implementer needs to translate the types into Integer values.</p>

<p>Next step: create the ViewHolders. So you have to implement:</p>

<p><code>
override fun onCreateViewHolder(parent: ViewGroup, viewType: Int): RecyclerView.ViewHolder
</code></p>

<p>In this method the API tells the Integer type you passed earlier as parameter.
The implementation is pretty trivial: a switch statement, or something similar, can be used to create ViewHolders for every given type.</p>

<p>The difference comes when binding the newly created (or recycled) ViewHolder:</p>

<p><code>
override fun onBindViewHolder(holder: ViewHolder, position: Int): Any
</code></p>

<p>Notice that here there is no type parameter. You could use getItemViewType if needed but normally it’s not needed. You could have some bind() method in a base class of all our different ViewHolders that you can call.</p>

<h2>The Uglyness</h2>

<p>So what is the problem now? Looks straightforward to implement, isn’t it?</p>

<p>Let’s look once again into getItemViewType().</p>

<p>The system needs the type for every position. So you have to translate an item in your backing model list to a view type.</p>

<p>You might want to write something like:</p>

<p>```
if (things.get(position) is Duck) {</p>

<pre><code>return TYPE_DUCK
</code></pre>

<p>} else if (things.get(position) is Mouse) {</p>

<pre><code>return TYPE_MOUSE
</code></pre>

<p>}
```</p>

<p>Can we agree on how ugly this is?</p>

<p>It might get even worse if your ViewHolders don’t share a common base class. If they are totally different types, in your lists you have the same ugly code when binding the ViewHolder:</p>

<p>```
override fun onBindViewHolder(holder: RecyclerView.ViewHolder, position: Int) {</p>

<pre><code>val thing = things.get(position)
if (thing is Animal) {
    (holder as AnimalViewHolder).bind(thing as Animal)
} else if (thing is Car) {
    (holder as CarViewHolder).bind(thing as Car)
}
</code></pre>

<p>&hellip;
}
```</p>

<p>This is a mess. instance-of checks and dozens of casting. Both are code smells and should be even considered anti-patterns.</p>

<p>Many years ago I had a couple of quotes attached to my monitor. One of them was from Effective C++ by Scott Meyers (one of the best IT books ever written) and goes like this:</p>

<p><code>
Anytime you find yourself writing code of the form “if the object is of type T1, then do something, but if it’s of type T2, then do something else,” slap yourself.
</code></p>

<p>If you look at those adapter implementation, there is a lot of slapping to be done.</p>

<ul>
<li>We have type checks and we have lots of ugly casts!</li>
<li>This is simply not object orientated code! OO just celebrated its 50th birthday so we should try to use more of its strengths.</li>
<li>In addition, the way we implemented those adapters is a violation of the “Open-Closed” rule from the SOLID principles. It says: “open for extension but closed for modifications”.</li>
</ul>


<p>But when we would add another type to our classes, another Model, let’s say Rabbit and therefore RabbitViewHolder, we have to change lots of methods in the adapter. A clear violation of the principle. A new kind of object should not lead to modifications in existing methods.</p>

<p>So let’s try to solve this.</p>

<h2>Let’s Fix It</h2>

<p>One alternative would be to put something in the middle to do the translation for us. It could be as simple as putting your Class types in some Map and retrieve the type with one call. It would be something like:</p>

<p><code>
override fun getItemViewType(position: Int) : Int
   = types.get(things.javaClass)
</code></p>

<p>It’s much better now isn’t it?
The sad answer is: not really! In the end this just hides instance-of.</p>

<p>How would you implement the onBindViewholder() we’ve seen above? It would be something like: if object is of type T1 then do.. else… so still slapping to be done here.</p>

<p>The goal should be to be able to <strong>add new view types without even touching the adapter</strong>.</p>

<p>Therefore: don’t create your own type mapping in the adapter between the models and the views in the first place. Google suggests using layout ids. With this trick you don’t need the artificial type mappings by simply using the layout id you’re inflating. And of course you probably save another enum as #perfmatters.</p>

<p>But still you need to map those to each other? How?</p>

<p>In the end end you need to map models to views. Could this knowledge move to the model?</p>

<p>It would be tempting to put the type into your model, something like.</p>

<p><code>
fun getType() : Int = R.layout.item_duck
</code></p>

<p>This way the adapter implementation for type could be totally generic:</p>

<p><code>
override fun getItemViewType(pos: Int) = things[pos].getType()
</code></p>

<p>Open-Closed principle is applied, no changes needed when adding new models.</p>

<p>But now you totally mixed our layers and indeed broke the complete architecture. Entities know about presentation, arrows pointing into the wrong direction. This must be unacceptable for us.</p>

<p>And again: adding a method into an object to asks for it’s type is not object orientated. You again would just hide the instance-of check.</p>

<h2>The ViewModel</h2>

<p>One way to approach this, is to have separat ViewModels instead of using our Model directly. In the end our problem was that our models are disjoint, they don’t share a common base: a car is not an animal. And this is correct. Only for the presentation layer you need to show them in on list. So when you introduce models for this layer you don’t have this problem, they can have a common base.</p>

<p>```
abstract class ViewModel {</p>

<pre><code>abstract fun type(): Int
</code></pre>

<p>}
class DuckViewModel(val duck: Duck): ViewModel() {</p>

<pre><code>override fun type() = R.layout.duck
</code></pre>

<p>}
class CarViewModel(val car: Car): ViewModel() {</p>

<pre><code>override fun type() = R.layout.car
</code></pre>

<p>}
```</p>

<p>So you simply wrapped the models. You don’t need to modify them at all and keep view specific code in those new ViewModels.</p>

<p>This way you can also add all formatting logic into there and use Android’s new Data Binding Library.</p>

<p>The idea of using list of ViewModels in the adapter instead of the Models helps especially when you need artificial items like dividers, section headers or simply advertisement items.</p>

<p>This is one approach to solve the problem. But not the only one.</p>

<h2>The Visitor</h2>

<p>Let’s go back to our initial idea of only using the Model. If you would have lots of model classes, maybe you don’t want to create lots of ViewModel one each.</p>

<p>Thinking of the type() method that you added in the first place into the model, you missed some decoupling. You need to avoid having the presentation code in there directly. You need to indirect it, move the actual type knowledge to somewhere else. How about adding an interface into this type() method:</p>

<p>```
interface Visitable {</p>

<pre><code>fun type(typeFactory: TypeFactory) : Int
</code></pre>

<p>}
```</p>

<p>Now you might ask what have you won here as the factory would still need to branch between types like the adapter did in the first place, right?</p>

<p>No it does not! This approach will be based on the Visitor pattern, one of the classic Gang-of-Four pattern. All the model will do, is forwarding this type call:</p>

<p>```
interface Animal : Visitable
interface Car : Visitable
class Mouse: Animal {</p>

<pre><code>override fun type(typeFactory: TypeFactory) 
    = typeFactory.type(this)
</code></pre>

<p>}
```</p>

<p>The factory has variations you need:</p>

<p>```
interface TypeFactory {</p>

<pre><code>fun type(duck: Duck): Int
fun type(mouse: Mouse): Int
fun type(dog: Dog): Int
fun type(car: Car): Int
</code></pre>

<p>}
```</p>

<p>This way it’s totally type safe, no instance-of, no casts needed at all.</p>

<p>And the responsibility of the factory is clear: it knows about the view types:</p>

<p>```
class TypeFactoryForList : TypeFactory {</p>

<pre><code>override fun type(duck: Duck) = R.layout.duck
override fun type(mouse: Mouse) = R.layout.mouse
override fun type(dog: Dog) = R.layout.dog
override fun type(car: Car) = R.layout.car
</code></pre>

<p>```</p>

<p>I could even also create ViewHolders to keep the knowledge about the ids in one place. So when adding a new view, this is the place to add. This should be pretty SOLID. You might need another method for new types but not modify any existing method: Open for Extension, Closed for Modification.</p>

<p>Now you might ask: why not use the factory directly from adapter instead using the indirection of the model?</p>

<p>Only with this path you get the type safety without need of casts and type checks. Take a moment to realize this here, there is not a single cast needed!This indirection is the magic behind Visitor Pattern.</p>

<p>Following this approach leaves the adapter with a very generic implementation that hardly ever needs to be changed.</p>

<h2>Conclusion</h2>

<ul>
<li>Try to keep your presentation code clean.</li>
<li>Instance-of checks should be a red flag!</li>
<li>Look out for down casting as it’s a code smell.</li>
<li>Try to replace those two with correct OO usage. Think about interfaces and inheritance.</li>
<li>Try to use generics to prevent castings.</li>
<li>Use ViewModels.</li>
<li>Check out for usages for the Visitor pattern.</li>
</ul>


<p>I would be happy to learn other ideas to make our Adapters cleaner.</p>

<p>PS: thanks to Jan M and Dmitri Kudrenko who crated examples on Github for Java and Kotlin:
<a href="https://github.com/dmitrikudrenko/BetterAdapters">https://github.com/dmitrikudrenko/BetterAdapters</a>
<a href="https://github.com/meierjan/BetterAdapters">https://github.com/meierjan/BetterAdapters</a></p>

<h2>reference</h2>

<ul>
<li><a href="https://medium.com/@dpreussler/writing-better-adapters-1b09758407d2#.vc2pos5tm">Writing Better Adapters</a></li>
<li><a href="https://juejin.im/entry/57fda1fe5bbb50005b3fef76?utm_source=gold-miner&amp;utm_medium=readme&amp;utm_campaign=github">关于 Android Adapter，你的实现方式可能一直都有问题</a></li>
<li><a href="http://github.com/flyfire/MultitypeBaseAdapter">MultitypeBaseAdapter</a></li>
</ul>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Choreographer in Android]]></title>
    <link href="http://Solarex.github.io/blog/2016/10/10/choreographer-in-android/"/>
    <updated>2016-10-10T20:38:00+08:00</updated>
    <id>http://Solarex.github.io/blog/2016/10/10/choreographer-in-android</id>
    <content type="html"><![CDATA[<p>Choreographer is the one which acts like a interface between application view system and lower layer display system for rendering the views.</p>

<p>ViewRootImpl is the ViewParent or root below which only Activity window DecorView will be attached. All the view layouts set by the activity through <code>setContentView()</code> will attached the DecorView whose parent is ViewRootImpl. Actually ViewRootImpl is not a View its just a ViewParent which handled and manages the View Hierarchies for displaying, handling input events etc.</p>

<p>The number of root views that are active in your process. Each root view is associated with a window, so this can help you identify memory leaks involving dialogs or other windows.</p>

<!-- more -->


<p>ViewRootImpl will get the requests for refresh or view update from its child and interact with Choreographer for drawing the view hierarchy to the display system.</p>

<p>Choreographer instance will be created for each thread wise. Each application thread will have separate instance of Choreographer. When this instance is created then it itself register to for VSYNC event to the lower layer and now it ready to handle the ViewRootImpl/Application refresh request and interaction with the lower layer.</p>

<p>When ever ViewRootImpl got request from View hierarchy to refresh or update or invalidate then it request Choreographer for refresh by registering a callback. When Choreographer got any request then it request for next VSYNC event from the lower layer and when it got he VSYNC event then it asks ViewRootImpl by calling the registered Callback to handle the drawing accordingly. Also when ever ViewRootImpl wants to redraw the view then this thing will repeat.</p>

<p>When Choreographer receives VSYNC event then it handled the below event handling in order to handle the drawing or display.</p>

<ul>
<li><p>Input  handling : All received input event received and maintained in the query and all these input event will be processed now only.</p></li>
<li><p>Animation : Handle all the registered animations from ViewRootImpl or from Application or Activity.</p></li>
<li><p>View Traversal (Drawing/Rendering of Views) : Handles the View drawing if ViewRootImpl has registered for refresh.</p></li>
</ul>


<p>Choreographer is the main component which registers application main thread to display system and coordinate between the application view drawing component to the display system for synchronizing VSYNC with the application event, animation and draw handling.</p>

<h2>reference</h2>

<ul>
<li><a href="https://nayaneshguptetechstuff.wordpress.com/2014/07/01/what-is-choreographeri-in-android/">WHAT IS CHOREOGRAPHER IN ANDROID?</a></li>
</ul>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[VSYNC in Android]]></title>
    <link href="http://Solarex.github.io/blog/2016/10/09/vsync-in-android/"/>
    <updated>2016-10-09T20:43:00+08:00</updated>
    <id>http://Solarex.github.io/blog/2016/10/09/vsync-in-android</id>
    <content type="html"><![CDATA[<h2>In Android What is VSYNC and its usage?</h2>

<p>VSYNC is the event posted periodically by the kernal at fixed interval where the input handling, Animation and Window drawing happening synchroniiously at the same VSYNC interval. Below have given the detail explanation about the VSYNC event before VSYNC is introduced and after VSYNC is introduced.</p>

<!-- more -->


<h3>Before VSYNC is introduced:</h3>

<p>Before VSYNC is introduced then there was no synchronization happening for Input, animation and draw. As when there is an input it will be handled, also as when there is an animation or change in view then it will be drawn which results in too many CPU operations and some complex animations where some time operations or drawing happens exceeds human identifcatrion of view change. Suppose human eye can see clearly and differentiate 60FPS / seconds. In this case it might happen more then 60FPS some time.</p>

<p>As there is no sync happens between these 3 handling so input handling might redraw the view, animation also might redraw the view and some changes in view is also redraw. So too many redraw will happen.</p>

<h3>After VSYNC is introduced:</h3>

<p>Not this VSYNC is been delivered at an interval of 16.67 MS which is around 60 FPS/second. In this VSYNC event only handling of input will be happend, if input arrived before that then it will be queued and handled at VSYNC event only. After handling this VSYNC event, will handle the animation and followed by draw. Now all these 3 handling is synchronized and handling will be initiated on VSYNC event. VSYNC event make sure handling and drawing of the window happen at fixed interval and thus by avoid unnecessary drawing and handling.</p>

<p>Lets check below Google butter document for VSYNC handling.<a href="https://docs.google.com/viewer?url=http%3A%2F%2Fcommondatastorage.googleapis.com%2Fio2012%2Fpresentations%2Flive%2520to%2520website%2F109.pdf">For Butter or Worse : Smoothing out performance in Android UIs</a></p>

<h2>reference</h2>

<ul>
<li><a href="https://nayaneshguptetechstuff.wordpress.com/2014/07/01/what-is-vsyc-in-android/">WHAT IS VSYNC IN ANDROID?</a></li>
</ul>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Aspect Oriented Programming in Android]]></title>
    <link href="http://Solarex.github.io/blog/2016/09/20/aspect-oriented-programming-in-android/"/>
    <updated>2016-09-20T18:24:00+08:00</updated>
    <id>http://Solarex.github.io/blog/2016/09/20/aspect-oriented-programming-in-android</id>
    <content type="html"><![CDATA[<p>Aspect-oriented programming entails breaking down program logic into &ldquo;concerns&rdquo; (cohesive areas of functionality). This means, that with AOP, we can add executable blocks to some source code without explicitly changing it. This programming paradigm pretends that “cross-cutting concerns” (the logic needed at many places, without a single class where to implement them) should be implemented once and injected it many times into those places.</p>

<p>Code injection becomes a very important part of AOP: it is useful for dealing with the mentioned &ldquo;concerns&rdquo; that cut across the whole application, such as logging or performance monitoring, and, using it in this way, should not be something used rarely as you might think, quite the contrary; every programmer will come into a situation where this ability of injecting code, could prevent a lot of pain and frustration.</p>

<p>AOP is a paradigm that has been with us for many years, and I found it very useful to apply it to Android. After some investigation I consider that we can get a lot of advantages and very useful stuff when making use of it.</p>

<!-- more -->


<h2>Terminology (Mini glossary)</h2>

<p>Before we get started, let&rsquo;s have a look at some vocabulary that we should keep in mind:</p>

<ul>
<li><p>Cross-cutting concerns:Even though most classes in an OO model will perform a single, specific function, they often share common, secondary requirements with other classes. For example, we may want to add logging to classes within the data-access layer and also to classes in the UI layer whenever a thread enters or exits a method. Even though each class has a very different primary functionality, the code needed to perform the secondary functionality is often identical.</p></li>
<li><p>Advice: The code that is injected to a class file. Typically we talk about before, after, and around advices, which are executed before, after, or instead of a target method. It’s possible to make also other changes than injecting code into methods, e.g. adding fields or interfaces to a class.</p></li>
<li><p>Joint point: A particular point in a program that might be the target of code injection, e.g. a method call or method entry.</p></li>
<li><p>Pointcut: An expression which tells a code injection tool where to inject a particular piece of code, i.e. to which joint points to apply a particular advice. It could select only a single such point – e.g. execution of a single method – or many similar points – e.g. executions of all methods marked with a custom annotation such as @DebugTrace.</p></li>
<li><p>Aspect: The combination of the pointcut and the advice is termed an aspect. For instance, we add a logging aspect to our application by defining a pointcut and giving the correct advice.</p></li>
<li><p>Weaving: The process of injecting code – advices – into the target places – joint points.</p></li>
</ul>


<p>This picture summarizes a bit a few of these concepts:</p>

<center><img src="http://Solarex.github.io/images/aop.png"/></center>


<h2>So…where and when can we apply AOP?</h2>

<p>Some examples of cross-cutting concerns are:</p>

<ul>
<li>Logging</li>
<li>Persistance</li>
<li>Performance monitoring</li>
<li>Data Validation</li>
<li>Caching</li>
<li>Many others</li>
</ul>


<p>And in relation with &ldquo;when the magic happens&rdquo;, the code can be injected at different points in time:</p>

<ul>
<li><p>At run-time: your code has to explicitly ask for the enhanced code, e.g. by using a Dynamic Proxy (this is arguably not true code injection). Anyway here is an example I created for testing it.</p></li>
<li><p>At load-time: the modification are performed when the target classes are being loaded by Dalvik or ART. Byte-code or Dex-code weaving.</p></li>
<li><p>At build-time: you add an extra step to your build process to modify the compiled classes before packaging and deploying your application. Source-code weaving.</p></li>
</ul>


<p>Depending on the situation you will be choosing one or the other :).</p>

<h2>Tools and Libraries</h2>

<p>There are a few tools and libraries out there that help us use AOP:</p>

<ul>
<li><p><a href="https://eclipse.org/aspectj/">AspectJ</a>: A seamless aspect-oriented extension to the Javatm programming language (works with Android).</p></li>
<li><p><a href="https://github.com/crimsonwoods/javassist-android">Javassist for Android</a>: An android porting of the very well known java library Javassist for bytecode manipulation.</p></li>
<li><p><a href="https://code.google.com/p/dexmaker/">DexMaker</a>: A Java-language API for doing compile time or runtime code generation targeting the Dalvik VM.</p></li>
<li><p><a href="http://asm.ow2.org/asmdex-index.html">ASMDEX</a>: A bytecode manipulation library as ASM but it handles the DEX bytecode used by Android executables.</p></li>
</ul>


<h2>Why AspectJ?</h2>

<p>For our example below I have chosen AspectJ for the following reasons:</p>

<ul>
<li>Very powerful.</li>
<li>Supports build time and load time code injection.</li>
<li>Easy to use.</li>
</ul>


<h2>Example</h2>

<p>Let&rsquo;s say we want to measure the performance of a method (how long takes its execution). For doing this we want to mark our method with a <code>@DebugTrace</code> annotation and want to see the results using the logcat transparently without having to write code in each annotated method. Our approach is to use AspectJ for this purpose.</p>

<p>This is what is gonna happen under the hood:</p>

<ul>
<li>The annotation will be processed in a new step we are adding to our compilation fase.</li>
<li>Necessary boilerplate code will be generated and injected in the annotated method.</li>
</ul>


<p>I have to say here that while I was researching I found <a href="https://github.com/JakeWharton/hugo">Jake Wharton&rsquo;s Hugo Library</a> that it is suppose to do the same, so I refactored my code and looks similar to it, although mine is a more primitive and simpler version (I have learnt a lot by looking at its code by the way).</p>

<center><img src="http://Solarex.github.io/images/aspectweaving.png"/></center>


<h2>Project structure</h2>

<p>We will break up our sample application into 2 modules, the first will contain our android app and the second will be an android library that will make use of AspectJ library for weaving (code injection).</p>

<p>You may be wondering why we are using an android library module instead of a pure java library: <strong>the reason is that for AspectJ to work on Android we have to make use of some hooks when compiling our app and this is only possible using the android-library gradle plugin.</strong> (Do not worry about this yet, cause I will be giving some more details later).</p>

<h2>Creating our annotation</h2>

<p>We first create our Java annotation. This annotation will be persisted in the class (<code>RetentionPolicy.CLASS</code>) file and we will be able to annotate any constructor or method with it (<code>ElementType.CONSTRUCTOR</code> and <code>ElementType.METHOD</code>). So our <code>DebugTrace.java</code> file will look like this:</p>

<p><code>
@Retention(RetentionPolicy.CLASS)
@Target({ ElementType.CONSTRUCTOR, ElementType.METHOD })
public @interface DebugTrace {}
</code></p>

<h2>Our StopWatch for performance monitoring</h2>

<p>I have created a simple class that encapsulates time start/stop. Here is our <code>StopWatch.java</code> class:</p>

<p>```
/<em>*
 * Class representing a StopWatch for measuring time.
 </em>/
public class StopWatch {
  private long startTime;
  private long endTime;
  private long elapsedTime;</p>

<p>  public StopWatch() {</p>

<pre><code>//empty
</code></pre>

<p>  }</p>

<p>  private void reset() {</p>

<pre><code>startTime = 0;
endTime = 0;
elapsedTime = 0;
</code></pre>

<p>  }</p>

<p>  public void start() {</p>

<pre><code>reset();
startTime = System.nanoTime();
</code></pre>

<p>  }</p>

<p>  public void stop() {</p>

<pre><code>if (startTime != 0) {
  endTime = System.nanoTime();
  elapsedTime = endTime - startTime;
} else {
  reset();
}
</code></pre>

<p>  }</p>

<p>  public long getTotalTimeMillis() {</p>

<pre><code>return (elapsedTime != 0) ? TimeUnit.NANOSECONDS.toMillis(endTime - startTime) : 0;
</code></pre>

<p>  }
}
```</p>

<h2>DebugLog Class</h2>

<p>I just decorated the &ldquo;android.util.Log&rdquo; cause my first idea was to add some more functionality to the android log. Here it is:</p>

<p>```
/<em>*
 * Wrapper around {@link android.util.Log}
 </em>/
public class DebugLog {</p>

<p>  private DebugLog() {}</p>

<p>  /<em>*
   * Send a debug log message
   *
   * @param tag Source of a log message.
   * @param message The message you would like logged.
   </em>/
  public static void log(String tag, String message) {</p>

<pre><code>Log.d(tag, message);
</code></pre>

<p>  }
}
```</p>

<h2>Our Aspect</h2>

<p>Now it is time to create our aspect class (<code>TraceAspect.java</code>) that will be in charge of managing the annotation processing and source-code weaving.</p>

<p>```
/<em>*
 * Aspect representing the cross cutting-concern: Method and Constructor Tracing.
 </em>/
@Aspect
public class TraceAspect {</p>

<p>  private static final String POINTCUT_METHOD =</p>

<pre><code>  "execution(@org.android10.gintonic.annotation.DebugTrace * *(..))";
</code></pre>

<p>  private static final String POINTCUT_CONSTRUCTOR =</p>

<pre><code>  "execution(@org.android10.gintonic.annotation.DebugTrace *.new(..))";
</code></pre>

<p>  @Pointcut(POINTCUT_METHOD)
  public void methodAnnotatedWithDebugTrace() {}</p>

<p>  @Pointcut(POINTCUT_CONSTRUCTOR)
  public void constructorAnnotatedDebugTrace() {}</p>

<p>  @Around(&ldquo;methodAnnotatedWithDebugTrace() || constructorAnnotatedDebugTrace()&rdquo;)
  public Object weaveJoinPoint(ProceedingJoinPoint joinPoint) throws Throwable {</p>

<pre><code>MethodSignature methodSignature = (MethodSignature) joinPoint.getSignature();
String className = methodSignature.getDeclaringType().getSimpleName();
String methodName = methodSignature.getName();

final StopWatch stopWatch = new StopWatch();
stopWatch.start();
Object result = joinPoint.proceed();
stopWatch.stop();

DebugLog.log(className, buildLogMessage(methodName, stopWatch.getTotalTimeMillis()));

return result;
</code></pre>

<p>  }</p>

<p>  /<em>*
   * Create a log message.
   *
   * @param methodName A string with the method name.
   * @param methodDuration Duration of the method in milliseconds.
   * @return A string representing message.
   </em>/
  private static String buildLogMessage(String methodName, long methodDuration) {</p>

<pre><code>StringBuilder message = new StringBuilder();
message.append("Gintonic --&gt; ");
message.append(methodName);
message.append(" --&gt; ");
message.append("[");
message.append(methodDuration);
message.append("ms");
message.append("]");

return message.toString();
</code></pre>

<p>  }
}
```</p>

<p>Some important points to mention here:</p>

<ul>
<li><p>We declare 2 public methods with 2 pointcuts that will filter all methods and constructors annotated with &ldquo;org.android10.gintonic.annotation.DebugTrace&rdquo;.</p></li>
<li><p>We define the &ldquo;weaveJointPoint(ProceedingJoinPoint joinPoint)&rdquo; annotated with &ldquo;@Around&rdquo; which means that our code injection will happen around the annotated method with &ldquo;@DebugTrace&rdquo;.</p></li>
<li><p>The line &ldquo;Object result = joinPoint.proceed();&rdquo; is where the annotated method execution happens, so before this, is where we start our StopWatch to start measuring time, and after that, we stop it.</p></li>
<li><p>Finally we build our message and print it using the Android Log.</p></li>
</ul>


<h2>Making AspectJ to work with Android</h2>

<p>Now everything should be working, but, if we compile our sample, we will see that nothing happens.</p>

<p>The reason is that we have to use the AspectJ compiler (ajc, an extension of the java compiler) to weave all classes that are affected by an aspect. That&rsquo;s why, as I mention before, we need to add some extra configuration to our gradle build task to make it work.</p>

<p>This is how our <code>build.gradle</code> looks like:</p>

<p>```
import com.android.build.gradle.LibraryPlugin
import org.aspectj.bridge.IMessage
import org.aspectj.bridge.MessageHandler
import org.aspectj.tools.ajc.Main</p>

<p>buildscript {
  repositories {</p>

<pre><code>mavenCentral()
</code></pre>

<p>  }
  dependencies {</p>

<pre><code>classpath 'com.android.tools.build:gradle:0.12.+'
classpath 'org.aspectj:aspectjtools:1.8.1'
</code></pre>

<p>  }
}</p>

<p>apply plugin: &lsquo;android-library&rsquo;</p>

<p>repositories {
  mavenCentral()
}</p>

<p>dependencies {
  compile &lsquo;org.aspectj:aspectjrt:1.8.1&rsquo;
}</p>

<p>android {
  compileSdkVersion 19
  buildToolsVersion &lsquo;19.1.0&rsquo;</p>

<p>  lintOptions {</p>

<pre><code>abortOnError false
</code></pre>

<p>  }
}</p>

<p>android.libraryVariants.all { variant &ndash;>
  LibraryPlugin plugin = project.plugins.getPlugin(LibraryPlugin)
  JavaCompile javaCompile = variant.javaCompile
  javaCompile.doLast {</p>

<pre><code>String[] args = ["-showWeaveInfo",
                 "-1.5",
                 "-inpath", javaCompile.destinationDir.toString(),
                 "-aspectpath", javaCompile.classpath.asPath,
                 "-d", javaCompile.destinationDir.toString(),
                 "-classpath", javaCompile.classpath.asPath,
                 "-bootclasspath", plugin.project.android.bootClasspath.join(
    File.pathSeparator)]

MessageHandler handler = new MessageHandler(true);
new Main().run(args, handler)

def log = project.logger
for (IMessage message : handler.getMessages(null, true)) {
  switch (message.getKind()) {
    case IMessage.ABORT:
    case IMessage.ERROR:
    case IMessage.FAIL:
      log.error message.message, message.thrown
      break;
    case IMessage.WARNING:
    case IMessage.INFO:
      log.info message.message, message.thrown
      break;
    case IMessage.DEBUG:
      log.debug message.message, message.thrown
      break;
  }
}
</code></pre>

<p>  }
}
```</p>

<h2>Our test method</h2>

<p>Let&rsquo;s use our cool aspect annotation by adding it to a test method. I have created a method inside the main activity for testing purpose. Let&rsquo;s have a look at it:</p>

<p>```
@DebugTrace
  private void testAnnotatedMethod() {</p>

<pre><code>try {
  Thread.sleep(10);
} catch (InterruptedException e) {
  e.printStackTrace();
}
</code></pre>

<p>  }
```</p>

<h2>Executing our application</h2>

<p>We build and install our app on an android device/emulator by executing the gradle command:<code>gradlew clean build installDebug</code></p>

<p>If we open the logcat and execute our sample, we will see a debug log with:</p>

<p><code>Gintonic --&gt; testAnnotatedMethod --&gt; [10ms]</code></p>

<p>Our first android application using AOP worked!</p>

<p>You can use the <a href="https://play.google.com/store/apps/details?id=jp.itplus.android.dex.dump&amp;hl=en">Dex Dump</a> android application (from your phone), or any any other reverse engineering tool for decompiling the apk and see the source code generated and injected.</p>

<h2>Recap</h2>

<p>So to recap and summarize:</p>

<ul>
<li>We have had a taste of Aspect Oriented programming paradigm.</li>
<li>Code Injection becomes a very important part of this approach (AOP).</li>
<li>AspectJ is a very powerful and easy to use tool for source code weaving in Android applications.</li>
<li>We have created a working example using AOP capabilities.</li>
</ul>


<h2>Conclusion</h2>

<p>Aspect Oriented Programming is very powerful. Using it the right way, you can avoid duplicating a lot of code when you have &ldquo;cross-cutting concerns&rdquo; in your Android apps, like performance monitoring, as we have seen in our example. I do encourage you to give it a try, you will find it very useful.</p>

<p>I hope you like the article, the purpose of it was to share what I&rsquo;ve learnt so far, so feel free to comment and give feedback, or even better, fork the code and play a bit with it.</p>

<p>I&rsquo;m sure we can add very interesting stuff to our AOP module in the sample app. Ideas are very welcome ;).</p>

<h2>Source Code</h2>

<p>You can check 2 examples here, the first one uses AspectJ and the second one uses a Dynamic Proxy approach:</p>

<ul>
<li><a href="https://github.com/android10/Android-AOPExample.">https://github.com/android10/Android-AOPExample.</a></li>
<li><a href="https://github.com/android10/DynamicProxy_Java_Sample">https://github.com/android10/DynamicProxy_Java_Sample</a></li>
</ul>


<h2>Resources</h2>

<ul>
<li><a href="http://en.wikipedia.org/wiki/Aspect-oriented_programming">Aspect-oriented programming</a>.</li>
<li><a href="http://en.wikipedia.org/wiki/Aspect-oriented_software_development">Aspect-oriented software development</a>.</li>
<li><a href="http://www.javacodegeeks.com/2011/09/practical-introduction-into-code.html">Practical Introduction into Code Injection with AspectJ, Javassist, and Java Proxy</a>.</li>
<li><a href="http://java.dzone.com/articles/implementing-build-time">Implementing Build-time Bytecode Instrumentation With Javassist</a>.</li>
<li><a href="http://www.eclipse.org/aspectj/doc/released/faq.php">Frequently Asked Questions about AspectJ</a>.</li>
<li><a href="http://blog.espenberntsen.net/2010/03/20/aspectj-cheat-sheet/">AspectJ Cheat Sheet</a>.</li>
</ul>


<h2>reference</h2>

<ul>
<li><a href="https://fernandocejas.com/2014/08/03/aspect-oriented-programming-in-android/">Aspect Oriented Programming in Android</a></li>
</ul>

]]></content>
  </entry>
  
</feed>
