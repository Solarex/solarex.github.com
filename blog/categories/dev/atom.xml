<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: dev | Solarex's Blog]]></title>
  <link href="http://Solarex.github.io/blog/categories/dev/atom.xml" rel="self"/>
  <link href="http://Solarex.github.io/"/>
  <updated>2017-04-13T18:22:12+08:00</updated>
  <id>http://Solarex.github.io/</id>
  <author>
    <name><![CDATA[Solarex]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[Writing Better Adapters]]></title>
    <link href="http://Solarex.github.io/blog/2016/12/26/writing-better-adapters/"/>
    <updated>2016-12-26T16:11:00+08:00</updated>
    <id>http://Solarex.github.io/blog/2016/12/26/writing-better-adapters</id>
    <content type="html"><![CDATA[<p>Implementing adapters is one of the most frequent tasks for an Android developer. It’s the base for every list. Looking at apps, lists are the base of most apps.</p>

<p>The schema we follow to implement list views is often the same: a View with an adapter that holds the data. Doing this all the time can make us blind to what we are writing, even to ugly code. Even worse, we end up repeating that ugly code.</p>

<p>It’s time to take a close look into adapters.</p>

<h2>RecyclerView Basics</h2>

<p>The basic operations for RecyclerViews (but also applicable for ListView) are:</p>

<ul>
<li>Creating the view and the ViewHolder that holds the view information.</li>
<li>Binding the ViewHolder to the data that the adapter holds, probably a list of model classes.</li>
</ul>


<p>Implementing this is pretty straightforward and not much can be done wrong here.</p>

<!-- more -->


<h2>RecyclerView With Different Types</h2>

<p>It gets trickier when you need to have different kind of items in your views. It might be different kind of cards in case you use CardViews or could be ads stitched in between your elements. You might even have a list of completely different kind of objects (this article uses Kotlin but it can be easily applied to Java as no language specific feature are used)</p>

<p><code>
interface Animal
class Mouse: Animal
class Duck: Animal
class Dog: Animal
class Car
</code></p>

<p>You have various animals and then suddenly something like a car that is totally unrelated.</p>

<p>In those use cases you have probably different view types you need to show. Means you need to create different ViewHolders and probably inflate different layouts in each. The API defines type identifier as integers, that’s where the ugliness starts!</p>

<p>But let’s look at some code. When you have more than one item type you announce this by overriding:</p>

<p><code>
override fun getItemViewType(position: Int) : Int
</code></p>

<p>as the default implementation always returns zero. The implementer needs to translate the types into Integer values.</p>

<p>Next step: create the ViewHolders. So you have to implement:</p>

<p><code>
override fun onCreateViewHolder(parent: ViewGroup, viewType: Int): RecyclerView.ViewHolder
</code></p>

<p>In this method the API tells the Integer type you passed earlier as parameter.
The implementation is pretty trivial: a switch statement, or something similar, can be used to create ViewHolders for every given type.</p>

<p>The difference comes when binding the newly created (or recycled) ViewHolder:</p>

<p><code>
override fun onBindViewHolder(holder: ViewHolder, position: Int): Any
</code></p>

<p>Notice that here there is no type parameter. You could use getItemViewType if needed but normally it’s not needed. You could have some bind() method in a base class of all our different ViewHolders that you can call.</p>

<h2>The Uglyness</h2>

<p>So what is the problem now? Looks straightforward to implement, isn’t it?</p>

<p>Let’s look once again into getItemViewType().</p>

<p>The system needs the type for every position. So you have to translate an item in your backing model list to a view type.</p>

<p>You might want to write something like:</p>

<p>```
if (things.get(position) is Duck) {</p>

<pre><code>return TYPE_DUCK
</code></pre>

<p>} else if (things.get(position) is Mouse) {</p>

<pre><code>return TYPE_MOUSE
</code></pre>

<p>}
```</p>

<p>Can we agree on how ugly this is?</p>

<p>It might get even worse if your ViewHolders don’t share a common base class. If they are totally different types, in your lists you have the same ugly code when binding the ViewHolder:</p>

<p>```
override fun onBindViewHolder(holder: RecyclerView.ViewHolder, position: Int) {</p>

<pre><code>val thing = things.get(position)
if (thing is Animal) {
    (holder as AnimalViewHolder).bind(thing as Animal)
} else if (thing is Car) {
    (holder as CarViewHolder).bind(thing as Car)
}
</code></pre>

<p>&hellip;
}
```</p>

<p>This is a mess. instance-of checks and dozens of casting. Both are code smells and should be even considered anti-patterns.</p>

<p>Many years ago I had a couple of quotes attached to my monitor. One of them was from Effective C++ by Scott Meyers (one of the best IT books ever written) and goes like this:</p>

<p><code>
Anytime you find yourself writing code of the form “if the object is of type T1, then do something, but if it’s of type T2, then do something else,” slap yourself.
</code></p>

<p>If you look at those adapter implementation, there is a lot of slapping to be done.</p>

<ul>
<li>We have type checks and we have lots of ugly casts!</li>
<li>This is simply not object orientated code! OO just celebrated its 50th birthday so we should try to use more of its strengths.</li>
<li>In addition, the way we implemented those adapters is a violation of the “Open-Closed” rule from the SOLID principles. It says: “open for extension but closed for modifications”.</li>
</ul>


<p>But when we would add another type to our classes, another Model, let’s say Rabbit and therefore RabbitViewHolder, we have to change lots of methods in the adapter. A clear violation of the principle. A new kind of object should not lead to modifications in existing methods.</p>

<p>So let’s try to solve this.</p>

<h2>Let’s Fix It</h2>

<p>One alternative would be to put something in the middle to do the translation for us. It could be as simple as putting your Class types in some Map and retrieve the type with one call. It would be something like:</p>

<p><code>
override fun getItemViewType(position: Int) : Int
   = types.get(things.javaClass)
</code></p>

<p>It’s much better now isn’t it?
The sad answer is: not really! In the end this just hides instance-of.</p>

<p>How would you implement the onBindViewholder() we’ve seen above? It would be something like: if object is of type T1 then do.. else… so still slapping to be done here.</p>

<p>The goal should be to be able to <strong>add new view types without even touching the adapter</strong>.</p>

<p>Therefore: don’t create your own type mapping in the adapter between the models and the views in the first place. Google suggests using layout ids. With this trick you don’t need the artificial type mappings by simply using the layout id you’re inflating. And of course you probably save another enum as #perfmatters.</p>

<p>But still you need to map those to each other? How?</p>

<p>In the end end you need to map models to views. Could this knowledge move to the model?</p>

<p>It would be tempting to put the type into your model, something like.</p>

<p><code>
fun getType() : Int = R.layout.item_duck
</code></p>

<p>This way the adapter implementation for type could be totally generic:</p>

<p><code>
override fun getItemViewType(pos: Int) = things[pos].getType()
</code></p>

<p>Open-Closed principle is applied, no changes needed when adding new models.</p>

<p>But now you totally mixed our layers and indeed broke the complete architecture. Entities know about presentation, arrows pointing into the wrong direction. This must be unacceptable for us.</p>

<p>And again: adding a method into an object to asks for it’s type is not object orientated. You again would just hide the instance-of check.</p>

<h2>The ViewModel</h2>

<p>One way to approach this, is to have separat ViewModels instead of using our Model directly. In the end our problem was that our models are disjoint, they don’t share a common base: a car is not an animal. And this is correct. Only for the presentation layer you need to show them in on list. So when you introduce models for this layer you don’t have this problem, they can have a common base.</p>

<p>```
abstract class ViewModel {</p>

<pre><code>abstract fun type(): Int
</code></pre>

<p>}
class DuckViewModel(val duck: Duck): ViewModel() {</p>

<pre><code>override fun type() = R.layout.duck
</code></pre>

<p>}
class CarViewModel(val car: Car): ViewModel() {</p>

<pre><code>override fun type() = R.layout.car
</code></pre>

<p>}
```</p>

<p>So you simply wrapped the models. You don’t need to modify them at all and keep view specific code in those new ViewModels.</p>

<p>This way you can also add all formatting logic into there and use Android’s new Data Binding Library.</p>

<p>The idea of using list of ViewModels in the adapter instead of the Models helps especially when you need artificial items like dividers, section headers or simply advertisement items.</p>

<p>This is one approach to solve the problem. But not the only one.</p>

<h2>The Visitor</h2>

<p>Let’s go back to our initial idea of only using the Model. If you would have lots of model classes, maybe you don’t want to create lots of ViewModel one each.</p>

<p>Thinking of the type() method that you added in the first place into the model, you missed some decoupling. You need to avoid having the presentation code in there directly. You need to indirect it, move the actual type knowledge to somewhere else. How about adding an interface into this type() method:</p>

<p>```
interface Visitable {</p>

<pre><code>fun type(typeFactory: TypeFactory) : Int
</code></pre>

<p>}
```</p>

<p>Now you might ask what have you won here as the factory would still need to branch between types like the adapter did in the first place, right?</p>

<p>No it does not! This approach will be based on the Visitor pattern, one of the classic Gang-of-Four pattern. All the model will do, is forwarding this type call:</p>

<p>```
interface Animal : Visitable
interface Car : Visitable
class Mouse: Animal {</p>

<pre><code>override fun type(typeFactory: TypeFactory) 
    = typeFactory.type(this)
</code></pre>

<p>}
```</p>

<p>The factory has variations you need:</p>

<p>```
interface TypeFactory {</p>

<pre><code>fun type(duck: Duck): Int
fun type(mouse: Mouse): Int
fun type(dog: Dog): Int
fun type(car: Car): Int
</code></pre>

<p>}
```</p>

<p>This way it’s totally type safe, no instance-of, no casts needed at all.</p>

<p>And the responsibility of the factory is clear: it knows about the view types:</p>

<p>```
class TypeFactoryForList : TypeFactory {</p>

<pre><code>override fun type(duck: Duck) = R.layout.duck
override fun type(mouse: Mouse) = R.layout.mouse
override fun type(dog: Dog) = R.layout.dog
override fun type(car: Car) = R.layout.car
</code></pre>

<p>```</p>

<p>I could even also create ViewHolders to keep the knowledge about the ids in one place. So when adding a new view, this is the place to add. This should be pretty SOLID. You might need another method for new types but not modify any existing method: Open for Extension, Closed for Modification.</p>

<p>Now you might ask: why not use the factory directly from adapter instead using the indirection of the model?</p>

<p>Only with this path you get the type safety without need of casts and type checks. Take a moment to realize this here, there is not a single cast needed!This indirection is the magic behind Visitor Pattern.</p>

<p>Following this approach leaves the adapter with a very generic implementation that hardly ever needs to be changed.</p>

<h2>Conclusion</h2>

<ul>
<li>Try to keep your presentation code clean.</li>
<li>Instance-of checks should be a red flag!</li>
<li>Look out for down casting as it’s a code smell.</li>
<li>Try to replace those two with correct OO usage. Think about interfaces and inheritance.</li>
<li>Try to use generics to prevent castings.</li>
<li>Use ViewModels.</li>
<li>Check out for usages for the Visitor pattern.</li>
</ul>


<p>I would be happy to learn other ideas to make our Adapters cleaner.</p>

<p>PS: thanks to Jan M and Dmitri Kudrenko who crated examples on Github for Java and Kotlin:
<a href="https://github.com/dmitrikudrenko/BetterAdapters">https://github.com/dmitrikudrenko/BetterAdapters</a>
<a href="https://github.com/meierjan/BetterAdapters">https://github.com/meierjan/BetterAdapters</a></p>

<h2>reference</h2>

<ul>
<li><a href="https://medium.com/@dpreussler/writing-better-adapters-1b09758407d2#.vc2pos5tm">Writing Better Adapters</a></li>
<li><a href="https://juejin.im/entry/57fda1fe5bbb50005b3fef76?utm_source=gold-miner&amp;utm_medium=readme&amp;utm_campaign=github">关于 Android Adapter，你的实现方式可能一直都有问题</a></li>
<li><a href="http://github.com/flyfire/MultitypeBaseAdapter">MultitypeBaseAdapter</a></li>
</ul>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Using annotations element-value pairs in AspectJ]]></title>
    <link href="http://Solarex.github.io/blog/2016/09/17/using-annotations-element-value-pairs-in-aspectj/"/>
    <updated>2016-09-17T16:18:00+08:00</updated>
    <id>http://Solarex.github.io/blog/2016/09/17/using-annotations-element-value-pairs-in-aspectj</id>
    <content type="html"><![CDATA[<h2>Annotations with element-value pairs</h2>

<p>Annotations by themselves are really powerful. They give direct control over when an aspect should be run to the developer. Adding element-value pairs makes the already powerful annotations even more powerful, since it enables you to pass information into the aspect.</p>

<!-- more -->


<h2>Description</h2>

<p>Creating an annotation with an element-value pair is in itself quite simple. It can take different parameters and it’s up to the aspect developer to use these in their aspects. The syntax is  <code>@annotation(elementValuePairs)</code> and the <code>elementValuePairs</code> is defined by <code>[keyName] = [value]</code>. If you want more than one <code>elementValuePairs</code>  you use the <code>,</code>  as a delimiter.</p>

<p>You can get the code for this blog series at the Git repository here.</p>

<p>Let’s start coding!</p>

<p>Requirements: Maven, Java 8, (preferably) an IDE (I’m using IntelliJ)</p>

<p>Adding a element-value pair is quite simple. Getting access to it from the aspect and advice body is a little bit tricky. Let’s start with a example.</p>

<p>```
package com.jayway.blog;</p>

<p>import java.lang.annotation.ElementType;
import java.lang.annotation.Retention;
import java.lang.annotation.RetentionPolicy;
import java.lang.annotation.Target;</p>

<p>/<em>*
 * Created by Steve on 2015-09-07.
 </em>/
@Retention(RetentionPolicy.RUNTIME)
@Target(ElementType.METHOD)
public @interface YourAnnotation {</p>

<pre><code>public boolean isRun() default true;
</code></pre>

<p>}
```</p>

<p>The <code>@Retention</code>  and <code>@Target</code>  define the scope of the annotation and you can add multiple <code>@Target</code>  values. We have a boolean with the name <code>isRun()</code> with a default value of <code>true</code> . So let’s continue and access the <code>isRun()</code>  from the aspect.</p>

<p>```
package com.jayway.blog;</p>

<p>import org.aspectj.lang.ProceedingJoinPoint;
import org.aspectj.lang.annotation.*;
import org.aspectj.lang.JoinPoint;</p>

<p>@Aspect
public class YourAspect {</p>

<pre><code>//Defines a pointcut that we can use in the @Before,@After, @AfterThrowing, @AfterReturning,@Around specifications
//The pointcut will look for the @YourAnnotation
@Pointcut("@annotation(yourAnnotationVariableName)")
public void annotationPointCutDefinition(YourAnnotation yourAnnotationVariableName){
}

//Defines a pointcut that we can use in the @Before,@After, @AfterThrowing, @AfterReturning,@Around specifications
//The pointcut is a catch-all pointcut with the scope of execution
@Pointcut("execution(* *(..))")
public void atExecution(){}

//Defines a pointcut where the @YourAnnotation exists
//and combines that with an catch-all pointcut with the scope of execution
@Around("annotationPointCutDefinition(yourAnnotationVariableName) &amp;&amp; atExecution()")
//ProceedingJointPoint = the reference of the call to the method.
//The difference between ProceedingJointPoint and JointPoint is that a JointPoint can't be continued (proceeded)
//A ProceedingJointPoint can be continued (proceeded) and is needed for an Around advice
public Object aroundAdvice(ProceedingJoinPoint joinPoint, YourAnnotation yourAnnotationVariableName) throws Throwable {
    if(yourAnnotationVariableName.isRun()) {
        //Default Object that we can use to return to the consumer
        Object returnObject = null;

        try {
            System.out.println("YourAspect's aroundAdvice's body is now executed Before yourMethodAround is called.");
            //We choose to continue the call to the method in question
            returnObject = joinPoint.proceed();
            //If no exception is thrown we should land here and we can modify the returnObject, if we want to.
        } catch (Throwable throwable) {
            //Here we can catch and modify any exceptions that are called
            //We could potentially not throw the exception to the caller and instead return "null" or a default object.
            throw throwable;
        } finally {
            //If we want to be sure that some of our code is executed even if we get an exception
            System.out.println("YourAspect's aroundAdvice's body is now executed After yourMethodAround is called.");
        }
        return returnObject;
    }
    else{
        return joinPoint.proceed();
    }
}

@After("annotationPointCutDefinition(yourAnnotationVariableName) &amp;&amp; atExecution()")
//JointPoint = the reference of the call to the method
public void printNewLine(JoinPoint pointcut, YourAnnotation yourAnnotationVariableName){
    //Just prints new lines after each method that's executed in
    System.out.print("\n\r");
}
</code></pre>

<p>}
```</p>

<p>We specify that the  <code>annotationPointCutDefinition(YourAnnotation yourAnnotationVariableName)</code> contains a <code>YourAnnotation</code> reference. The variable reference is then used in the <code>@Pointcut("@annotation(yourAnnotationVariableName")</code>  instead of the generic <code>YourAnnotation</code> that were used in the earlier examples. By passing the variable to the <code>@annotation</code> we gain access to it. We need to pass the variable into the <code>@Around</code>  advice to gain access to the variable in the advice body.  Once in the advice body we can use it like a normal method parameter.</p>

<p>```
package com.jayway.blog;</p>

<p>public class YourClass {</p>

<pre><code>public static void main(String[] args) {
    YourClass yourClass = new YourClass();
    yourClass.yourMethodAroundDontRun();
    yourClass.yourMethodAroundRunTrue();
    yourClass.yourMethodAroundRun();
}

@YourAnnotation(isRun = false)
public void yourMethodAroundDontRun(){
    System.out.println("Executing TestTarget.yourMethodAroundDontRun()");
}

@YourAnnotation(isRun = true)
public void yourMethodAroundRunTrue(){
    System.out.println("Executing TestTarget.yourMethodAroundRunTrue()");
}

@YourAnnotation()
public void yourMethodAroundRun(){
    System.out.println("Executing TestTarget.yourMethodAroundRun()");
}
</code></pre>

<p>}
```</p>

<p>We add the annotation to our methods and have the option to omit the parameter or directly specify the value of the parameter. If the parameter is omitted the parameter will get it’s default value specified in the annotation.</p>

<h2>Conclusion</h2>

<p>Annotations with element-value pairs can be really powerful for both the developer who is using the aspects and as the one developing them. It gives the ability to send parameters into the aspect code. By adding the ability to send parameters we open up the code to be more configurable. By having aspects that are configurable we open up the code to be separated into it’s own independent framework or library.</p>

<h2>reference</h2>

<ul>
<li><a href="http://blog.jayway.com/2015/09/09/using-annotations-element-value-pairs-in-aspectj/">Using annotations element-value pairs in AspectJ </a></li>
</ul>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Defining pointcuts by annotations]]></title>
    <link href="http://Solarex.github.io/blog/2016/09/16/defining-pointcuts-by-annotations/"/>
    <updated>2016-09-16T16:17:00+08:00</updated>
    <id>http://Solarex.github.io/blog/2016/09/16/defining-pointcuts-by-annotations</id>
    <content type="html"><![CDATA[<h2>Pointcuts by annotations</h2>

<p>Using annotations is more convenient than using patterns. While patterns might be anything between a big cannon and a scalpel the annotations are definitely a scalpel, by only getting the pointcuts that the developer has manually specified.</p>

<p>You can get the code for this blog series at the Git repository <a href="https://github.com/Nosfert/AspectJ-Tutorial-jayway">here</a>.</p>

<!-- more -->


<p>Let’s start coding!</p>

<p>Requirements: Maven, Java 8, (preferably) an IDE (I’m using IntelliJ)</p>

<p>The use of annotations is a precise way to define when an aspect should be run. They are only run when a developer has used the annotation on an object or method.</p>

<p>The errors that can and will occur</p>

<p>Using only annotations creates another problem that we don’t need to think about while using patterns; It will make our advice run twice(or more), because the annotation pointcut don’t specify if it should be run during execution or initialization. The reason for the advice in the pattern example not being executed twice is that the pattern uses the <a href="https://eclipse.org/aspectj/doc/released/progguide/semantics-pointcuts.html">combinator</a> execute(pattern) . We are practically saying that the advice should only look for code that’s executed. There are different combinators that we can use to define when we should run our advice; one of them is execute.</p>

<p>So instead of only using annotations we need to use annotations and a combinator with a pattern. The simplest way is to use a catch all pattern with the combinator execution and then combine it with an annotation.</p>

<p>A real example:</p>

<p>```
package com.jayway.blog;</p>

<p>import org.aspectj.lang.ProceedingJoinPoint;
import org.aspectj.lang.annotation.*;
import org.aspectj.lang.JoinPoint;</p>

<p>@Aspect
public class YourAspect {</p>

<pre><code>//Defines a pointcut where the @YourAnnotation exists
//And combines that with a catch all pointcut with the scope of execution
@Around("@annotation(YourAnnotation) &amp;&amp; execution(* *(..))")
//ProceedingJointPoint = the reference of the call to the method.
//Difference between ProceedingJointPoint and JointPoint is that a JointPoint can't be continued(proceeded)
//A ProceedingJointPoint can be continued(proceeded) and is needed for a Around advice
public Object aroundAdvice(ProceedingJoinPoint joinPoint) throws Throwable {
    //Default Object that we can use to return to the consumer
    Object returnObject = null;
    try {
        System.out.println("YourAspect's aroundAdvice's body is now executed Before yourMethodAround is called.");
        //We choose to continue the call to the method in question
        returnObject = joinPoint.proceed();
        //If no exception is thrown we should land here and we can modify the returnObject, if we want to.
    } catch (Throwable throwable) {
        //Here we can catch and modify any exceptions that are called
        //We could potentially not throw the exception to the caller and instead return "null" or a default object.
        throw throwable;
    }
    finally {
        //If we want to be sure that some of our code is executed even if we get an exception
        System.out.println("YourAspect's aroundAdvice's body is now executed After yourMethodAround is called.");
    }
    return returnObject;
}
</code></pre>

<p>}
```</p>

<p>In this example we are using the combinator execute with a catch-all pattern and annotations. Basically we are looking for any code that’s executed and has the annotation @YourAnnotation. There is a whole list of different combinators at AspectJ’s homepage. Each one of them can take different patterns to help you define when your advice should be triggered.</p>

<p>Implementing annotation in a class</p>

<p>```
package com.jayway.blog;</p>

<p>public class YourClass {</p>

<pre><code>public static void main(String[] args) {
    YourClass yourClass = new YourClass();
    yourClass.yourMethodAround();
}

@YourAnnotation
public void yourMethodAround(){
    System.out.println("Executing TestTarget.yourMethodAround()");
}
</code></pre>

<p>}
```</p>

<p>By adding the <code>@YourAnnotation</code>  before any method the aspect will find the annotation and execute the advice body.</p>

<h2>Complexity and @Pointcut</h2>

<p>When there is a need to define pointcuts that are a bit more complex we can define a standalone pointcut that we can reuse. By using the @Pointcut attribute we can define a specific pointcut and when it should get run. We can then use the name of the pointcut as a reference in the @Before ,  @After, @AfterThrowing,  @AfterReturn  and @Around .</p>

<p>A real example:</p>

<p>```
package com.jayway.blog;</p>

<p>import org.aspectj.lang.ProceedingJoinPoint;
import org.aspectj.lang.annotation.*;
import org.aspectj.lang.JoinPoint;</p>

<p>@Aspect
public class YourAspect {</p>

<pre><code>//Defines a pointcut that we can use in the @Before,@After, @AfterThrowing, @AfterReturning,@Around specifications
//The pointcut will look for the @YourAnnotation
@Pointcut("@annotation(YourAnnotation)")
public void annotationPointCutDefinition(){
}

//Defines a pointcut that we can use in the @Before,@After, @AfterThrowing, @AfterReturning,@Around specifications
//The pointcut is a catch all pointcut with the scope of execution
@Pointcut("execution(* *(..))")
public void atExecution(){}

@After("annotationPointCutDefinition() &amp;&amp; atExecution()")
//JointPoint = the reference of the call to the method
public void printNewLine(JoinPoint pointcut){
    //Just prints new lines after each method that's executed in
    System.out.print("\n\r");
}
</code></pre>

<p>}
```</p>

<p>We got the same result as the earlier example but we are using the name of the pointcuts so we can reuse them.</p>

<h2>Conclusion</h2>

<p>Annotations can be a precise tool, as a pointcut will not trigger if the annotations are not in the code. But there are some weak points that we need to try and cover up with the use of combinators and patterns. Combining patterns and annotations is a good middle road when we want to specify when the advice should be run.</p>

<h2>reference</h2>

<ul>
<li><a href="http://blog.jayway.com/2015/09/08/defining-pointcuts-by-annotations/">Defining pointcuts by annotations</a></li>
</ul>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Defining pointcuts by pattern]]></title>
    <link href="http://Solarex.github.io/blog/2016/09/15/defining-pointcuts-by-pattern/"/>
    <updated>2016-09-15T16:16:00+08:00</updated>
    <id>http://Solarex.github.io/blog/2016/09/15/defining-pointcuts-by-pattern</id>
    <content type="html"><![CDATA[<h2>Pointcuts by pattern</h2>

<p>Going through all the different ways of defining pointcuts and explaining them in an easy manner would be a near impossible feat for this post. Rather than aiming for the impossible let’s narrow down the scope, and talk about the most commonly used pointcut definitions and how we can experiment with them. We will get you started with defining your own pointcuts!</p>

<p>You can get the code for this blog series at the Git repository <a href="https://github.com/Nosfert/AspectJ-Tutorial-jayway">here</a>.</p>

<!-- more -->


<p>Let’s start coding!</p>

<p>Requirements: Maven, Java 8, (preferably) an IDE (I’m using IntelliJ)</p>

<p>Patterns are designed by the following elements and any element in the pattern can use wildcards (*)</p>

<p><strong>[modifiers] [return type] <a href="parameters">(packageName)(className)(methodName)</a></strong></p>

<p><strong>[modifiers]</strong> can be left blank; that will be interpreted as <code>*</code>
<strong>[void/object/primitive type]</strong> defined by either <code>void</code> , a specific object or a primitive type
<strong>[(packageName)(className)(methodName)]</strong> <code>your.package.structure.ClassName.yourMethod</code>  is valid. You can add <code>*</code>anywhere in that line to extend the search pattern
<strong>(parameters)</strong> <code>yourMetod(..)</code>  defines any method named yourMethod. The (..) is the parameter section. In this case it defines that it looks for none or any parameters.  If we replace the <code>..</code>  with <code>Integer</code>  we will only look for a method called <code>yourMethod(Integer)</code>  and that has one parameter that is an <code>Integer</code>.</p>

<p>A real example:</p>

<p>```
package com.jayway.blog;</p>

<p>import org.aspectj.lang.ProceedingJoinPoint;
import org.aspectj.lang.annotation.*;
import org.aspectj.lang.JoinPoint;</p>

<p>@Aspect
public class YourAspect {</p>

<pre><code>//Patterns
//blank = modifier (public/private/protected or default(blank) should be looked for
//* = return type to look for. Void/Object
//com.jayway.YourClass.yourMethodBefore(..) = PackageName . ClassName . methodName (parameters)
@Before("execution (* com.jayway.blog.YourClass.yourMethodBefore(..))")
//JointPoint = the reference of the call to the method
public void beforeAdvice(JoinPoint joinPoint) {
    System.out.println("YourAspect's BeforeAdvice's body is now executed Before yourMethodBefore is called.");
}
//Patterns
//public = look for the specific modifier named public
//!Object = Basically we are looking for void or primitives. But if we specified Object we could get a good pattern
//com.jayway.YourClass.yourMethodBefore(..) = PackageName . ClassName . methodName (parameters)
@After("execution (public !Object com.jayway.blog.YourClass.yourMethodAfter(..))")
public void afterAdvice(JoinPoint joinPoint) {
    System.out.println("YourAspect's afterAdvice's body is now executed After yourMethodAfter is called.");
}
//Patterns
//!private = look for any modifier thats not private
//void = looking for method with void
//com.jayway.YourClass.yourMethodBefore(..) = PackageName . ClassName . methodName (parameters)
@Around("execution (!private void com.jayway.blog.YourClass.yourMethodAround(Integer,..))")
//ProceedingJointPoint = the reference of the call to the method.
//Difference between ProceedingJointPoint and JointPoint is that a JointPoint cant be continued(proceeded)
//A ProceedingJointPoint can be continued(proceeded) and is needed for a Around advice
public Object aroundAdvice(ProceedingJoinPoint joinPoint) throws Throwable {
    //Default Object that we can use to return to the consumer
    Object returnObject = null;
    try {
        System.out.println("YourAspect's aroundAdvice's body is now executed Before yourMethodAround is called.");
        //We choose to continue the call to the method in question
        returnObject = joinPoint.proceed();
        //If no exception is thrown we should land here and we can modify the returnObject, if we want to.
    } catch (Throwable throwable) {
        //Here we can catch and modify any exceptions that are called
        //We could potentially not throw the exception to the caller and instead return "null" or a default object.
        throw throwable;
    }
    finally {
        //If we want to be sure that some of our code is executed even if we get an exception
        System.out.println("YourAspect's aroundAdvice's body is now executed After yourMethodAround is called.");
    }

    return returnObject;
}
//Patterns//* = return type to look for. Void/Object/Primitive type
//blank = modifier (public/private/protected or default(blank) should be looked for
//* = return type to look for. Void/Object/Primitive type
//com.jayway.YourClass.yourMethod*(..) = PackageName . ClassName . * (parameters)
//Where the "*" will catch any method name
@After("execution ( * com.jayway.blog.YourClass.*(..))")
//JointPoint = the reference of the call to the method
public void printNewLine(JoinPoint pointcut){
    //Just prints new lines after each method that's executed in
    System.out.print("\n\r");
}
</code></pre>

<p>}
```</p>

<p>In this example we are using the combinator  execution([pattern])  to define when this pointcut should be triggered. There are a whole list of different <a href="https://eclipse.org/aspectj/doc/released/progguide/semantics-pointcuts.html">combinators</a> at AspectJ’s homepage. Each one of them can take different patterns to help you define when your advice should be triggered.</p>

<h2>JointPoint and ProceedingJointPoint</h2>

<p>A JointPoint in the code is the call to the actual (method/object) in question. The ProceedingJointPoint  extends JointPoint to add the option to continue (proceed) the call to the (method/object) in question. The JointPoint contains a lot of information (such as parameters) that can be useful when writing the advice body.</p>

<h2>Conclusion</h2>

<p>Patterns can difficult – that’s why there are so many threads about how to define patterns online. Patterns gives us a lot of power, but demand that we know what we are looking for. Having the options to specify modifiers, return value and parameters gives us great tools to narrow down the complexity of our patterns.</p>

<h2>reference</h2>

<ul>
<li><a href="http://blog.jayway.com/2015/09/08/defining-pointcuts-by-pattern/">Defining pointcuts by pattern</a></li>
</ul>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[The basics of AOP]]></title>
    <link href="http://Solarex.github.io/blog/2016/09/14/the-basics-of-aop/"/>
    <updated>2016-09-14T16:15:00+08:00</updated>
    <id>http://Solarex.github.io/blog/2016/09/14/the-basics-of-aop</id>
    <content type="html"><![CDATA[<h2>Aspect Oriented Programming</h2>

<p>AOP is both a complex and quite simple thing. There has been a lot of buzz around AOP but recently the buzz has faded. The question that people still ask is “what do I do with it”. Hopefully you will have an idea of what it is and create your own thoughts on how you could use it.</p>

<p>In this post I aim to describe what AOP actually is and how it works.</p>

<!-- more -->


<h2>Description</h2>

<p>Aspect Oriented Programming circle around Aspects. An aspect contains descriptions of Joint-points and Advice bodies. The joint-points defines rules of when they should be triggered, once triggered they will execute the advice body.</p>

<p>An aspect acts like a middleman/proxy between the consumer of a (method/object) and the (method/object) in question. This can be achieved in five different scenarios such as; <strong>Before, After, AfterReturn, AfterThrowing and Around</strong> a (method/object) is called.</p>

<h2>The power of advice body</h2>

<p>Once a joint-point has triggered the advice body will be executed. The advice body has tremendous power and here lies the actual code that so many people think is “magic”.</p>

<p>Some of the powerful things that the advice body can do are</p>

<ul>
<li>modify any parameters that are passed into the call.</li>
<li>modify the return value</li>
<li>choose to not continue the call to the (method/object) in question</li>
<li>call other (methods/objects)</li>
<li>catch any exception that is thrown by the (method/object) in question</li>
</ul>


<h2>Before, After and Around</h2>

<h3>Before – @Before</h3>

<p>The before advice can only modify things before the (method/object) in question is called. The advice has the power to throw an exception and cancel the call to the (method/object) in question and modify the parameters of the call.</p>

<center><img src="http://Solarex.github.io/images/aspectj-before.png"/></center>


<h3>After – @After , @AfterReturning  or @AfterThrowing</h3>

<p>The after advice can only intercept the eventual return value of the (method/object) that is being called. The after advice contain three different definitions for the three different use-cases. @After  let you do things after a call and can return it’s own return value.  But @After  does not give you access to any potential return value or any potential exception that the called (method/object) creates. @AfterReturning  gives you the same abilities as @After  but gives you access to the return value. @AfterThrowing  gives you the same abilities as @After  but access to any exception that is thrown.</p>

<center><img src="http://Solarex.github.io/images/aspectj-after.png"/></center>


<h3>Around – @Around</h3>

<p>An around advice is like a combination of the Before and After advice. Once it has intercepted a call to the (method/object) in question it has the same control as the Before. The big difference is that when the (method/object) has run the advice gets access to any potential return value or exception. While it has access to the potential return or exception value it has the option to continue doing operations with/on that value. The advice specifies what to return to the caller.</p>

<center><img src="http://Solarex.github.io/images/aspectj-around.png"/></center>


<h2>Conclusion</h2>

<p>The advice can and will intercept calls to (method/object) according to the joint-point definition. The advice can specify five different situations of when they should be run. Each situation gives the advice different options to do its operations. Before, After, AfterReturn, AfterThrowing and Around are powerful in their own ways. Figuring out when to use what advice is the tricky part.</p>

<h2>Example</h2>

<p>The most classical example of AOP would be logging information. Printing out information before and after a method have been called and even printing out specific exception information. By using AOP for logging we could easily create a standardized pattern that will apply to all our code.  By having the logging information in the aspect lets us modify  a few rows of code and see it take affect everywhere at the same time.  And the developers don’t need to implement their own logging for each method/class.</p>

<h2>reference</h2>

<ul>
<li><a href="https://blog.jayway.com/2015/09/07/the-basics-of-aop/">The basics of AOP</a></li>
</ul>

]]></content>
  </entry>
  
</feed>
