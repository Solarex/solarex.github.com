<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: dev | Solarex's Blog]]></title>
  <link href="http://Solarex.github.io/blog/categories/dev/atom.xml" rel="self"/>
  <link href="http://Solarex.github.io/"/>
  <updated>2019-08-26T23:07:46+08:00</updated>
  <id>http://Solarex.github.io/</id>
  <author>
    <name><![CDATA[Solarex]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[Dagger2学习]]></title>
    <link href="http://Solarex.github.io/blog/2019/04/30/learning-dagger2/"/>
    <updated>2019-04-30T16:17:00+08:00</updated>
    <id>http://Solarex.github.io/blog/2019/04/30/learning-dagger2</id>
    <content type="html"><![CDATA[<h3>reference</h3>

<ul>
<li><a href="https://www.youtube.com/playlist?list=PLrnPJCHvNZuA2ioi4soDZKz8euUQnJW65">Dagger2 Beginner Tutorial</a></li>
</ul>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Kotlin是如何实现方法默认参数的]]></title>
    <link href="http://Solarex.github.io/blog/2019/04/18/how-kotlin-generate-method-default-arguments/"/>
    <updated>2019-04-18T10:36:00+08:00</updated>
    <id>http://Solarex.github.io/blog/2019/04/18/how-kotlin-generate-method-default-arguments</id>
    <content type="html"><![CDATA[<p>学习Kotlin的时候，发现可以给方法设置默认参数，Java是不支持给方法设置默认参数的，那Kotin是如何实现的呢？不妨看下下面的kotlin文件，kotlin允许这样写：</p>

<p>```kotlin
class frob() {</p>

<pre><code>fun fred(x: Int = 300, y: frob = mkfrob(x)) {
    println("${this}${x}${y}")
}
fun mkfrob(x: Int): frob {
    return this;
}
fun boobar() {
    fred();
    fred(100);
    fred(100, frob());
}
</code></pre>

<p>}
```</p>

<p>使用<code>kotlinc</code>编译成class文件之后，我们使用<code>cfr</code>反编译一下class文件看下编译器帮我们做了什么黑魔法。</p>

<!-- more -->


<p>```java
import java.io.PrintStream;
import kotlin.Metadata;
import kotlin.jvm.internal.Intrinsics;
import org.jetbrains.annotations.NotNull;</p>

<p>@Metadata(mv={1, 1, 13}, bv={1, 0, 3}, k=1, d1={&ldquo;\u0000\u001c\n\u0002\u0018\u0002\n\u0002\u0010\u0000\n\u0002\b\u0002\n\u0002\u0010\u0002\n\u0002\b\u0002\n\u0002\u0010\b\n\u0002\b\u0002\u0018\u00002\u00020\u0001B\u0005\u00a2\u0006\u0002\u0010\u0002J\u0006\u0010\u0003\u001a\u00020\u0004J\u001a\u0010\u0005\u001a\u00020\u00042\b\b\u0002\u0010\u0006\u001a\u00020\u00072\b\b\u0002\u0010\b\u001a\u00020\u0000J\u000e\u0010\t\u001a\u00020\u00002\u0006\u0010\u0006\u001a\u00020\u0007&rdquo;}, d2={&ldquo;Lfrob;&rdquo;, &ldquo;&rdquo;, &ldquo;()V&rdquo;, &ldquo;boobar&rdquo;, &ldquo;&rdquo;, &ldquo;fred&rdquo;, &ldquo;x&rdquo;, &ldquo;&rdquo;, &ldquo;y&rdquo;, &ldquo;mkfrob&rdquo;})
public final class frob {</p>

<pre><code>public final void fred(int x, @NotNull frob y) {
    Intrinsics.checkParameterIsNotNull((Object)y, (String)"y");
    String string = "" + this + x + y;
    System.out.println((Object)string);
}

public static /* synthetic */ void fred$default(frob frob2, int n, frob frob3, int n2, Object object) {
    if ((n2 &amp; 1) != 0) {
        n = 300;
    }
    if ((n2 &amp; 2) != 0) {
        frob3 = frob2.mkfrob(n);
    }
    frob2.fred(n, frob3);
}

@NotNull
public final frob mkfrob(int x) {
    return this;
}

public final void boobar() {
    frob.fred$default(this, 0, null, 3, null);
    frob.fred$default(this, 100, null, 2, null);
    this.fred(100, new frob());
}
</code></pre>

<p>}
```</p>

<p>可以看到编译器底层自动为我们生成了一个<code>static</code>,<code>synthetic</code>的方法，在这个方法中，第一个参数是对象接收者，第二个和第三个参数和我们声明的<code>fred</code>方法相同，第四个参数<code>n2</code>从方法体可以看出是一个bitmask。</p>

<p>从生成的方法<code>fred$default</code>实现来看，每个可以有默认参数的位置的参数有个mask值，为<code>2^x</code>，x为参数出现的顺序，如果方法调用的时候用到了某个位置上的默认参数，<code>fred$default</code>方法的第四个参数<code>n2</code>就会加上<code>2^x</code>。</p>

<p>在Java中是不能使用默认参数调用<code>fred</code>这种方法的，如果想要在Java中调用，需要给方法加上<code>@JvmOverloads</code>注解，我们加上这个注解再去反编译一下看下有什么变化。</p>

<p>```kotlin
class frob() {</p>

<pre><code>@JvmOverloads
fun fred(x: Int = 300, y: frob = mkfrob(x)) {
    println("${this}${x}${y}")
}
fun mkfrob(x: Int): frob {
    return this;
}
fun boobar() {
    fred();
    fred(100);
    fred(100, frob());
}
</code></pre>

<p>}
```</p>

<p>再反编译一下我们看下有什么变化：</p>

<p>```java
import java.io.PrintStream;
import kotlin.Metadata;
import kotlin.jvm.JvmOverloads;
import kotlin.jvm.internal.Intrinsics;
import org.jetbrains.annotations.NotNull;</p>

<p>@Metadata(mv={1, 1, 13}, bv={1, 0, 3}, k=1, d1={&ldquo;\u0000\u001c\n\u0002\u0018\u0002\n\u0002\u0010\u0000\n\u0002\b\u0002\n\u0002\u0010\u0002\n\u0002\b\u0002\n\u0002\u0010\b\n\u0002\b\u0002\u0018\u00002\u00020\u0001B\u0005\u00a2\u0006\u0002\u0010\u0002J\u0006\u0010\u0003\u001a\u00020\u0004J\u001c\u0010\u0005\u001a\u00020\u00042\b\b\u0002\u0010\u0006\u001a\u00020\u00072\b\b\u0002\u0010\b\u001a\u00020\u0000H\u0007J\u000e\u0010\t\u001a\u00020\u00002\u0006\u0010\u0006\u001a\u00020\u0007&rdquo;}, d2={&ldquo;Lfrob;&rdquo;, &ldquo;&rdquo;, &ldquo;()V&rdquo;, &ldquo;boobar&rdquo;, &ldquo;&rdquo;, &ldquo;fred&rdquo;, &ldquo;x&rdquo;, &ldquo;&rdquo;, &ldquo;y&rdquo;, &ldquo;mkfrob&rdquo;})
public final class frob {</p>

<pre><code>@JvmOverloads
public final void fred(int x, @NotNull frob y) {
    Intrinsics.checkParameterIsNotNull((Object)y, (String)"y");
    String string = "" + this + x + y;
    System.out.println((Object)string);
}

@JvmOverloads
public static /* synthetic */ void fred$default(frob frob2, int n, frob frob3, int n2, Object object) {
    if ((n2 &amp; 1) != 0) {
        n = 300;
    }
    if ((n2 &amp; 2) != 0) {
        frob3 = frob2.mkfrob(n);
    }
    frob2.fred(n, frob3);
}

@JvmOverloads
public final void fred(int x) {
    frob.fred$default(this, x, null, 2, null);
}

@JvmOverloads
public final void fred() {
    frob.fred$default(this, 0, null, 3, null);
}

@NotNull
public final frob mkfrob(int x) {
    return this;
}

public final void boobar() {
    frob.fred$default(this, 0, null, 3, null);
    frob.fred$default(this, 100, null, 2, null);
    this.fred(100, new frob());
}
</code></pre>

<p>}
```</p>

<p>可以看到比上面多生成了几个重载的方法，在重载的方法内部调用了生成方法<code>fred$default</code>。</p>

<h3>reference</h3>

<ul>
<li><a href="https://www.benf.org/other/cfr/kotlin-defaults.html">How does Kotlin generate default arguments?</a></li>
</ul>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[自定义View总结三]]></title>
    <link href="http://Solarex.github.io/blog/2019/03/12/summary-of-custom-views-part-iii/"/>
    <updated>2019-03-12T00:34:00+08:00</updated>
    <id>http://Solarex.github.io/blog/2019/03/12/summary-of-custom-views-part-iii</id>
    <content type="html"><![CDATA[<h3>自定义View总结 &ndash; 触摸反馈</h3>

<p>之前分析了<a href="http://solarex.github.io/blog/2018/03/25/android-touch-system/">Android触摸事件分发机制</a>，在自定义View的时候进行触摸反馈，一般都是重写<code>onTouchEvent</code>，当然也有一些工具类可以使用，本文就对这些工具类进行总结，他们是<code>ViewConfiguration</code>，<code>Scroller</code>，<code>OverScroller</code>，<code>VelocityTracker</code>，<code>GestureDetector</code>，<code>ScaleGestureDetector</code>，<code>ViewDragHelper</code>。</p>

<!-- more -->


<h4>ViewConfiguration</h4>

<p><code>ViewConfiguration</code>定义了一些UI系统用用到的常量，包括timeouts,sizes,distances。timeouts比如<code>DEFAULT_LONG_PRESS_TIMEOUT</code>,<code>DOUBLE_TAP_TIMEOUT</code>等，sizes包括<code>SCROLL_BAR_SIZE</code>等，distances我们平时自定义View的时候可能用的比较多，常用的有<code>getScaledTouchSlop</code>来判断是否是滑动，<code>getScaledPagingTouchSlop</code>来判断是否是翻页滑动，自己写<code>ViewPager</code>的时候可以用到，<code>getScaledMaximumFlingVelocity</code>和<code>getMinimumFlingVelocity</code>来对惯性滑动进行判断处理。</p>

<h3>Scroller &amp; OverScroller</h3>

<p><code>View</code>的<code>scrollTo</code>和<code>scrollBy</code>是瞬间完成的，如果需要<code>View</code>的滑动有个动画效果，说白了，就是View的位置移动有段时间间隔，可以使用<code>Scroller</code>或<code>OverScroller</code>来完成。<code>Scroller</code>本身无法让View滑动，它主要是个计算器，得配合View的<code>computeScroll</code>使用才能完成这个功能，或者不使用View的<code>computeScroll</code>，你自己写个<code>Runnable</code>，在<code>Runnable</code>里面进行<code>Scroller</code>计算完成的判断并调用View的<code>scrollTo</code>，然后再<code>postOnAnimation(this)</code>将自身传入再次调用即可。</p>

<p>使用<code>computeScroll</code>的样板代码如下：</p>

<p>```java
Scroller scroller = new Scroller(context);</p>

<p>// 缓慢滚动到指定位置
private void smoothScrollTo(int destX, int destY) {</p>

<pre><code>int scrollx = getScrollX();
int dx = destX - scrollx;
scroller.startScroll(scrollx, 0, dx, 0, 1000);
// 这步很重要，触发下面的 computeScroll
invalidate();
</code></pre>

<p>}</p>

<p>@Override
public void computeScroll() {</p>

<pre><code>if(scroller.computeScrollOffset()) {
    scrollTo(scroller.getCurrX(), scroller.getCurrY());
    // 这步继续触发 computeScroll，Scroller会更新x,y，View继续scrollTo新位置
    postInvalidate();或者invalidate();
}
</code></pre>

<p>}
```</p>

<p><code>OverScroller</code>的<code>startScroll</code>，<code>fling</code>方法和<code>Scroller</code>类似，不再赘述，除此之外<code>OverScroller</code>还有一个带over参数的<code>fling</code>函数<code>public void fling(int startX, int startY, int velocityX, int velocityY, int minX, int maxX, int minY, int maxY, int overX, int overY)</code>可以滑动超出View的边界。</p>

<h4>VelocityTracker</h4>

<p>速度追踪，用于追踪手指在滑动过程中的速度，包括水平和垂直方向的速度，一般配合<code>Scroller</code>的<code>fling</code>使用。它的使用过程很简单，首先，在View的<code>onTouchEvent</code>方法中追踪当前单击事件的速度：</p>

<p><code>java
// onTouchEvent
VelocityTracker velocityTracker = VelocityTracker.obtain();
velocityTracker.addMovement(event);
</code></p>

<p>接着，在手指抬起，也就是<code>ACTION_UP</code>的时候，获取速度：</p>

<p><code>java
// onTouchEvent ACTION_UP
velocityTracker.computeCurrentVelocity(1000);
int xVel = (int) velocityTracker.getXVelocity();
int yVel = (int) velocityTracker.getYVelocity();
/* do something like fling */
velocityTracker.clear();
velocityTracker.recycle(); // 重置并回收
</code></p>

<p>速度的计算公式是<code>速度=(终点位置 - 起点位置)/时间段</code>，所以逆着手机坐标系的正方向滑动，所产生的速度为负值。另外记得要重置并回收<code>VelocityTracker</code>。</p>

<h4>GestureDetector &amp; ScaleGestureDetector</h4>

<p><code>GestureDetector</code>手势检测，用于辅助检测用户的单击、滑动、长按、双击等行为。<code>ScaleGestureDetector</code>主要是双指或多指的pinch zoom放大缩小行为。要使用<code>GestureDetector</code>也很简单，参考如下过程。</p>

<p>首先，创建<code>GestureDetector</code>对象并实现<code>GestureDetector.OnGestureListener</code>接口，根据需要也可以实现<code>GestureDetector.OnDoubleTapListener</code>接口或者<code>GestureDetector.OnContextClickListener</code>接口，或者使用<code>SimpleOnGestureListener</code>来在自己感兴趣的方法中做处理。</p>

<table>
<thead>
<tr>
<th></th>
<th align="center">        方法名        </th>
<th align="center">                             描述                             </th>
<th align="center">      所属接口       </th>
</tr>
</thead>
<tbody>
<tr>
<td></td>
<td align="center">        onDown        </td>
<td align="center">            手指轻触屏幕，由1个<code>ACTION_DOWN</code>触发            </td>
<td align="center">  OnGestureListener  </td>
</tr>
<tr>
<td></td>
<td align="center">     onShowPress      </td>
<td align="center">    手指轻触屏幕，尚未松开或拖动，由1个<code>ACTION_DOWN</code>触发    </td>
<td align="center">  OnGestureListener  </td>
</tr>
<tr>
<td></td>
<td align="center">    onSingleTapUp     </td>
<td align="center">   手指轻触屏幕后松开，随着<code>ACTION_UP</code>触发，这是单击行为    </td>
<td align="center">  OnGestureListener  </td>
</tr>
<tr>
<td></td>
<td align="center">       onScroll       </td>
<td align="center"> 手指按下屏幕并拖动，由1个<code>ACTION_DOWN</code>及多个<code>ACTION_MOVE</code>触发，这是拖动行为 </td>
<td align="center">  OnGestureListener  </td>
</tr>
<tr>
<td></td>
<td align="center">     onLongPress      </td>
<td align="center">                             长按                             </td>
<td align="center">  OnGestureListener  </td>
</tr>
<tr>
<td></td>
<td align="center">       onFling        </td>
<td align="center"> 按下屏幕快速滑动后松开，由1个<code>ACTION_DOWN</code>多个<code>ACTION_MOVE</code>和1个<code>ACTION_UP</code>触发，快速滑动 </td>
<td align="center">  OnGestureListener  </td>
</tr>
<tr>
<td></td>
<td align="center">     onDoubleTap      </td>
<td align="center"> 双击，由2次连续的单击组成，不可能和onSingleTapConfirmed共存  </td>
<td align="center"> OnDoubleTapListener </td>
</tr>
<tr>
<td></td>
<td align="center"> onSingleTapConfirmed </td>
<td align="center">                        严格的单击行为                        </td>
<td align="center"> OnDoubleTapListener </td>
</tr>
<tr>
<td></td>
<td align="center">   onDoubleTapEvent   </td>
<td align="center"> 发生了双击行为，在双击期间，<code>ACTION_DOWN</code>、<code>ACTION_MOVE</code>、<code>ACTION_UP</code>都会触发此回调 </td>
<td align="center"> OnDoubleTapListener </td>
</tr>
</tbody>
</table>


<p>接着，接管目标View的<code>onTouchEvent</code>方法</p>

<p><code>java
// onTouchEvent
boolean consume = mGestureDetector.onTouchEvent(event);
return consume;
</code></p>

<p>事件经过判断后就会回调我们实现的listener中的方法。如果只是监听滑动相关的可以自己在<code>onTouchEvent</code>方法的<code>ACTION_MOVE</code>中调用<code>View</code>的<code>scrollTo(x,y)</code>来实现View的滑动，如果是监听双击这种行为的话，就使用<code>GestureDetector</code>。</p>

<p><code>ScaleGestureDetector</code>是处理放大缩小手势的，使用和<code>GestureDetector</code>类似。</p>

<table>
<thead>
<tr>
<th></th>
<th align="center">                           方法名                            </th>
<th align="center">                             描述                             </th>
<th align="center">        所属接口        </th>
</tr>
</thead>
<tbody>
<tr>
<td></td>
<td align="center">   public boolean onScale(ScaleGestureDetector detector);    </td>
<td align="center"> 通过调用detector.getScaleFactor来获得放大的系数，来进行进一步处理，比如对ImageView的Matrix进行操作等等，返回值代表事件有没有被消费 </td>
<td align="center"> OnScaleGestureListener |</td>
</tr>
<tr>
<td></td>
<td align="center"> public boolean onScaleBegin(ScaleGestureDetector detector); </td>
<td align="center"> 如果要检测放大缩小手势，返回true，类似于<code>ACTION_DOWN</code>对事件感兴趣返回true </td>
<td align="center"> OnScaleGestureListener |</td>
</tr>
<tr>
<td></td>
<td align="center">   public void onScaleEnd(ScaleGestureDetector detector);    </td>
<td align="center"> 放大或缩小结束，可以调用detector.getFocusX()或detector.getFocusY()来获取焦点 </td>
<td align="center"> OnScaleGestureListener |</td>
</tr>
</tbody>
</table>


<h3>ViewDragHelper &amp; View.OnDragListener</h3>

<p><code>ViewDragHelper</code>可以实现各种不同的滑动、拖放需求，使用参考如下过程。<code>ViewDragHelper</code>一般在自定义<code>ViewGroup</code>中使用。</p>

<p>首先，初始化<code>ViewDragHelper</code>，实现<code>ViewDragHelper.Callback</code>。<code>mViewDragHelper = ViewDragHelper.create(viewgroup, callback);</code></p>

<p>然后，接管ViewGroup的事件处理，样板代码如下：</p>

<p>```java
@Override
public boolean onInterceptTouchEvent(MotionEvent ev) {</p>

<pre><code>return mViewDragHelper.shouldInterceptTouchEvent(ev);
</code></pre>

<p>}</p>

<p>@Override
public boolean onTouchEvent(MotionEvent ev) {</p>

<pre><code>mViewDragHelper.processTouchEvent(ev);
return true;
</code></pre>

<p>}
```</p>

<p>接着，处理<code>computeScroll</code>，<code>ViewDragHelper</code>内部也是通过<code>Scroller</code>来实现平滑移动的，样板代码如下：</p>

<p>```java
@Override
public void computeScroll() {</p>

<pre><code>if(mViewDragHelper.continueSettling(true)) {
    ViewCompat.postInvalidateOnAnimation(this);
}
</code></pre>

<p>}
```</p>

<table>
<thead>
<tr>
<th></th>
<th align="center">                            方法名                            </th>
<th align="center">                             描述                             </th>
<th align="center">        所属接口         </th>
</tr>
</thead>
<tbody>
<tr>
<td></td>
<td align="center"> public abstract boolean tryCaptureView(View child, int pointerId); </td>
<td align="center">                哪个子View可以被拖动就返回true                </td>
<td align="center"> ViewDragHelper.Callback |</td>
</tr>
<tr>
<td></td>
<td align="center"> public int clampViewPositionVertical(View child, int top, int dy) {     return 0; } </td>
<td align="center">             限制被捕捉的View垂直方向上活动的范围             </td>
<td align="center"> ViewDragHelper.Callback |</td>
</tr>
<tr>
<td></td>
<td align="center"> public int clampViewPositionHorizontal(View child, int left, int dx) {     return 0; } </td>
<td align="center">              限制被捕捉View水平方向上活动的范围              </td>
<td align="center"> ViewDragHelper.Callback |</td>
</tr>
<tr>
<td></td>
<td align="center"> public void onViewCaptured(View capturedChild, int activePointerId) {} </td>
<td align="center">                    View被捕捉的时候被调用                    </td>
<td align="center"> ViewDragHelper.Callback |</td>
</tr>
<tr>
<td></td>
<td align="center"> public void onViewPositionChanged(View changedView, int left, int top, int dx, int dy) {} </td>
<td align="center">                被捕捉的View位置发生变化时调用                </td>
<td align="center"> ViewDragHelper.Callback |</td>
</tr>
<tr>
<td></td>
<td align="center">       public void onViewDragStateChanged(int state) {}       </td>
<td align="center"> drag state变化时调用，STATE_IDLE，STATE_DRAGGING，STATE_SETTLING </td>
<td align="center"> ViewDragHelper.Callback |</td>
</tr>
<tr>
<td></td>
<td align="center"> public void onViewReleased(View releasedChild, float xvel, float yvel) {} </td>
<td align="center">                       View被松开时调用                       </td>
<td align="center"> ViewDragHelper.Callback |</td>
</tr>
<tr>
<td></td>
<td align="center">  public void onEdgeTouched(int edgeFlags, int pointerId) {}  </td>
<td align="center">            没有View被捕捉，父View的边缘被touch到             </td>
<td align="center"> ViewDragHelper.Callback |</td>
</tr>
<tr>
<td></td>
<td align="center"> public boolean onEdgeLock(int edgeFlags) {     return false; } </td>
<td align="center">                                                              </td>
<td align="center"> ViewDragHelper.Callback |</td>
</tr>
<tr>
<td></td>
<td align="center"> public void onEdgeDragStarted(int edgeFlags, int pointerId) {} </td>
<td align="center">                                                              </td>
<td align="center"> ViewDragHelper.Callback |</td>
</tr>
<tr>
<td></td>
<td align="center"> public int getOrderedChildIndex(int index) {     return index; } </td>
<td align="center">                                                              </td>
<td align="center"> ViewDragHelper.Callback |</td>
</tr>
<tr>
<td></td>
<td align="center"> public int getViewHorizontalDragRange(View child) {     return 0; } </td>
<td align="center">                                                              </td>
<td align="center"> ViewDragHelper.Callback |</td>
</tr>
<tr>
<td></td>
<td align="center"> public int getViewVerticalDragRange(View child) {     return 0; } </td>
<td align="center">                                                              </td>
<td align="center"> ViewDragHelper.Callback |</td>
</tr>
</tbody>
</table>


<p><code>View.OnDragListener</code>只有一个方法<code>boolean onDrag(View v, DragEvent event);</code>，当拖拽事件被分发到View时调用。<code>DragEvent</code>有几个状态可以在其中做处理<code>ACTION_DRAG_STARTED</code>，<code>ACTION_DRAG_ENDED</code>，<code>ACTION_DRAG_ENTERED</code>，<code>ACTION_DRAG_EXITED</code>。View开始拖动可以调用<code>ViewCompat.startDragAndDrop(@NonNull View v, ClipData data,View.DragShadowBuilder shadowBuilder, Object localState, int flags)</code>来开始拖动，这样会在View上方出现一个Shadow来表示被拖动的View。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[自定义View总结二]]></title>
    <link href="http://Solarex.github.io/blog/2019/02/12/summary-of-custom-views-part-ii/"/>
    <updated>2019-02-12T00:34:00+08:00</updated>
    <id>http://Solarex.github.io/blog/2019/02/12/summary-of-custom-views-part-ii</id>
    <content type="html"><![CDATA[<h3>自定义View总结 &ndash; 布局</h3>

<h4>布局基础</h4>

<p>布局过程，就是程序在运行时利用布局文件中的代码来计算出实际尺寸和位置的过程。有两个阶段，测量阶段和布局阶段，分别对应<code>measure</code>和<code>layout</code>。</p>

<p>对于一个<code>View</code>而言，默认的<code>onMeasure</code>实现是：</p>

<!-- more -->


<p>```java</p>

<pre><code>/**
 * &lt;p&gt;
 * Measure the view and its content to determine the measured width and the
 * measured height. This method is invoked by {@link #measure(int, int)} and
 * should be overridden by subclasses to provide accurate and efficient
 * measurement of their contents.
 * &lt;/p&gt;
 *
 * &lt;p&gt;
 * &lt;strong&gt;CONTRACT:&lt;/strong&gt; When overriding this method, you
 * &lt;em&gt;must&lt;/em&gt; call {@link #setMeasuredDimension(int, int)} to store the
 * measured width and height of this view. Failure to do so will trigger an
 * &lt;code&gt;IllegalStateException&lt;/code&gt;, thrown by
 * {@link #measure(int, int)}. Calling the superclass'
 * {@link #onMeasure(int, int)} is a valid use.
 * &lt;/p&gt;
 *
 * &lt;p&gt;
 * The base class implementation of measure defaults to the background size,
 * unless a larger size is allowed by the MeasureSpec. Subclasses should
 * override {@link #onMeasure(int, int)} to provide better measurements of
 * their content.
 * &lt;/p&gt;
 *
 * &lt;p&gt;
 * If this method is overridden, it is the subclass's responsibility to make
 * sure the measured height and width are at least the view's minimum height
 * and width ({@link #getSuggestedMinimumHeight()} and
 * {@link #getSuggestedMinimumWidth()}).
 * &lt;/p&gt;
 *
 * @param widthMeasureSpec horizontal space requirements as imposed by the parent.
 *                         The requirements are encoded with
 *                         {@link android.view.View.MeasureSpec}.
 * @param heightMeasureSpec vertical space requirements as imposed by the parent.
 *                         The requirements are encoded with
 *                         {@link android.view.View.MeasureSpec}.
 *
 * @see #getMeasuredWidth()
 * @see #getMeasuredHeight()
 * @see #setMeasuredDimension(int, int)
 * @see #getSuggestedMinimumHeight()
 * @see #getSuggestedMinimumWidth()
 * @see android.view.View.MeasureSpec#getMode(int)
 * @see android.view.View.MeasureSpec#getSize(int)
 */
protected void onMeasure(int widthMeasureSpec, int heightMeasureSpec) {
    setMeasuredDimension(getDefaultSize(getSuggestedMinimumWidth(), widthMeasureSpec),
            getDefaultSize(getSuggestedMinimumHeight(), heightMeasureSpec));
}

/**
 * Utility to return a default size. Uses the supplied size if the
 * MeasureSpec imposed no constraints. Will get larger if allowed
 * by the MeasureSpec.
 *
 * @param size Default size for this view
 * @param measureSpec Constraints imposed by the parent
 * @return The size this view should be.
 */
public static int getDefaultSize(int size, int measureSpec) {
    int result = size;
    int specMode = MeasureSpec.getMode(measureSpec);
    int specSize = MeasureSpec.getSize(measureSpec);

    switch (specMode) {
    case MeasureSpec.UNSPECIFIED:
        result = size;
        break;
    case MeasureSpec.AT_MOST:
    case MeasureSpec.EXACTLY:
        result = specSize;
        break;
    }
    return result;
}

/**
 * Returns the suggested minimum width that the view should use. This
 * returns the maximum of the view's minimum width
 * and the background's minimum width
 *  ({@link android.graphics.drawable.Drawable#getMinimumWidth()}).
 * &lt;p&gt;
 * When being used in {@link #onMeasure(int, int)}, the caller should still
 * ensure the returned width is within the requirements of the parent.
 *
 * @return The suggested minimum width of the view.
 */
protected int getSuggestedMinimumWidth() {
    return (mBackground == null) ? mMinWidth : max(mMinWidth, mBackground.getMinimumWidth());
}
</code></pre>

<p>```</p>

<p>可以看到在<code>getDefault</code>方法中对<code>AT_MOST</code>(<code>wrap_content</code>)和<code>EXACTLY</code>(<code>match_parent</code>)的处理都是用父View的size来作为了子View的size，这种处理有的时候是不合适的，需要我们额外做些处理，下面是一个在写自定义View的时候的一个utils方法：</p>

<p>```java</p>

<pre><code>public static int measure(int measureSpec, int defaultSize){
    int result = defaultSize;
    int specMode = View.MeasureSpec.getMode(measureSpec);
    int specSize = View.MeasureSpec.getSize(measureSpec);
    if (specMode == View.MeasureSpec.EXACTLY){
        result = specSize;
    } else if (specMode == View.MeasureSpec.AT_MOST){
        result = Math.min(specSize, defaultSize);
    }
    return result;
}
</code></pre>

<p>```</p>

<p>测量阶段，<code>measure()</code>方法被父View调用，在<code>measure()</code>中做一些准备和优化工作后，调用<code>onMeasure()</code>来进行实际的自我测量。<code>onMeasure()</code>中做的事，<code>View</code>和<code>ViewGroup</code>不太一样：</p>

<ul>
<li><code>View</code>在<code>onMeasure()</code>中根据父View传过来的MeasureSpec约束计算自己的大小并调用<code>setMeasuredDimension</code>保存下来。</li>
<li><code>ViewGroup</code>在<code>onMeasure</code>中调用<code>measureChildren</code>测量子View，并根据子View计算出的期望大小来计算出它们的实际尺寸和位置然后保存。同时根据子View的尺寸和位置来计算出自己的尺寸并保存。</li>
</ul>


<p>在<code>ViewGroup</code>测量子View的时候，也就是调用<code>childView.measure()</code>的时候需要将自己的约束MeasureSpec传递给子View，这个MeasureSpec如何计算，下面会说。回到最顶层的父View，也即<code>DecorView</code>，它的MeasureSpec是<code>LayoutParams.MATCH_PARENT, LayoutParams.MATCH_PARENT</code>。</p>

<p>布局过程，<code>layout()</code>方法被父View调用，在<code>layout()</code>方法中它会保存父View传进来的自己的位置和尺寸，并且调用<code>onLayout</code>来进行实际的内部布局。<code>onLayout</code>中做的事，<code>View</code>和<code>ViewGroup</code>也不一样：</p>

<ul>
<li><code>View</code>由于没有子View，它的<code>onLayout</code>什么也不做</li>
<li><code>ViewGroup</code>在<code>onLayout</code>中会调用自己所有子View的<code>layout</code>方法，把它们的尺寸和位置传给它们，让它们完成自我的内部布局。</li>
</ul>


<h4>全新定义 View 的尺寸</h4>

<p>子View在计算的时候需要保证计算结果满足父View MeasureSpec对自己的尺寸限制。<code>ViewGroup</code>提供了几个工具方法供我们调用：</p>

<p>```</p>

<pre><code>/**
 * Ask all of the children of this view to measure themselves, taking into
 * account both the MeasureSpec requirements for this view and its padding.
 * We skip children that are in the GONE state The heavy lifting is done in
 * getChildMeasureSpec.
 *
 * @param widthMeasureSpec The width requirements for this view
 * @param heightMeasureSpec The height requirements for this view
 */
protected void measureChildren(int widthMeasureSpec, int heightMeasureSpec) {
    final int size = mChildrenCount;
    final View[] children = mChildren;
    for (int i = 0; i &lt; size; ++i) {
        final View child = children[i];
        if ((child.mViewFlags &amp; VISIBILITY_MASK) != GONE) {
            measureChild(child, widthMeasureSpec, heightMeasureSpec);
        }
    }
}

/**
 * Ask one of the children of this view to measure itself, taking into
 * account both the MeasureSpec requirements for this view and its padding.
 * The heavy lifting is done in getChildMeasureSpec.
 *
 * @param child The child to measure
 * @param parentWidthMeasureSpec The width requirements for this view
 * @param parentHeightMeasureSpec The height requirements for this view
 */
protected void measureChild(View child, int parentWidthMeasureSpec,
        int parentHeightMeasureSpec) {
    final LayoutParams lp = child.getLayoutParams();

    final int childWidthMeasureSpec = getChildMeasureSpec(parentWidthMeasureSpec,
            mPaddingLeft + mPaddingRight, lp.width);
    final int childHeightMeasureSpec = getChildMeasureSpec(parentHeightMeasureSpec,
            mPaddingTop + mPaddingBottom, lp.height);

    child.measure(childWidthMeasureSpec, childHeightMeasureSpec);
}

/**
 * Does the hard part of measureChildren: figuring out the MeasureSpec to
 * pass to a particular child. This method figures out the right MeasureSpec
 * for one dimension (height or width) of one child view.
 *
 * The goal is to combine information from our MeasureSpec with the
 * LayoutParams of the child to get the best possible results. For example,
 * if the this view knows its size (because its MeasureSpec has a mode of
 * EXACTLY), and the child has indicated in its LayoutParams that it wants
 * to be the same size as the parent, the parent should ask the child to
 * layout given an exact size.
 *
 * @param spec The requirements for this view
 * @param padding The padding of this view for the current dimension and
 *        margins, if applicable
 * @param childDimension How big the child wants to be in the current
 *        dimension
 * @return a MeasureSpec integer for the child
 */
public static int getChildMeasureSpec(int spec, int padding, int childDimension) {
    int specMode = MeasureSpec.getMode(spec);
    int specSize = MeasureSpec.getSize(spec);

    int size = Math.max(0, specSize - padding);

    int resultSize = 0;
    int resultMode = 0;

    switch (specMode) {
    // Parent has imposed an exact size on us
    case MeasureSpec.EXACTLY:
        if (childDimension &gt;= 0) {
            resultSize = childDimension;
            resultMode = MeasureSpec.EXACTLY;
        } else if (childDimension == LayoutParams.MATCH_PARENT) {
            // Child wants to be our size. So be it.
            resultSize = size;
            resultMode = MeasureSpec.EXACTLY;
        } else if (childDimension == LayoutParams.WRAP_CONTENT) {
            // Child wants to determine its own size. It can't be
            // bigger than us.
            resultSize = size;
            resultMode = MeasureSpec.AT_MOST;
        }
        break;

    // Parent has imposed a maximum size on us
    case MeasureSpec.AT_MOST:
        if (childDimension &gt;= 0) {
            // Child wants a specific size... so be it
            resultSize = childDimension;
            resultMode = MeasureSpec.EXACTLY;
        } else if (childDimension == LayoutParams.MATCH_PARENT) {
            // Child wants to be our size, but our size is not fixed.
            // Constrain child to not be bigger than us.
            resultSize = size;
            resultMode = MeasureSpec.AT_MOST;
        } else if (childDimension == LayoutParams.WRAP_CONTENT) {
            // Child wants to determine its own size. It can't be
            // bigger than us.
            resultSize = size;
            resultMode = MeasureSpec.AT_MOST;
        }
        break;

    // Parent asked to see how big we want to be
    case MeasureSpec.UNSPECIFIED:
        if (childDimension &gt;= 0) {
            // Child wants a specific size... let him have it
            resultSize = childDimension;
            resultMode = MeasureSpec.EXACTLY;
        } else if (childDimension == LayoutParams.MATCH_PARENT) {
            // Child wants to be our size... find out how big it should
            // be
            resultSize = View.sUseZeroUnspecifiedMeasureSpec ? 0 : size;
            resultMode = MeasureSpec.UNSPECIFIED;
        } else if (childDimension == LayoutParams.WRAP_CONTENT) {
            // Child wants to determine its own size.... find out how
            // big it should be
            resultSize = View.sUseZeroUnspecifiedMeasureSpec ? 0 : size;
            resultMode = MeasureSpec.UNSPECIFIED;
        }
        break;
    }
    //noinspection ResourceType
    return MeasureSpec.makeMeasureSpec(resultSize, resultMode);
}
</code></pre>

<p>```</p>

<p>可以看到子View<code>MeasureSpec</code>是由3个因素共同决定的，父View的<code>MeasureSpec</code>，<code>padding</code>，<code>LayoutParams</code>中的值，其中父View的<code>MeasureSpec</code>是从<code>DecorView</code>一层层约束下来得到的，不难理解，那<code>LayoutParams</code>是从哪里来的呢？   其实<code>LayoutParams</code>是在<code>LayoutInflater</code>解析xml布局的时候，父布局会根据xml中的<code>layout_width</code>和<code>layout_height</code>来给子View<code>generateLayoutParams</code>保存在子View中，所以，可以认为子View的<code>LayoutParams</code>实际上保存的是布局中的开发者对View的要求。</p>

<p>着重看下<code>getChildMeasureSpec</code>这个方法，这个方法对父View尺寸有无限制的情况下子View的大小应该如何进行了处理，注释的比较清楚，就不解释了。</p>

<h4>定制 Layout(ViewGroup) 的内部布局</h4>

<p>通过重写<code>onMeasure()</code>来计算内部布局，重写<code>onLayout</code>来摆放子View。</p>

<p>重写<code>onMeasure()</code>的三个步骤：</p>

<ul>
<li>调用每个子View的<code>measure</code>方法来计算子View的尺寸</li>
<li>计算子View的位置并保存子View的位置和尺寸</li>
<li>计算自己的尺寸并用<code>setMeasuredDimension()</code>保存</li>
</ul>


<p>计算子View尺寸的关键在于<code>measure()</code>方法的两个MeasureSpec参数的计算。子View的<code>MeasureSpec</code>的计算方式：</p>

<ul>
<li>结合开发者的要求（xml中的layout_打头的属性）和自己的可用空间（自己的尺寸上限-已用尺寸）</li>
<li>尺寸上限根据自己的<code>MeasureSpec</code>中的mode而定，<code>EXACTLY/AT_MOST</code>尺寸上限为<code>MeasureSpec</code>中的size，<code>UNSPECIFIED</code>尺寸无上限。</li>
</ul>


<p>重写<code>onLayout</code>的方式，在<code>onLayout</code>里调用每个子View的<code>layout()</code>。</p>

<h4>reference</h4>

<ul>
<li><a href="https://hencoder.com/tag/bu-ju/">自定义 View &ndash; 布局</a></li>
</ul>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[自定义View总结一]]></title>
    <link href="http://Solarex.github.io/blog/2019/01/12/summary-of-custom-views-part-i/"/>
    <updated>2019-01-12T00:33:00+08:00</updated>
    <id>http://Solarex.github.io/blog/2019/01/12/summary-of-custom-views-part-i</id>
    <content type="html"><![CDATA[<h2>自定义View总结 &ndash; 绘制</h2>

<h3>绘制基础</h3>

<ul>
<li><code>Canvas.drawColor(@ColorInt int color)</code> 颜色填充</li>
<li><code>drawCircle(float centerX, float centerY, float radius, Paint paint)</code> 画圆</li>
<li><code>Paint.setColor(int color)</code>,<code>Paint.setStyle(Paint.Style style)</code>,<code>Paint.setStrokeWidth(float width)</code>,<code>Paint.setAntiAlias(boolean aa)</code></li>
<li><code>drawRect(float left, float top, float right, float bottom, Paint paint)</code> 画矩形</li>
<li><code>drawPoint(float x, float y, Paint paint)</code> 画点</li>
<li><code>drawPoints(float[] pts, int offset, int count, Paint paint) / drawPoints(float[] pts, Paint paint)</code> 画点（批量）</li>
<li><code>drawOval(float left, float top, float right, float bottom, Paint paint)</code>画椭圆</li>
<li><code>drawLine(float startX, float startY, float stopX, float stopY, Paint paint)</code> 画线</li>
<li><code>drawLines(float[] pts, int offset, int count, Paint paint) / drawLines(float[] pts, Paint paint)</code> 画线（批量）</li>
<li><code>drawRoundRect(float left, float top, float right, float bottom, float rx, float ry, Paint paint)</code> 画圆角矩形</li>
<li><code>drawArc(float left, float top, float right, float bottom, float startAngle, float sweepAngle, boolean useCenter, Paint paint)</code> 绘制弧形或扇形</li>
<li><code>drawPath(Path path, Paint paint)</code> 画自定义图形</li>
<li><code>drawBitmap(Bitmap bitmap, float left, float top, Paint paint)</code> 画 Bitmap</li>
<li><code>drawText(String text, float x, float y, Paint paint)</code>绘制文字</li>
</ul>


<!-- more -->


<h4>Path</h4>

<ul>
<li><code>addCircle(float x, float y, float radius, Direction dir)</code> 添加圆</li>
<li><code>addOval(float left, float top, float right, float bottom, Direction dir) / addOval(RectF oval, Direction dir)</code>添加椭圆</li>
<li><code>addRect(float left, float top, float right, float bottom, Direction dir) / addRect(RectF rect, Direction dir)</code>添加矩形</li>
<li><code>addRoundRect(RectF rect, float rx, float ry, Direction dir) / addRoundRect(float left, float top, float right, float bottom, float rx, float ry, Direction dir) / addRoundRect(RectF rect, float[] radii, Direction dir) / addRoundRect(float left, float top, float right, float bottom, float[] radii, Direction dir)</code>添加圆角矩形</li>
<li><code>addPath(Path path)</code> 添加另一个 Path</li>
<li><code>lineTo(float x, float y) / rLineTo(float x, float y)</code>画直线</li>
<li><code>quadTo(float x1, float y1, float x2, float y2) / rQuadTo(float dx1, float dy1, float dx2, float dy2)</code>画二次贝塞尔曲线</li>
<li><code>cubicTo(float x1, float y1, float x2, float y2, float x3, float y3) / rCubicTo(float x1, float y1, float x2, float y2, float x3, float y3)</code> 画三次贝塞尔曲线</li>
<li><code>moveTo(float x, float y) / rMoveTo(float x, float y)</code>移动到目标位置</li>
<li><code>arcTo(RectF oval, float startAngle, float sweepAngle, boolean forceMoveTo) / arcTo(float left, float top, float right, float bottom, float startAngle, float sweepAngle, boolean forceMoveTo) / arcTo(RectF oval, float startAngle, float sweepAngle)</code> 画弧形</li>
<li><code>addArc(float left, float top, float right, float bottom, float startAngle, float sweepAngle) / addArc(RectF oval, float startAngle, float sweepAngle)</code>,<code>addArc()</code> 只是一个直接使用了 <code>forceMoveTo = true</code> 的简化版 <code>arcTo()</code></li>
<li><code>close()</code>封闭当前子图形</li>
<li><code>Path.setFillType(Path.FillType ft)</code> 设置填充方式</li>
</ul>


<h3>Paint详解</h3>

<center><p><img src="http://Solarex.github.io/images/canvas-color.jpg" alt="Canvas绘制的内容，有三层对颜色的处理"></p></center>


<h4>颜色</h4>

<table>
<thead>
<tr>
<th></th>
<th align="center">     canvas 方法      </th>
<th> 像素颜色的设置方式 </th>
</tr>
</thead>
<tbody>
<tr>
<td></td>
<td align="center"> drawColor/RGB/ARGB() </td>
<td> 直接作为参数传入   |</td>
</tr>
<tr>
<td></td>
<td align="center"> drawBitmap() </td>
<td> 与<code>bitmap</code>参数的像素颜色相同 |</td>
</tr>
<tr>
<td></td>
<td align="center"> 图形和文字(drawCircle()/drawPath()/drawText()&hellip;) </td>
<td> 在<code>paint</code>参数中设置 |</td>
</tr>
</tbody>
</table>


<h5>直接设置颜色<code>Paint.setColor(int color)</code>,<code>Paint.setARGB(int a,int r,int g,int b)</code></h5>

<h5>setShader(Shader shader) 设置shader</h5>

<ul>
<li><p>shader着色器，它和直接设置颜色的区别是，着色器设置的是一个颜色方案，或者说是一套着色规则。</p></li>
<li><p>LinearGradient 线性渐变</p></li>
<li><p>RadialGradient 辐射渐变，辐射渐变很好理解，就是从中心向周围辐射状的渐变。</p></li>
<li><p>SweepGradient 扫描渐变</p></li>
<li><p>BitmapShader 用 Bitmap 来着色，其实也就是用 Bitmap 的像素来作为图形或文字的填充。</p></li>
<li><p>ComposeShader 混合着色器 所谓混合，就是把两个 Shader 一起使用。</p></li>
</ul>


<h5>setColorFilter(ColorFilter colorFilter)</h5>

<p>为绘制设置颜色过滤。颜色过滤的意思，就是为绘制的内容设置一个统一的过滤策略，然后 Canvas.drawXXX() 方法会对每个像素都进行过滤后再绘制出来。</p>

<ul>
<li><code>LightingColorFilter(int mul, int add)</code></li>
</ul>


<p><code>java
R' = R * mul.R / 0xff + add.R  
G' = G * mul.G / 0xff + add.G  
B' = B * mul.B / 0xff + add.B  
</code></p>

<ul>
<li><code>PorterDuffColorFilter(int color, PorterDuff.Mode mode)</code></li>
<li><code>ColorMatrixColorFilter</code></li>
</ul>


<p><code>ColorMatrixColorFilter</code> 使用一个 <code>ColorMatrix</code> 来对颜色进行处理。 <code>ColorMatrix</code> 这个类，内部是一个 4x5 的矩阵：</p>

<p>```java
[ a, b, c, d, e,
  f, g, h, i, j,
  k, l, m, n, o,
  p, q, r, s, t ]</p>

<p>R’ = a<em>R + b</em>G + c<em>B + d</em>A + e;<br/>
G’ = f<em>R + g</em>G + h<em>B + i</em>A + j;<br/>
B’ = k<em>R + l</em>G + m<em>B + n</em>A + o;<br/>
A’ = p<em>R + q</em>G + r<em>B + s</em>A + t;
```</p>

<p><a href="https://github.com/chengdazhi/StyleImageView">StyleImageView</a></p>

<h5>setXfermode(Xfermode xfermode)</h5>

<ul>
<li><p>使用离屏缓冲（Off-screen Buffer）</p></li>
<li><p>控制好透明区域</p></li>
</ul>


<h4>效果</h4>

<h5>setAntiAlias (boolean aa) 设置抗锯齿</h5>

<h5>setStyle(Paint.Style style)</h5>

<h5>线条形状</h5>

<ul>
<li><p><code>setStrokeWidth(float width)</code></p></li>
<li><p><code>setStrokeCap(Paint.Cap cap)</code></p></li>
<li><p><code>setStrokeJoin(Paint.Join join)</code></p></li>
<li><p><code>setStrokeMiter(float miter)</code></p></li>
</ul>


<h5>色彩优化</h5>

<ul>
<li><p><code>setDither(boolean dither)</code> 设置图像的抖动</p></li>
<li><p><code>setFilterBitmap(boolean filter)</code> 设置是否使用双线性过滤来绘制 Bitmap</p></li>
</ul>


<h5>setPathEffect(PathEffect effect)</h5>

<p>使用 <code>PathEffect</code> 来给图形的轮廓设置效果。对 Canvas 所有的图形绘制有效，也就是  <code>drawLine() drawCircle() drawPath()</code> 这些方法。</p>

<ul>
<li><p><code>CornerPathEffect</code> 把所有拐角变成圆角</p></li>
<li><p><code>DiscretePathEffect</code> 把线条进行随机的偏离，让轮廓变得乱七八糟。</p></li>
<li><p><code>DashPathEffect</code> 使用虚线来绘制线条</p></li>
<li><p><code>PathDashPathEffect</code> 这个方法比 DashPathEffect 多一个前缀 Path ，所以顾名思义，它是使用一个 Path 来绘制「虚线」。</p></li>
<li><p><code>SumPathEffect</code> 这是一个组合效果类的 PathEffect 。它的行为特别简单，就是分别按照两种 PathEffect 分别对目标进行绘制。</p></li>
<li><p><code>ComposePathEffect</code> 这也是一个组合效果类的 PathEffect 。不过它是先对目标 Path 使用一个 PathEffect，然后再对这个改变后的 Path 使用另一个 PathEffect。它的构造方法 <code>ComposePathEffect(PathEffect outerpe, PathEffect innerpe)</code> 中的两个  PathEffect 参数， innerpe 是先应用的， outerpe 是后应用的。</p></li>
</ul>


<h5>setShadowLayer(float radius, float dx, float dy, int shadowColor)</h5>

<p>在之后的绘制内容下面加一层阴影。如果要清除阴影层，使用 clearShadowLayer() 。</p>

<ul>
<li><p>在硬件加速开启的情况下， setShadowLayer() 只支持文字的绘制，文字之外的绘制必须关闭硬件加速才能正常绘制阴影。</p></li>
<li><p>如果 shadowColor 是半透明的，阴影的透明度就使用 shadowColor 自己的透明度；而如果 shadowColor 是不透明的，阴影的透明度就使用 paint 的透明度。</p></li>
</ul>


<h5>setMaskFilter(MaskFilter maskfilter)</h5>

<p>为之后的绘制设置 <code>MaskFilter</code>。上一个方法 <code>setShadowLayer()</code> 是设置的在绘制层下方的附加效果；而这个 <code>MaskFilter</code> 和它相反，设置的是在绘制层上方的附加效果。</p>

<ul>
<li><p><code>BlurMaskFilter</code> 模糊效果的 MaskFilter。<code>BlurMaskFilter(float radius, BlurMaskFilter.Blur style)</code> 中， radius 参数是模糊的范围， style 是模糊的类型。NORMAL: 内外都模糊绘制，SOLID: 内部正常绘制，外部模糊，INNER: 内部模糊，外部不绘制，OUTER: 内部不绘制，外部模糊。</p></li>
<li><p><code>EmbossMaskFilter</code> 浮雕效果的 MaskFilter。</p></li>
</ul>


<h5>获取绘制的 Path</h5>

<p>根据 paint 的设置，计算出绘制 Path 或文字时的实际 Path。所谓实际 Path ，指的就是 drawPath() 的绘制内容的轮廓，要算上线条宽度和设置的 PathEffect。</p>

<ul>
<li><p><code>getFillPath(Path src, Path dst)</code>，<code>getFillPath(src, dst)</code> 方法就能获取这个实际 Path。方法的参数里，src 是原 Path ，而 dst 就是实际 Path 的保存位置。 <code>getFillPath(src, dst)</code> 会计算出实际 Path，然后把结果保存在 dst 里。</p></li>
<li><p><code>getTextPath(String text, int start, int end, float x, float y, Path path) / getTextPath(char[] text, int index, int count, float x, float y, Path path)</code> 文字的绘制，虽然是使用 Canvas.drawText() 方法，但其实在下层，文字信息全是被转化成图形，对图形进行绘制的。  getTextPath() 方法，获取的就是目标文字所对应的 Path</p></li>
</ul>


<h4>Paint初始化类</h4>

<ul>
<li><p><code>reset()</code></p></li>
<li><p><code>set(Paint src)</code></p></li>
<li><p><code>setFlags(int flags)</code></p></li>
</ul>


<h3>文字的绘制</h3>

<h5>Canvas 绘制文字的方式</h5>

<ul>
<li><p><code>drawText(String text, float x, float y, Paint paint)</code></p></li>
<li><p><code>drawTextRun()</code></p></li>
<li><p><code>drawTextOnPath()</code></p></li>
<li><p><code>StaticLayout</code></p></li>
</ul>


<h5>Paint 对文字绘制的辅助</h5>

<ul>
<li><p><code>setTextSize(float textSize)</code></p></li>
<li><p><code>setTypeface(Typeface typeface)</code></p></li>
<li><p><code>setFakeBoldText(boolean fakeBoldText)</code> 伪粗体（ fake bold ），因为它并不是通过选用更高 weight 的字体让文字变粗，而是通过程序在运行时把文字给「描粗」了</p></li>
<li><p><code>setStrikeThruText(boolean strikeThruText)</code> 是否加删除线</p></li>
<li><p><code>setUnderlineText(boolean underlineText)</code> 是否加下划线</p></li>
<li><p><code>setTextSkewX(float skewX)</code> 设置文字横向错切角度。其实就是文字倾斜度的啦。</p></li>
<li><p><code>setTextScaleX(float scaleX)</code> 设置文字横向放缩。也就是文字变胖变瘦。</p></li>
<li><p><code>setLetterSpacing(float letterSpacing)</code> 设置字符间距。默认值是 0。</p></li>
<li><p><code>setFontFeatureSettings(String settings)</code></p></li>
<li><p><code>setTextAlign(Paint.Align align)</code> 设置文字的对齐方式。一共有三个值：LEFT CETNER 和 RIGHT。默认值为 LEFT。</p></li>
<li><p><code>setTextLocale(Locale locale) / setTextLocales(LocaleList locales)</code> 设置绘制所使用的 Locale。</p></li>
<li><p><code>setHinting(int mode)</code> 设置是否启用字体的 hinting （字体微调）。</p></li>
<li><p><code>setElegantTextHeight(boolean elegant)</code> 设置是否开启文字的 elegant height 。开启之后，文字的高度就变优雅了</p></li>
<li><p><code>setSubpixelText(boolean subpixelText)</code> 是否开启次像素级的抗锯齿（ sub-pixel anti-aliasing ）。</p></li>
<li><p><code>setLinearText(boolean linearText)</code></p></li>
<li><p><code>hasGlyph(String string)</code> 检查指定的字符串中是否是一个单独的字形 (glyph）。</p></li>
</ul>


<h5>测量文字尺寸类</h5>

<ul>
<li><p><code>float getFontSpacing()</code> 获取推荐的行距。</p></li>
<li><p><code>FontMetircs getFontMetrics()</code> 获取 Paint 的 FontMetrics。<code>FontMetrics</code> 是个相对专业的工具类，它提供了几个文字排印方面的数值：<code>ascent</code>,  <code>descent</code>, <code>top</code>, <code>bottom</code>, <code>leading</code>。<code>ascent</code> 和 <code>descent</code> 这两个值还可以通过 <code>Paint.ascent()</code> 和 <code>Paint.descent()</code> 来快捷获取。</p></li>
<li><p><code>getTextBounds(String text, int start, int end, Rect bounds)</code> 获取文字的显示范围。</p></li>
<li><p><code>float measureText(String text)</code> 测量文字的宽度并返回。</p></li>
</ul>


<p>如果你用代码分别使用 getTextBounds() 和 measureText() 来测量文字的宽度，你会发现  measureText() 测出来的宽度总是比 getTextBounds() 大一点点。这是因为这两个方法其实测量的是两个不一样的东西。getTextBounds: 它测量的是文字的显示范围（关键词：显示）。形象点来说，你这段文字外放置一个可变的矩形，然后把矩形尽可能地缩小，一直小到这个矩形恰好紧紧包裹住文字，那么这个矩形的范围，就是这段文字的 bounds。measureText(): 它测量的是文字绘制时所占用的宽度（关键词：占用）。前面已经讲过，一个文字在界面中，往往需要占用比他的实际显示宽度更多一点的宽度，以此来让文字和文字之间保留一些间距，不会显得过于拥挤。</p>

<ul>
<li><p><code>getTextWidths(String text, float[] widths)</code> 获取字符串中每个字符的宽度，并把结果填入参数 widths。</p></li>
<li><p><code>int breakText(String text, boolean measureForwards, float maxWidth, float[] measuredWidth)</code> 这个方法也是用来测量文字宽度的。但和 measureText() 的区别是， breakText() 是在给出宽度上限的前提下测量文字的宽度。如果文字的宽度超出了上限，那么在临近超限的位置截断文字。</p></li>
</ul>


<h5>光标相关</h5>

<ul>
<li><p><code>getRunAdvance(CharSequence text, int start, int end, int contextStart, int contextEnd, boolean isRtl, int offset)</code> 对于一段文字，计算出某个字符处光标的 x 坐标。</p></li>
<li><p><code>getOffsetForAdvance(CharSequence text, int start, int end, int contextStart, int contextEnd, boolean isRtl, float advance)</code> 给出一个位置的像素值，计算出文字中最接近这个位置的字符偏移量</p></li>
</ul>


<h3>Canvas 对绘制的辅助 clipXXX() 和 Matrix</h3>

<h5>范围裁切</h5>

<p>范围裁切有两个方法： <code>clipRect()</code> 和 <code>clipPath()</code>。裁切方法之后的绘制代码，都会被限制在裁切范围内。</p>

<ul>
<li><p><code>clipRect()</code></p></li>
<li><p><code>clipPath()</code></p></li>
</ul>


<h5>几何变换</h5>

<p>几何变换的使用大概分为三类：</p>

<ul>
<li>使用 Canvas 来做常见的二维变换；</li>
<li>使用 Matrix 来做常见和不常见的二维变换；</li>
<li>使用 Camera 来做三维变换。</li>
</ul>


<h6>使用 Canvas 来做常见的二维变换</h6>

<ul>
<li><p><code>Canvas.translate(float dx, float dy)</code> 平移</p></li>
<li><p><code>Canvas.rotate(float degrees, float px, float py)</code> 旋转</p></li>
<li><p><code>Canvas.scale(float sx, float sy, float px, float py)</code> 放缩</p></li>
<li><p><code>skew(float sx, float sy)</code> 错切</p></li>
</ul>


<h6>使用 Matrix 来做变换</h6>

<p>Matrix 做常见变换的方式：</p>

<ul>
<li>创建 Matrix 对象；</li>
<li>调用 Matrix 的 <code>pre/postTranslate/Rotate/Scale/Skew()</code> 方法来设置几何变换；</li>
<li>使用 <code>Canvas.setMatrix(matrix)</code> 或 <code>Canvas.concat(matrix)</code> 来把几何变换应用到 Canvas。</li>
</ul>


<p>把 Matrix 应用到 Canvas 有两个方法： <code>Canvas.setMatrix(matrix)</code> 和 <code>Canvas.concat(matrix)</code>。</p>

<ul>
<li><code>Canvas.setMatrix(matrix)</code>：用 Matrix 直接替换 Canvas 当前的变换矩阵，即抛弃 Canvas 当前的变换，改用 Matrix 的变换（注：根据下面评论里以及我在微信公众号中收到的反馈，不同的系统中 setMatrix(matrix) 的行为可能不一致，所以还是尽量用  concat(matrix) 吧）；</li>
<li><code>Canvas.concat(matrix)</code>：用 Canvas 当前的变换矩阵和 Matrix 相乘，即基于 Canvas 当前的变换，叠加上 Matrix 中的变换。</li>
</ul>


<p>使用 Matrix 来做自定义变换</p>

<ul>
<li><code>Matrix.setPolyToPoly(float[] src, int srcIndex, float[] dst, int dstIndex, int pointCount)</code> 用点对点映射的方式设置变换。poly 就是「多」的意思。setPolyToPoly() 的作用是通过多点的映射的方式来直接设置变换。「多点映射」的意思就是把指定的点移动到给出的位置，从而发生形变。例如：(0, 0) &ndash;> (100, 100) 表示把 (0, 0) 位置的像素移动到 (100, 100) 的位置，这个是单点的映射，单点映射可以实现平移。而多点的映射，就可以让绘制内容任意地扭曲。</li>
</ul>


<h6>使用 Camera 来做三维变换</h6>

<p>Camera 的三维变换有三类：旋转、平移、移动相机。</p>

<ul>
<li><p><code>Camera.rotate*()</code> 三维旋转 <code>Camera.rotate*()</code> 一共有四个方法： <code>rotateX(deg) rotateY(deg) rotateZ(deg) rotate(x, y, z)</code>。</p></li>
<li><p><code>Camera.translate(float x, float y, float z)</code> 移动</p></li>
<li><p><code>Camera.setLocation(x, y, z)</code> 设置虚拟相机的位置。在 Camera 中，相机的默认位置是 (0, 0, -8)（英寸）。8 x 72 = 576，所以它的默认位置是 (0, 0, -576)（像素）。</p></li>
</ul>


<h3>绘制顺序</h3>

<h5>super.onDraw() 前 or 后？</h5>

<h5><code>dispatchDraw()</code>：绘制子 View 的方法</h5>

<h5>绘制过程简述</h5>

<p>绘制过程中最典型的两个部分是上面讲到的主体和子 View，但它们并不是绘制过程的全部。除此之外，绘制过程还包含一些其他内容的绘制。具体来讲，一个完整的绘制过程会依次绘制以下几个内容：</p>

<ul>
<li>背景</li>
<li>主体（onDraw()）</li>
<li>子 View（dispatchDraw()）</li>
<li>滑动边缘渐变和滑动条</li>
<li>前景</li>
</ul>


<center><p><img src="http://Solarex.github.io/images/canvas-draw-process.jpg"/></p></center>


<h5>onDrawForeground()</h5>

<p>在 onDrawForeground() 中，会依次绘制滑动边缘渐变、滑动条和前景。</p>

<h5>draw() 总调度方法</h5>

<center><p><img src="http://Solarex.github.io/images/canvas-draw.jpg"/></p></center>


<p>关于绘制方法，有两点需要注意一下：</p>

<ul>
<li><p>出于效率的考虑，ViewGroup 默认会绕过 <code>draw()</code> 方法，换而直接执行  <code>dispatchDraw()</code>，以此来简化绘制流程。所以如果你自定义了某个 ViewGroup 的子类（比如 LinearLayout）并且需要在它的除 <code>dispatchDraw()</code> 以外的任何一个绘制方法内绘制内容，你可能会需要调用 <code>View.setWillNotDraw(false)</code> 这行代码来切换到完整的绘制流程（是「可能」而不是「必须」的原因是，有些 ViewGroup 是已经调用过  setWillNotDraw(false) 了的，例如 ScrollView）。</p></li>
<li><p>有的时候，一段绘制代码写在不同的绘制方法中效果是一样的，这时你可以选一个自己喜欢或者习惯的绘制方法来重写。但有一个例外：如果绘制代码既可以写在  <code>onDraw()</code> 里，也可以写在其他绘制方法里，那么优先写在 <code>onDraw()</code> ，因为 Android 有相关的优化，可以在不需要重绘的时候自动跳过 <code>onDraw()</code> 的重复执行，以提升开发效率。享受这种优化的只有 <code>onDraw()</code> 一个方法。</p></li>
</ul>


<h3>属性动画 Property Animation</h3>

<p> Android 里动画是有一些分类的：动画可以分为两类：Animation 和 Transition；其中 Animation 又可以再分为 View Animation 和 Property Animation 两类： View Animation 是纯粹基于 framework 的绘制转变，Property Animation，属性动画，这是在 Android 3.0 开始引入的新的动画形式。</p>

<p> ##### ViewPropertyAnimator</p>

<p> <center><p><img src="http://Solarex.github.io/images/view-animate.jpg"/></p></center></p>

<p> ##### ObjectAnimator</p>

<p>使用方式：</p>

<ul>
<li>如果是自定义控件，需要添加 setter / getter 方法；</li>
<li>用 ObjectAnimator.ofXXX() 创建 ObjectAnimator 对象；</li>
<li>用 start() 方法执行动画。</li>
</ul>


<h5>通用方法</h5>

<ul>
<li><p><code>setDuration(int duration)</code> 设置动画时长</p></li>
<li><p><code>setInterpolator(Interpolator interpolator)</code> 设置 Interpolator,<code>AccelerateDecelerateInterpolator</code>,<code>LinearInterpolator</code>,<code>AccelerateInterpolator</code>,<code>DecelerateInterpolator</code>,<code>AnticipateInterpolator</code>,<code>OvershootInterpolator</code>,<code>AnticipateOvershootInterpolator</code>,<code>BounceInterpolator</code>,<code>CycleInterpolator</code>,<code>PathInterpolator</code>,<code>FastOutLinearInInterpolator</code>,<code>FastOutSlowInInterpolator</code>,<code>LinearOutSlowInInterpolator</code></p></li>
</ul>


<h5>设置监听器</h5>

<p>设置监听器的方法， ViewPropertyAnimator 和 ObjectAnimator 略微不一样：  ViewPropertyAnimator 用的是 setListener() 和 setUpdateListener() 方法，可以设置一个监听器，要移除监听器时通过 set[Update]Listener(null) 填 null 值来移除；而  ObjectAnimator 则是用 addListener() 和 addUpdateListener() 来添加一个或多个监听器，移除监听器则是通过 remove[Update]Listener() 来指定移除对象。另外，由于 ObjectAnimator 支持使用 pause() 方法暂停，所以它还多了一个  addPauseListener() / removePauseListener() 的支持；而 ViewPropertyAnimator 则独有  withStartAction() 和 withEndAction() 方法，可以设置一次性的动画开始或结束的监听。</p>

<p>AnimatorListener 共有 4 个回调方法：</p>

<ul>
<li><p><code>onAnimationStart(Animator animation)</code></p></li>
<li><p><code>onAnimationEnd(Animator animation)</code></p></li>
<li><p><code>onAnimationCancel(Animator animation)</code></p></li>
<li><p><code>onAnimationRepeat(Animator animation)</code></p></li>
</ul>


<p><code>AnimatorUpdateListener</code>它只有一个回调方法：<code>onAnimationUpdate(ValueAnimator animation)</code></p>

<p><code>ViewPropertyAnimator.withStartAction/EndAction()</code>，<code>withStartAction() / withEndAction()</code> 是一次性的，在动画执行结束后就自动弃掉了，就算之后再重用 <code>ViewPropertyAnimator</code> 来做别的动画，用它们设置的回调也不会再被调用。而 <code>set/addListener()</code> 所设置的 <code>AnimatorListener</code> 是持续有效的，当动画重复执行时，回调总会被调用。<code>withEndAction()</code> 设置的回调只有在动画正常结束时才会被调用，而在动画被取消时不会被执行。这点和 <code>AnimatorListener.onAnimationEnd()</code> 的行为是不一致的。</p>

<h5>TypeEvaluator</h5>

<ul>
<li><p><code>ArgbEvaluator</code></p></li>
<li><p>自定义 Evaluator</p></li>
</ul>


<p>借助于 TypeEvaluator，属性动画就可以通过 ofObject() 来对不限定类型的属性做动画了。方式很简单：</p>

<ul>
<li><p>为目标属性写一个自定义的 TypeEvaluator</p></li>
<li><p>使用 ofObject() 来创建 Animator，并把自定义的 TypeEvaluator 作为参数填入</p></li>
</ul>


<h5>PropertyValuesHolder 同一个动画中改变多个属性</h5>

<h5>AnimatorSet 多个动画配合执行</h5>

<h5>PropertyValuesHolders.ofKeyframe() 把同一个属性拆分</h5>

<h3>硬件加速</h3>

<ul>
<li><p><a href="https://developer.android.google.cn/guide/topics/graphics/hardware-accel.html">Hardware Acceleration | Android Developers</a></p></li>
<li><p><a href="https://www.youtube.com/watch?v=v9S5EO7CLjo">Google I/O 2011: Accelerated Android Rendering</a></p></li>
</ul>


<p>所谓硬件加速，指的是把某些计算工作交给专门的硬件来做，而不是和普通的计算工作一样交给 CPU 来处理。这样不仅减轻了 CPU 的压力，而且由于有了「专人」的处理，这份计算工作的速度也被加快了。这就是「硬件加速」。</p>

<p>而对于 Android 来说，硬件加速有它专属的意思：在 Android 里，硬件加速专指把 View 中绘制的计算工作交给 GPU 来处理。进一步地再明确一下，这个「绘制的计算工作」指的就是把绘制方法中的那些 Canvas.drawXXX() 变成实际的像素这件事。</p>

<p>在硬件加速关闭的时候，Canvas 绘制的工作方式是：把要绘制的内容写进一个  Bitmap，然后在之后的渲染过程中，这个 Bitmap 的像素内容被直接用于渲染到屏幕。这种绘制方式的主要计算工作在于把绘制操作转换为像素的过程（例如由一句  Canvas.drawCircle() 来获得一个具体的圆的像素信息），这个过程的计算是由 CPU 来完成的。而在硬件加速开启时，Canvas 的工作方式改变了：它只是把绘制的内容转换为 GPU 的操作保存了下来，然后就把它交给 GPU，最终由 GPU 来完成实际的显示工作。</p>

<p>硬件加速不只是好处，也有它的限制：受到 GPU 绘制方式的限制，Canvas 的有些方法在硬件加速开启式会失效或无法正常工作。比如，在硬件加速开启时， clipPath() 在 API 18 及以上的系统中才有效。具体的 API 限制和 API 版本的关系如下图：</p>

<center><p><img src="http://Solarex.github.io/images/hardware-acceleration.jpg"></p></center>


<h5>View Layer</h5>

<p>setLayerType() 这个方法，它的作用其实就是名字里的意思：设置 View Layer 的类型。所谓 View Layer，又称为离屏缓冲（Off-screen Buffer），它的作用是单独启用一块地方来绘制这个 View ，而不是使用软件绘制的 Bitmap 或者通过硬件加速的 GPU。这块「地方」可能是一块单独的 Bitmap，也可能是一块 OpenGL 的纹理（texture，OpenGL 的纹理可以简单理解为图像的意思），具体取决于硬件加速是否开启。采用什么来绘制 View 不是关键，关键在于当设置了 View Layer 的时候，它的绘制会被缓存下来，而且缓存的是最终的绘制结果，而不是像硬件加速那样只是把 GPU 的操作保存下来再交给 GPU 去计算。通过这样更进一步的缓存方式，View 的重绘效率进一步提高了：只要绘制的内容没有变，那么不论是 CPU 绘制还是 GPU 绘制，它们都不用重新计算，而只要只用之前缓存的绘制结果就可以了。</p>

<p>基于这样的原理，在进行移动、旋转等（无需调用 invalidate()）的属性动画的时候开启 Hardware Layer 将会极大地提升动画的效率，因为在动画过程中 View 本身并没有发生改变，只是它的位置或角度改变了，而这种改变是可以由 GPU 通过简单计算就完成的，并不需要重绘整个 View。所以在这种动画的过程中开启 Hardware Layer，可以让本来就依靠硬件加速而变流畅了的动画变得更加流畅。</p>

<p>不过一定要注意，只有你在对 translationX translationY rotation alpha 等无需调用  invalidate() 的属性做动画的时候，这种方法才适用，因为这种方法本身利用的就是当界面不发生时，缓存未更新所带来的时间的节省。所以简单地说——这种方式不适用于基于自定义属性绘制的动画。</p>

<p>另外，由于设置了 View Layer 后，View 在初次绘制时以及每次 invalidate() 后重绘时，需要进行两次的绘制工作（一次绘制到 Layer，一次从 Layer 绘制到显示屏），所以其实它的每次绘制的效率是被降低了的。所以一定要慎重使用 View Layer，在需要用到它的时候再去使用。</p>

<h3>reference</h3>

<ul>
<li><a href="https://github.com/xinghongfei/awesome-view">awesome-view</a></li>
<li><a href="https://github.com/GcsSloop/AndroidNote/tree/master/CustomView">GcsSloop CustomView</a></li>
<li><a href="https://blog.csdn.net/aigestudio/column/info/androidcustomview">Android自定义控件其实很简单</a></li>
<li><a href="https://hencoder.com/tag/hui-zhi/">自定义View-绘制</a></li>
</ul>

]]></content>
  </entry>
  
</feed>
