---
layout: post
title: "Java AQS解析"
date: 2019-07-28 16:59
comments: true
categories: 
- java
- concurrency
---

``AbstractQueuedSynchronizer``是很多并发工具类如``ReentrantLock``的实现基础，本文对其进行分析。

<!-- more -->

Synchronizers possess two kinds of methods : at least one ``acquire`` operation that blocks the calling thread unless/until the synchronization state allows it to proceed, and at least one ``release`` operation that changes synchronization state in a way that may allow one or more blocked threads to unblock.

同步器提供两种方法：一个``acquire``方法在同步状态不允许线程通过运行时阻塞线程，一个``release``方法改变同步状态来允许一个或多个被阻塞的线程继续运行。

The ``java.util.concurrent`` package does not define a single unified API for synchronizers. Some are defined via common interfaces (e.g., ``Lock``), but others contain only specialized versions. So, ``acquire`` and ``release`` operations take a range of names and forms across different classes. For example, methods ``Lock.lock``,``Semaphore.acquire``, ``CountDownLatch.await``, and ``FutureTask.get`` all map to ``acquire`` operations in the framework. However, the package does maintain consistent conventions across classes to support a range of common usage options. When meaningful, each synchronizer supports:
+ Nonblocking synchronization attempts (for example,``tryLock``) as well as blocking versions.
+ Optional timeouts, so applications can give up waiting.
+ Cancellability via interruption, usually separated into one version of acquire that is cancellable, and one that isn't.

JUC没有为同步器定义一个统一的API。有一些是在通用的接口中定义的，比如``Lock``，但是其他的包括一些特殊的版本。所以不同同步器的``acquire``和``release``方法在名字和形态上表现不同。比如，``Lock.lock``，``Semaphore.acquire``，``CountDownLatch.await``和``FutureTask.get``和AQS框架中的``acquire``方法相对应。但是JUC框架在通用操作上保持了一致性。对于同步器来说，一般都支持以下操作：

+ 非阻塞尝试和阻塞尝试，比如``Lock.tryLock``和``Lock.lock``
+ 可选的超时，超时后线程可以放弃等待尝试
+ 在等待获取尝试的时候，对线程中断的响应或不响应

Synchronizers may vary according to whether they manage only ``exclusive`` states – those in which only one thread at a time may continue past a possible blocking point – versus possible ``shared`` states in which multiple threads can at least sometimes proceed.Regular lock classes of course maintain only exclusive state, but counting semaphores, for example, may be acquired by as many threads as the count permits. To be widely useful, the framework must support both modes of operation.

同步器可能会因为共享状态是独占还是可共享的而不同。一般锁维护的是独占状态，同时只能有一个线程持有锁，但是Semaphore可能同时被多个线程获取。AQS对这两种模式都支持。

### reference

+ [一行一行源码分析清楚 AbstractQueuedSynchronizer](https://javadoop.com/post/AbstractQueuedSynchronizer)
+ [一行一行源码分析清楚 AbstractQueuedSynchronizer（二）](https://javadoop.com/post/AbstractQueuedSynchronizer-2)
+ [一行一行源码分析清楚 AbstractQueuedSynchronizer（三）](https://javadoop.com/post/AbstractQueuedSynchronizer-3)
+ [AbstractQueuedSynchronizer的介绍和原理分析](http://ifeve.com/introduce-abstractqueuedsynchronizer/)
+ [深度解析 Java 8：JDK1.8 AbstractQueuedSynchronizer 的实现分析（上）](https://www.infoq.cn/article/jdk1.8-abstractqueuedsynchronizer)
+ [深度解析 Java 8：AbstractQueuedSynchronizer 的实现分析（下）](https://www.infoq.cn/article/java8-abstractqueuedsynchronizer)
+ [深入理解AbstractQueuedSynchronizer(AQS)](https://juejin.im/post/5aeb07ab6fb9a07ac36350c8)
+ [AbstractQueuedSynchronizer使用和源码分析](https://liuzhengyang.github.io/2017/05/12/aqs/)
+ [AbstractQueuedSynchronizer 源码分析 (基于Java 8)](https://www.jianshu.com/p/e7659436538b)
+ [源码分析JDK8之AbstractQueuedSynchronizer](https://segmentfault.com/a/1190000014221325)
+ [aqs.pdf](http://gee.cs.oswego.edu/dl/papers/aqs.pdf)
+ [CLH.pdf](http://www.cs.tau.ac.il/~shanir/nir-pubs-web/Papers/CLH.pdf)
+ [自旋锁、排队自旋锁、MCS锁、CLH锁](https://coderbee.net/index.php/concurrent/20131115/577)
