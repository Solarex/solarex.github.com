---
layout: post
title: "Java并发编程实战笔记"
date: 2018-06-03 21:43
comments: true
categories: 
- dev
- java
- notes
---
* [简介](#ch01)
* [线程安全性](#ch02)
* [对象的共享](#ch03)
* [对象的组合](#ch04)
* [基础构建模块](#ch05)
* [任务执行](#ch06)
* [取消与关闭](#ch07)
* [线程池的使用](#ch08)
* [图形用户界面应用程序](#ch09)
* [避免活跃性危险](#ch10)
* [性能和可伸缩性](#ch11)
* [并发程序的测试](#ch12)
* [显式锁](#ch13)
* [构建自定义的同步工具](#ch14)
* [原子变量与非阻塞同步机制](#ch15)
* [Java内存模型](#ch16)

<!-- more -->

<h2 id="ch01">简介</h2>
操作系统的出现使得计算机每次能运行多个程序，并且不同的程序都在单独的进程中运行：操作系统为每个独立执行的进程分配各种资源，包括内存，文件句柄以及安全证书等。如果需要的话，在不同的进程之间可以通过一些粗粒度的通信机制来交换数据，包括：套接字、信号处理器、共享内存、信号量以及文件等。

进程会共享进程范围内的资源，例如内存句柄和文件句柄，但每个线程都有各自的程序计数器、栈以及局部变量等。线程还提供了一种直观的分解模式来充分利用多处理器系统中的硬件并行性，而在同一个程序中的多个线程也可以被同时调度到多个CPU上运行。线程也被称为轻量级进程。在大多数操作系统上，都是以线程为基本的调度单位。

在设计良好的并发应用程序中，并发能提升程序的性能，但无论如何，线程总会带来某种程度的运行时开销。在多线程程序中，当线程调度器临时挂起活跃线程并转而运行另一个线程时，就会频繁地出现上下文切换操作，这种操作将带来极大的开销：保存和恢复执行上下文，丢失局部性，并且CPU时间将更多地话再线程调度而不是线程运行上。当线程共享数据时，必须使用同步机制，而这些同步机制往往会抑制某些编译器优化，使内存缓存区的数据无效，以及增加共享内存总线的同步流量。

<h2 id="ch02">线程安全性</h2>
要编写线程安全的代码，其核心在于要对状态访问操作进行管理，特别是对共享（shared）的和可变的（mutable）状态的访问。

如果当多个线程访问同一个可变的状态变量时没有使用合适的同步，那么程序就会出现错误。有三种方式可以修复这个问题：

+ 不在线程之间共享该状态变量
+ 将状态变量修改为不可变的变量
+ 在访问状态变量时使用同步

在并发编程中，这种由于不恰当的执行时序而出现不正确的结果是一种非常重要的情况，他有一个正式的名字：竞态条件（race condition）。

要避免竞态条件问题，就必须在某个线程修改该变量时，通过某种方式防止其他线程使用这个变量，从而确保其他线程只能在修改操作完成之前或之后读取和修改状态，而不是在修改状态的过程中。

Java提供了一种内置的锁机制来支持原子性：同步代码块（synchronized block）。同步代码块包括两部分：一个作为锁的对象引用，一个作为由这个锁保护的代码块。以关键字``synchronized``来修饰的方法就是一种横跨整个方法体的同步代码块，其中该同步代码块的锁就是方法调用所在的对象。静态的synchronized方法以class对象作为锁。

每个Java对象都可以用做一个可以实现同步的锁，这些锁被称为内置锁（intrinsic lock）或监视器锁（monitor lock）。线程在进入同步代码块之前会自动获取锁，并且在退出代码块时自动释放锁，而无论是通过正常的控制路径退出还是通过从代码块中抛出异常退出。获取内置锁的唯一途径是进入由这个锁保护的同步代码块或方法。Java内置锁相当于一种互斥体（或互斥锁），这意味着最多只有一个线程能持有这种锁。当线程A尝试获取一个由线程B持有的锁时，线程A必须等待或者阻塞，直到线程B释放这个锁。如果B永远不释放锁，那么A也将永远地等下去。

当某个线程请求一个由其他线程持有的锁时，发出请求的线程就会阻塞。然而，由于内置锁是可重入的，因此如果某个线程师徒获取一个已经由他自己持有的锁，那么这个请求就会成功。重入意味着获取锁的操作的粒度是线程而不是调用。重入的一种实现方法是，为每个锁关联一个获取计数值和一个所有者线程。当计数值为0时，这个锁就被认为是没有被任何线程持有。当线程请求一个未被持有的锁时，JVM将记下锁的持有者，并且将获取计数值置为1。如果同一个线程再次获取这个锁，计数值将递增，而当线程退出同步代码块时，计数值会相应地递减。当计数值为0时，这个锁将被释放。Java对象头的mark word会保存这些信息。

对于可能被多个线程同时访问的可变状态变量，在访问它的时候都需要持有同一个锁，在这种情况下，我们称状态变量是由这个锁保护的。一种常见的加锁约定是，将所有的可变状态都封装在对象内部，并通过对象的内置锁对所有访问可变状态的代码路径进行同步，是的在该对象上不会发生并发访问。在许多线程安全类中都使用了这种模式，例如Vector、Hashtable等其他同步集合类。

当执行时间较长的计算或者可能无法快速完成的操作时（例如，网络I/O或者控制台I/O），一定不要持有锁。

<h2 id="ch03">对象的共享</h2>
在没有同步的情况下，编译器、处理器以及运行时等都可能对操作的执行顺序进行一些意想不到的调整（重排序）。在缺乏足够同步的多线程程序中，要相对内存操作的执行顺序进行判断，几乎无法得出正确的结论。

Java内存模型要求，变量的读取操作和写入操作都必须是原子操作，但对于非volatile类型的long和double变量，JVM允许将64位的读操作或写操作分解为两个32位的操作。当读取一个非volatile类型的long变量时，如果对该变量的读操作和写操作是在不同的线程中执行，那么很可能读取到某个值的高32位和另一个值的低32位，因此，即使不考虑失效数据问题，在多线程程序中使用共享且可变的long和double等类型的变量也是不安全的，除非用volatile关键字来声明他们或者用锁保护起来。

Java提供了一种稍弱的同步机制，即volatile变量，用来确保将变量的更新操作通知到其他线程。当把变量声明为volatile类型后，编译器和运行时都会注意到这个变量是共享的，因此不会将该变量上的操作与其他内存操作一起重排序。volatile变量不会被缓存在寄存器或者对其他处理器不可见的地方，因此在读取volatile变量时总是返回最新写入的值。对volatile变量的写总是happens before对volatile变量的读。对volatile变量的写会导致其他处理器缓存行失效，会从内存中重新读取值。volatile变量通常用作某个操作完成、发生中断或者状态的标志。

加锁机制既可以保证可见性又可以保证原子性，而volatile变量只能保证可见性。volatile语义不足以确保递增操作的原子性。

当且仅当满足以下所有条件时，才应该使用volatile变量：

+ 对变量的写入操作不依赖变量的当前值，或者你能保证只有单个线程更新变量的值。
+ 该变量不会与其他状态变量一起纳入不可变条件中。
+ 在访问变量时不需要加锁。

当且仅当对象的构造函数返回时，对象才处于可预测的和一致的状态。因此，当从对象的构造函数中发布对象时，只是发布了一个尚未构造完成的对象。如果this引用在构造过程中逸出，那么这种对象就被认为是不正确构造。``不要在构造过程中使this引用逸出``

不可变对象一定是线程安全的。

当满足以下条件时，对象才是不可变的：

+ 对象创建之后其状态就不能修改
+ 对象的所有域都是final类型
+ 对象是正确创建的（在对象的创建期间，this引用没有逸出）

final类型的域是不能修改的（但如果final域引用的对象是可变的，那么这些被引用的对象是可以修改的）。Java内存模型中，final域还有着特殊的语义。final域能确保初始化过程的安全性，从而可以不受限制地访问不可变对象，并在共享这些对象时无需使用同步。

要安全地发布一个对象，对象的引用以及对象的状态必须同时对其他线程可见。一个正确构造的对象可以通过以下方式来安全地发布：

+ 在静态初始化函数中初始化一个对象引用
+ 将对象的引用保存到volatile类型的域或者AtomicReference对象中
+ 将对象的引用保存到某个正确构造对象的final域中
+ 将对象的引用保存到一个由锁保护的域中

在并发程序中使用和共享对象时，可以使用一些实用的策略，包括：

+ 线程封闭。线程封闭的对象只能由一个线程拥有，对象被封闭在该线程中，并且只能由这个线程修改，如ThreadLocal对象
+ 只读共享。在没有额外同步的情况下，共享的只读对象可以由多个线程并发访问，但任何线程都不能修改它。共享的只读对象包括不可变对象和事实不可变对象。final对象
+ 线程安全的共享。线程安全的对象在其内部实现同步，因此多个线程可以通过对象的公有接口来进行访问而不需要进一步的同步。如使用线程安全的容器
+ 保护对象。被保护的对象只能通过持有特定的锁来访问。保护对象包括封装在其他线程安全对象中的对象，以及已发布的并且由某个特定锁保护的对象。

<h2 id="ch04">对象的组合</h2>
在设计线程安全类的过程中，需要包含以下三个基本要素：

+ 找出构成对象状态的所有变量
+ 找出约束状态变量的不变性条件
+ 建立对象状态的并发访问管理策略

如果不了解对象的不变性条件与后验条件，那么就不能确保线程安全性。要满足在状态变量的有效值或状态转换上的各种约束条件，就需要借助于原子性与封装性。

<h2 id="ch05">基础构建模块</h2>
同步容器类包括Vector和Hashtable，二者是早期JDK的一部分，此外还包括在JDK1.2中添加的一些功能相似的类，这些同步的封装器类是由``Collections.synchronizedXXX``等工厂方法创建的。这些类实现线程安全的方式是：将他们的状态封装起来，并对每个公有方法都进行同步，使得每次只有一个线程能访问容器的状态。

同步容器类都是线程安全的，但在某些情况下可能需要额外的客户端加锁来保护复合操作。容器上常见的复合操作包括：迭代（反复访问元素，直到遍历完容器中所有元素）、跳转（根据指定顺序找到当前元素的下一个元素）以及条件运算（如“若没有就添加”，检查Map中是否存在键值K，如果没有，就加入二元组(K,V)）。在同步容器类中，这些复合操作在没有客户端加锁的情况下仍然是线程安全的，但当其他线程并发地修改容器时，它们可能会表现出意料之外的行为。

许多现代的容器类也并没有消除复合操作中的问题。无论在直接迭代还是在Java5.0引入的for-each循环语句中，对容器类进行迭代的标准方式都是使用Iterator。然而，如果有其他线程并发地修改容器，那么即使是使用迭代器也无法避免在迭代期间对容器加锁。在设计同步容器类的迭代器时并没有考虑到并发修改的问题，并且他们表现出的行为是及时失败fail-fast的。这意味着，当他们发现容器在迭代过程中被修改时，就会抛出一个ConcurrentModificationException异常。

容器的toString、hashCode、equals等方法也会间接地执行迭代操作，当容器作为另一个容器的元素或键值时，就会出现这种情况。同样，containsAll、removeAll、retainAll等方法，以及把容器作为参数的构造函数，都会对容器进行迭代。所有这些间接的迭代操作都可能抛出ConcurrentModificationException。

通过并发容器来代替同步容器，可以极大地提高伸缩性并降低风险。

Java5.0增加了两种新的容器类型：Queue和BlockingQueue。Queue用来临时保存一组等待处理的元素。它提供了几种实现，包括ConcurrentLinkedQueue，这是一个传统的先进先出队列，以及PriorityQueue，这是一个非并发优先队列。Queue上的操作不会阻塞，如果队列为空，那么获取元素的操作将返回空值。虽然可以用List来模拟Queue的行为——事实上，正是通过LinkedList来实现Queue的，但还需要一个Queue的类，因为它能去掉List的随机访问需求，从而实现更高效的并发。

BlockingQueue扩展了Queue，增加了可阻塞的插入和获取等操作。如果队列为空，那么获取元素的操作将一直阻塞，知道队列中出现一个可用的元素。如果队列已满（对于有界队列来说），那么插入操作将一直阻塞，只到队列中出现ke'yong的空间。

正如ConcurrentHashMap用于代替基于散列的同步Map，Java6也引入了ConcurrentSkipListMap和ConcurrentSkipListSet，分别作为同步的SortedMap和SortedSet的并发替代品（例如用synchronizedMap包装起来的TreeMap或TreeSet）。

ConcurrentHashMap使用分段锁来实现更大程度的共享，任意数量的读线程可以并发地访问Map，执行读取操作的线程和执行写入操作的线程可以并发的访问Map，并且一定数量的写入线程可以并发地修改Map。

```java
public interface ConcurrentMap<K,V> extends Map<K,V> {
    //仅当K没有相应的映射值时才插入
    V putIfAbsent(K key,V value);
    //仅当K被映射到V时才移除
    boolean remove(K key,V value);
    //仅当K被映射到oldValue时才替换为newValue
    boolean replace(K key,V oldValue,V newValue);
    //仅当K被映射到某个值时才替换为newValue
    V replace(K key, V newValue);
}
```

<h2 id="ch06">任务执行</h2>
<h2 id="ch07">取消与关闭</h2>
<h2 id="ch08">线程池的使用</h2>
<h2 id="ch09">图形用户界面应用程序</h2>
<h2 id="ch10">避免活跃性危险</h2>
<h2 id="ch11">性能和可伸缩性</h2>
<h2 id="ch12">并发程序的测试</h2>
<h2 id="ch13">显式锁</h2>
<h2 id="ch14">构建自定义的同步工具</h2>
<h2 id="ch15">原子变量与非阻塞同步机制</h2>
<h2 id="ch16">Java内存模型</h2>
