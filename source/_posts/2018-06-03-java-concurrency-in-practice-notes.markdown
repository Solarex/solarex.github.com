---
layout: post
title: "java-concurrency-in-practice-notes"
date: 2018-06-03 21:43
comments: true
categories: 
- dev
- java
---
* [简介](#ch01)
* [线程安全性](#ch02)
* [对象的共享](#ch03)
* [对象的组合](#ch04)
* [基础构建模块](#ch05)
* [任务执行](#ch06)
* [取消与关闭](#ch07)
* [线程池的使用](#ch08)
* [图形用户界面应用程序](#ch09)
* [避免活跃性危险](#ch10)
* [性能和可伸缩性](#ch11)
* [并发程序的测试](#ch12)
* [显式锁](#ch13)
* [构建自定义的同步工具](#ch14)
* [原子变量与非阻塞同步机制](#ch15)
* [Java内存模型](#ch16)

<!-- more -->

<h2 id="ch01">简介</h2>
操作系统的出现使得计算机每次能运行多个程序，并且不同的程序都在单独的进程中运行：操作系统为每个独立执行的进程分配各种资源，包括内存，文件句柄以及安全证书等。如果需要的话，在不同的进程之间可以通过一些粗粒度的通信机制来交换数据，包括：套接字、信号处理器、共享内存、信号量以及文件等。

进程会共享进程范围内的资源，例如内存句柄和文件句柄，但每个线程都有各自的程序计数器、栈以及局部变量等。线程还提供了一种直观的分解模式来充分利用多处理器系统中的硬件并行性，而在同一个程序中的多个线程也可以被同时调度到多个CPU上运行。线程也被称为轻量级进程。在大多数操作系统上，都是以线程为基本的调度单位。

在设计良好的并发应用程序中，并发能提升程序的性能，但无论如何，线程总会带来某种程度的运行时开销。在多线程程序中，当线程调度器临时挂起活跃线程并转而运行另一个线程时，就会频繁地出现上下文切换操作，这种操作将带来极大的开销：保存和恢复执行上下文，丢失局部性，并且CPU时间将更多地话再线程调度而不是线程运行上。当线程共享数据时，必须使用同步机制，而这些同步机制往往会抑制某些编译器优化，使内存缓存区的数据无效，以及增加共享内存总线的同步流量。

<h2 id="ch02">线程安全性</h2>
要编写线程安全的代码，其核心在于要对状态访问操作进行管理，特别是对共享（shared）的和可变的（mutable）状态的访问。

如果当多个线程访问同一个可变的状态变量时没有使用合适的同步，那么程序就会出现错误。有三种方式可以修复这个问题：

+ 不在线程之间共享该状态变量
+ 将状态变量修改为不可变的变量
+ 在访问状态变量时使用同步

在并发编程中，这种由于不恰当的执行时序而出现不正确的结果是一种非常重要的情况，他有一个正式的名字：竞态条件（race condition）。

要避免竞态条件问题，就必须在某个线程修改该变量时，通过某种方式防止其他线程使用这个变量，从而确保其他线程只能在修改操作完成之前或之后读取和修改状态，而不是在修改状态的过程中。

Java提供了一种内置的锁机制来支持原子性：同步代码块（synchronized block）。同步代码块包括两部分：一个作为锁的对象引用，一个作为由这个锁保护的代码块。以关键字``synchronized``来修饰的方法就是一种横跨整个方法体的同步代码块，其中该同步代码块的锁就是方法调用所在的对象。静态的synchronized方法以class对象作为锁。

每个Java对象都可以用做一个可以实现同步的锁，这些锁被称为内置锁（intrinsic lock）或监视器锁（monitor lock）。线程在进入同步代码块之前会自动获取锁，并且在退出代码块时自动释放锁，而无论是通过正常的控制路径退出还是通过从代码块中抛出异常退出。获取内置锁的唯一途径是进入由这个锁保护的同步代码块或方法。Java内置锁相当于一种互斥体（或互斥锁），这意味着最多只有一个线程能持有这种锁。当线程A尝试获取一个由线程B持有的锁时，线程A必须等待或者阻塞，直到线程B释放这个锁。如果B永远不释放锁，那么A也将永远地等下去。

当某个线程请求一个由其他线程持有的锁时，发出请求的线程就会阻塞。然而，由于内置锁是可重入的，因此如果某个线程师徒获取一个已经由他自己持有的锁，那么这个请求就会成功。重入意味着获取锁的操作的粒度是线程而不是调用。重入的一种实现方法是，为每个锁关联一个获取计数值和一个所有者线程。当计数值为0时，这个锁就被认为是没有被任何线程持有。当线程请求一个未被持有的锁时，JVM将记下锁的持有者，并且将获取计数值置为1。如果同一个线程再次获取这个锁，计数值将递增，而当线程退出同步代码块时，计数值会相应地递减。当计数值为0时，这个锁将被释放。Java对象头的mark word会保存这些信息。

对于可能被多个线程同时访问的可变状态变量，在访问它的时候都需要持有同一个锁，在这种情况下，我们称状态变量是由这个锁保护的。一种常见的加锁约定是，将所有的可变状态都封装在对象内部，并通过对象的内置锁对所有访问可变状态的代码路径进行同步，是的在该对象上不会发生并发访问。在许多线程安全类中都使用了这种模式，例如Vector、Hashtable等其他同步集合类。

当执行时间较长的计算或者可能无法快速完成的操作时（例如，网络I/O或者控制台I/O），一定不要持有锁。

<h2 id="ch03">对象的共享</h2>
在没有同步的情况下，编译器、处理器以及运行时等都可能对操作的执行顺序进行一些意想不到的调整（重排序）。在缺乏足够同步的多线程程序中，要相对内存操作的执行顺序进行判断，几乎无法得出正确的结论。

Java内存模型要求，变量的读取操作和写入操作都必须是原子操作，但对于非volatile类型的long和double变量，JVM允许将64位的读操作或写操作分解为两个32位的操作。当读取一个非volatile类型的long变量时，如果对该变量的读操作和写操作是在不同的线程中执行，那么很可能读取到某个值的高32位和另一个值的低32位，因此，即使不考虑失效数据问题，在多线程程序中使用共享且可变的long和double等类型的变量也是不安全的，除非用volatile关键字来声明他们或者用锁保护起来。

Java提供了一种稍弱的同步机制，即volatile变量，用来确保将变量的更新操作通知到其他线程。当把变量声明为volatile类型后，编译器和运行时都会注意到这个变量是共享的，因此不会将该变量上的操作与其他内存操作一起重排序。volatile变量不会被缓存在寄存器或者对其他处理器不可见的地方，因此在读取volatile变量时总是返回最新写入的值。对volatile变量的写总是happens before对volatile变量的读。对volatile变量的写会导致其他处理器缓存行失效，会从内存中重新读取值。volatile变量通常用作某个操作完成、发生中断或者状态的标志。

加锁机制既可以保证可见性又可以保证原子性，而volatile变量只能保证可见性。volatile语义不足以确保递增操作的原子性。

当且仅当满足以下所有条件时，才应该使用volatile变量：

+ 对变量的写入操作不依赖变量的当前值，或者你能保证只有单个线程更新变量的值。
+ 该变量不会与其他状态变量一起纳入不可变条件中。
+ 在访问变量时不需要加锁。

当且仅当对象的构造函数返回时，对象才处于可预测的和一致的状态。因此，当从对象的构造函数中发布对象时，只是发布了一个尚未构造完成的对象。如果this引用在构造过程中逸出，那么这种对象就被认为是不正确构造。``不要在构造过程中使this引用逸出``

不可变对象一定是线程安全的。

当满足以下条件时，对象才是不可变的：

+ 对象创建之后其状态就不能修改
+ 对象的所有域都是final类型
+ 对象是正确创建的（在对象的创建期间，this引用没有逸出）

final类型的域是不能修改的（但如果final域引用的对象是可变的，那么这些被引用的对象是可以修改的）。Java内存模型中，final域还有着特殊的语义。final域能确保初始化过程的安全性，从而可以不受限制地访问不可变对象，并在共享这些对象时无需使用同步。

<h2 id="ch04">对象的组合</h2>
<h2 id="ch05">基础构建模块</h2>
<h2 id="ch06">任务执行</h2>
<h2 id="ch07">取消与关闭</h2>
<h2 id="ch08">线程池的使用</h2>
<h2 id="ch09">图形用户界面应用程序</h2>
<h2 id="ch10">避免活跃性危险</h2>
<h2 id="ch11">性能和可伸缩性</h2>
<h2 id="ch12">并发程序的测试</h2>
<h2 id="ch13">显式锁</h2>
<h2 id="ch14">构建自定义的同步工具</h2>
<h2 id="ch15">原子变量与非阻塞同步机制</h2>
<h2 id="ch16">Java内存模型</h2>
