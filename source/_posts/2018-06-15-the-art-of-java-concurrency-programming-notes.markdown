---
layout: post
title: "Java并发编程的艺术笔记"
date: 2018-06-15 23:04
comments: true
categories: 
- dev
- java
- notes
---
* [并发编程的挑战](#ch01)
* [Java并发机制的底层实现原理](#ch02)
* [Java内存模型](#ch03)
* [Java并发编程基础](#ch04)
* [Java中的锁](#ch05)
* [Java并发容器和框架](#ch06)
* [Java中的13个原子操作类](#ch07)
* [Java中的并发工具类](#ch08)
* [Java中的线程池](#ch09)
* [Executor框架](#ch10)
* [Java并发编程实践](#ch11)

<!-- more -->

<h2 id="ch01">并发编程的挑战</h2>
利用``vmstat``测量上下文切换次数。CS(Context Switch)

减少上下文切换的方法有无锁并发编程、CAS算法、使用最少线程和使用协程。

+ 无锁并发编程。多线程竞争锁时，会引起上下文切换，所以多线程处理数据时，可以用一些办法来避免使用锁，如将数据的ID按照Hash算法取模分段，不同的线程处理不同段的数据。
+ CAS算法。Java的Atomic包使用CAS算法来更新数据，而不需要加锁。
+ 使用最少线程。避免创建不需要的线程，比如任务很少，但是创建了很多线程来处理，这样会使大量线程处于等待状态。
+ 协程：在单线程里实现多任务的调度，并在单线程里维持多个任务间的切换。

``sudo -u admin jstack {pid}``

避免死锁的几种常见方法：

+ 避免一个线程同时获取多个锁
+ 避免一个线程在锁内同时占用多个资源，尽量保证每个锁只占用一个资源
+ 尝试使用定时锁，使用``lock.tryLock(timeout)``来替代使用内置锁机制
+ 对于数据库锁，加锁和解锁必须在一个数据库连接里，否则会出现解锁失败的情况


<h2 id="ch02">Java并发机制的底层实现原理</h2>

<h2 id="ch03">Java内存模型</h2>

<h2 id="ch04">Java并发编程基础</h2>

<h2 id="ch05">Java中的锁</h2>

<h2 id="ch06">Java并发容器和框架</h2>

<h2 id="ch07">Java中的13个原子操作类</h2>

<h2 id="ch08">Java中的并发工具类</h2>

<h2 id="ch09">Java中的线程池</h2>

<h2 id="ch10">Executor框架</h2>

<h2 id="ch11">Java并发编程实践</h2>

